################################# data : basic #################################

################################# data : parse #################################
⧫. regex_set ==> ι=>{
	# ! low quality ,scrap
	ι = (ι+'').replace(/\n$/,'')
	t←[] ;[…[…ι].∪([])]._.sortBy().map(ι=>{ ι = ord(ι) ;t[-1]&&t[-1][1] === ι-1? (t[-1][1] = ι) : t.push([ι,ι]) })
	x ← ι=>{ ι = chr(ι) ;↩ {'-':1,']':1,'\\':1}[ι]? '\\'+ι : ι==="'"? ι : node.util.inspect(ι).slice(1,-1).replace(/\\u00/g,'\\x') }
	ι = t.map(ι=> ι[0] === ι[1]? x(ι[0]) : ι[0] === ι[1]-1? x(ι[0])+x(ι[1]) : x(ι[0])+'-'+x(ι[1]) ).join('')
	↩ ι }

⧫. schema ==>{
	sc_merge ← (a,b)=>{ ak ← _u.keys(a) ;bk ← _u.keys(b) ;bk.-(ak).forEach(k=> a[k] = b[k]) ;ak.∩(bk).forEach(k=> a[k] = !Tprim(a[k])? sc_merge(a[k],b[k]) : !Tprim(b[k])? 'error' : a[k]) ;↩ a }
	↩ ι=> T.boolean(ι)? ✓ : Tstr(ι)? '' : Tnum(ι)? 0 : Tarr(ι)? !ι.‖? [] : [ι.map(schema).fold(sc_merge)] : _u.pairs(ι).map(ι=> [ι[0],schema(ι[1])])._.object()
	}

################################## data : time #################################

################################ data : numeric ################################
⧫. numeric2 ==>{
	nk ← npm`numeric@1.2.6`
	norm∞ ← ι=> nk.div( ι ,ι.fold(nk.max.XX) )
	norm1 ← ι=> nk.div( ι ,ι.fold(nk.add.XX) )
	mean ← ι=> nk.diveq( ι.fold(nk.add.XX) ,ι.‖ )
	norm∞_affine_sorted_E ← ι=>( nk.subeq(ι,ι[0]) ,nk.diveq(ι,ι[-1]) )
	↩ {,nk,norm∞,norm1,mean,norm∞_affine_sorted_E} }
⧫. normal_PDF ==> x=>{ μ ← 0 ;σ ← 1 ;v ← σ**2 ;↩ 1/sqrt(v*τ)*exp(-((x-μ)**2)/(2*v)) }
⧫. normal_CDF ==> x=>{ μ ← 0 ;σ ← 1 ;↩ (1 + npm`math-erf@1.0.0`( (x-μ) / (σ*sqrt(2)) ))/2 }

################################# data : color #################################
⧫. color ==>{
	color ← npm`color@2.0.1`
	color.interpolate_0 = (c,x)=>{ x *= c.‖ ;i ← x|0 ;r ← x-i ;↩ c[i%c.‖].mix(c[(i+1)%c.‖] ,1-r) }
	color.prototype‘.i .get= λ(){ ι ← @.rgb().color ;↩ ( ι[0]<<24 | ι[1]<<16 | ι[2]<<8 | 0xff )>>>0 }
	↩ color }

######################### net incl context device,proc #########################
⧫. lock ==>{
	fs ← node.fs ;util ← node.util
	;fs_close ← util.promisify(fs.close) ;fs_unlink ← util.promisify(fs.unlink) ;fs_open ← util.promisify(fs.open)
	locks ← {}
	𐅨𐅯 ← id=> φ`/tmp/lock_${id}`+''
	♓_on_exits(=> _u.keys(locks).map(id=>{ try{ fs.unlinkSync(𐅨𐅯(id)) }catch(e){} }) )
	lock ← (id,opt)=> fs_open(𐅨𐅯(id),'wx').then(
		,fd=>( locks[id] = ✓ ,fs_close(fd).then(=> =>lock.un(id) ) )
		,e=>{ T.Error(e) || ‽ ;opt||(opt={}) ;'wait' in opt ||(opt.wait = 0)
			if(!( e.code==='EEXIST' && opt.wait > 0 )) ↩ Π(e)
			else{ w ← min(opt.wait,0.1) ;opt.wait -= w ;↩ (=> lock(id,opt)).in_Π(w) }
			} )
	lock.un = id=>( delete locks[id] ,fs_unlink(𐅨𐅯(id)) )
	lock.∃ = id=> fs_open(𐅨𐅯(id),'r').then(
		,fd=>( fs.close(fd) ,✓ )
		,e=> e.code==='ENOENT'? ✗ : Π(e) )
	↩ lock }

⧫. stream4 ==>{ E ← {}
	E.send_json = memoize_weak(s=>{ ;t ← npm`through2@2.0.3`.obj((ι,ˣ,cb)=>cb(∅,JSON.stringify(ι)+'\n')) ;t.pipe(s) ;↩ t‘.write .f })
	E.as_json = memoize_weak(s=>{ ;t ← npm`split2@2.2.0`(ι=>{ try{↩ JSON.parse(ι) }catch(e){ @.emit('error',e) } }) ;s.pipe(t) ;↩ t.P`data` })
	↩ E }

⧫. net1 ==>{ E ← {}
	E.open_send = at=> Π((yes,no)=>{ if(! at )↩ no() ;r ← new node.net.Socket() ;r.unref().on('error',no).connect(at).on('connect',=>yes(r)) })
	E.device_listen = (port=0)=>{ r ← new node.net.Server().listen(port,'localhost') ;↩ r.Π`listening`.then(=> r) }
	node.net.Server.prototype.just_first_json = λ(){↩ @.Π`connection`.then(s=> stream4.as_json(s).Π.then(ι=>{ ;s.end() ;@.close() ;↩ ι })) }
	node.net.Server.prototype‘.at .get= λ(){t← ;↩ @.𐅭𐅝𐅯𐅨𐅋||(@.𐅭𐅝𐅯𐅨𐅋= [(t=@.address()).address,t.port]) }
	↩ E }

⧫. Π ==> ι⇒
	: Tfun(ι) && /^(re|yes|\(yes,no\))=>/.test(ι+'')? new Promise(ι)
	: T.Error(ι)? Πx(ι)
	: Promise.resolve(ι)
⧫. Πx ==> ι=> Promise.reject(ι)
⧫. Πand ==> (…ι)=> Promise.all(ι)
⧫. Πor ==> (…ι)=> Promise.race(ι)

⧫. @deviceΠ = => ι=>{ start ← Tfun(ι)
	φ_on_E ← ι=> Π(re=>{ 𐅪 ← ι.∃? re() : npm`chokidar@2.0.0`.watch(ι+'',{persistent:✓}).on('all',=> ι.∃ &&( 𐅪.close() ,re() )) })
	id ← !start? ι : random_id.greek(9)
	𐅞 ← @device0('Π'+id)
	re ← (ι=>{ 𐅞.ι = ι }) …←({ ,id ,toString:=>r+'.re' })
	r ← { ,id ,re ,toString:=>ζjs`@deviceΠ(${id})` } !>(‘.Π .get==> φ_on_E(𐅞.o).then(=> 𐅞.ι))
	start && ι(re)
	↩ r }

############################### friend glue : ui ###############################
⧫. electron_window_for ==>{
	# interaction with previous versions: unsolved
	𐅰𐅃𐅬𐅦𐅜electron ← {
		,init:=> _electron__start_my().Π
		,ι: @device0`𐅰𐅃𐅬𐅦𐅜electron`
		# @proc alive_at: time of last message received from
		# @proc path_to
		,path_init:=> !𐅩.ι.ι? Πx() :( 𐅩.path_to = net1.open_send(𐅩.ι.ι[1]) !>(.then(ι=> Πor(ι.Π`close`,ι.Π`end`).then(=> 𐅩.path_to = ∅ ) ,=>∅)) )
		,path_to:∅
		} ;𐅩 ← 𐅰𐅃𐅬𐅦𐅜electron
	send_to_my ← ι=>{
		𐅯 ← => 𐅩.path_init() !>(.then(s=> stream4.send_json(s)(ι) ,=>∅))
		𐅯().catch(=>{
			lock('𐅂𐅂𐅪𐅯𐅩 electron init').then(
				,un=> 𐅩.init().then(ι=>{ un() ;𐅩.ι.ι = ι ;𐅯().catch(=>∅) })
				,=> /* retry once */ (=> 𐅯().catch(=>∅) ).in(1/*holy shit cheating*/)
				)
			}) }
	↩ id=> code=> send_to_my({ ,id ,code }) }
⧫. _electron__start_my ==>{
	# ! requires modules using /usr/local/bin/node 's ABI ;currently electron matches but this will break
	start_el_app ← (code,…a)=>{
		cmd ← npm`electron@1.8.2-beta.2` ;t ← cmd_log_loc(cmd)
		c2 ← `require('/usr/local/bin/ζ')(global) ;(${code})(${a.join(',')})`
		node.child_process.spawn(sh`${cmd} ${simple_as_file(c2)}`,{ ,shell:✓ ,detached:✓ ,stdio:['ignore',fs.openSync(t.out,'a+'),fs.openSync(t.err,'a+')] })
		|>(ι=> [ι,…ι.stdio,ι.channel].map(ι=>ι&&ι.unref()) )
		}
	↩ => @deviceΠ(re=> start_el_app(re=>{ el ← require('electron') ;el.app.Π`ready`.then(=>{
		el.app.on('window-all-closed',=> el.app.hide() )
		el.app.dock.setIcon('/~/code/scratch/dotfiles/eye.png')
		# el.ipcMain.on('eval_main',(ev,ι)=> eval(ι)(𐅦d.get(ev.sender))) ;𐅦 ← ι=> 𐅦d.set(ι.webContents,ι) ;𐅦d ← new WeakMap()
		# el ← require('electron')
		# eval_main ← f=> el.ipcRenderer.send('eval_main',f+'')
		# eval_main(me=> me.Π`ready-to-show`.then(=> me.show()))
		# eval_main(=> el.app.dock.setIcon('/~/code/scratch/dotfiles/eye.png') )
		on_msg ← ({,id,code})=>{ w ← 𐅮𐅭𐅰𐅂𐅮‘[id]
			send ← ι=> w.ι.webContents.executeJavaScript(ι+';0')
			if(! w.ι ){
				t ← w.ι = new el.BrowserWindow({ ,show:✗ ,frame:✗ }) # !>(𐅦)
				t.loadURL('about:blank')
				t.Π`closed`.then(=> w.∃ = ✗ )
				send(` require('/usr/local/bin/ζ')(global) ;γ.el = require('electron') `)
				t.Π`ready-to-show`.then(=> t.show()) }
			send(code) } ;𐅮𐅭𐅰𐅂𐅮 ← {}
		net1.device_listen().then(H=>{ H.on('connection',s=> stream4.as_json(s).on(on_msg) ) ;re(H.at) })
		})},re) ) }

⧫. notify ==> ι=>{
	Tstr(ι) &&( ι = ι.re`\n`? ι.re`^(.*?)\n([^]*)`.slice(1) : ι.re` `? ι.re`^(.*?) ([^]*)`.slice(1) : [ι] )
	↩ net1.device_listen().then(H=>{
	r ← H.just_first_json()
	hsᵥ`hs.notify.new(
		function(x) ;x:withdraw() ;simple_send(${H.at},{ at=x:actualDeliveryDate() }) end
		,{ title=${ι[0]} ,informativeText=${or∅(ι[1],'')} ,otherButtonTitle='\u{2063}' ,actionButtonTitle='\u{2063}' }
		):send()`
	↩ r }) }

⧫. set_newtab_bg ==> ι=> shᵥ`ln -sf ${ι} ~/code/scratch/net.user/chrome:newtab/it.jpg`

⧫. sfx ==> (ss,…ιs)=>{ ι ← ss[0]
	shₐ`afplay ~/code/scratch/dotfiles/${ι}.wav`
	if( ι==='done' && osaᵥ`get volume settings`['output muted'] ){ br ← npm`brightness@3.0.0` ;br.get().then(t=>{ br.set(0) ;(=> br.set(t)).in(0.2) }) }
	}

⧫. style ==> ι=> document.head.appendChild( document.createElement('style') …←({ innerHTML:ι+'' }) )

############################## friend glue : data ##############################
⧫. wikipedia_source ==> page=> JSON.parse(GET_L(`https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(page)}&prop=revisions&rvprop=content&format=json`,1e6)+'').query.pages |> (ι=> _u.values(ι)[0].revisions[0]['*'] )

⧫. github_url ==> ι=>{
	[file,h] ← sbᵥ`view = deserialize(${ι}) ;s = view.sel() ;[ view.file_name() ,[view.rowcol(ι) for ι in [s[0].begin() ,s[-1].end()]] ]`
	fm ← ι=> 'L'+(ι+1)
	↩ github_remote_origin(file||'')+( ≈(h[0],h[1])? '' : '#'+(h[0][0]===h[1][0]? fm(h[0][0]) : fm(h[0][0])+'-'+fm(h[1][0])) ) }
⧫. github_remote_origin ==> file=>{
	ι ← φ(file).root('/')
	root ← ι ;while( root+''!=='/' && !root.φ`.git`.∃ ) root=root .φ`..`
	if( root+''==='/' ) throw Error() …← ({ human:'did not find github remote origin for '+(file||'<anon>') })
	ι = (ι+'').slice((root+'/').‖)
	name ← root.φ`.git/config`.ini['remote "origin"'].url.match(/github\.com[:/](.+)\/(.+)\.git/).slice(1).join('/')
	commit ← /*jet[*/ catch_ι(=> root.φ`.git/HEAD`.text.trim()==='ref: refs/heads/master' && root.φ`.git/refs/heads/master`.text.trim() ) /*]*/ || shᵥ`cd ${root} ;git rev-parse HEAD`+''
	↩ encodeURI('http://github.com/'+name+'/blob/'+commit+'/'+ι) }

⧫. _slot0 ==> (get,set)=>{ t ← {} ;def(t,'ι',{get,set}) ;↩ t }
⧫. clipboard ==> _slot0( => shᵥ`pbpaste`+'' ,ι=> shₐ`${ζ_inspect(ι)} |`` pbcopy` )

⧫. chrome_tabs ==> i=>{
	nice_ ← (title,url)=>{ t ← new String(title+' '+url) ;t.sourcemap = { ,title:[0,title.‖] ,url:[(title+' ').‖,(title+' '+url).‖] } ;↩ nice_url(t) }
	[title,url] ← osaᵥ`chrome: {title,URL} of tabs of windows`
	if( i ){ i = i|0 ;t ← nice_(title[0][i],url[0][i]) ;p(t) ;↩ t+'\n<copied>\n' }
	else{ t ← _.zip(title,url).map(ι=> _.zip(…ι)).map(.map(ι=> nice_(…ι)).join('\n')).join('\n\n') ;sb.tab.push(t) }
	}

⧫. bookmarks ==> ι=>{
	# ! should use nice_url
	use_chrome ← ✓
	safari_bookmarks ← ι=>{
		𐅜𐅫 ← ι⇒
			: Tarr(ι)? ι.map…(𐅜𐅫)
			: ι.WebBookmarkType==='WebBookmarkTypeProxy'? []
			: ι.WebBookmarkType==='WebBookmarkTypeLeaf'? [{ ,name:ι.URIDictionary.title ,ι:ι.URLString }]
			: ι.WebBookmarkType==='WebBookmarkTypeList'? !ι.Children? [] : [{ ,name:ι.Title ,ιs:ι.Children.map…(𐅜𐅫) }]
			: { ,name:'' ,ι:JSON.stringify(ι) }
		↩ 𐅜𐅫(φ(ι||φ`~/Library/Safari/Bookmarks.plist`).plist)[0].ιs }
	chrome_bookmarks ← ι=>{
		𐅜𐅫 ← ι=> ι.children? { ,name:ι.name ,ιs:ι.children.map(𐅜𐅫) } : ι.url? { ,name:ι.name ,ι:ι.url } : { ,name:'' ,ι:JSON.stringify(ι) }
		↩ φ(ι||'~/Library/Application Support/Google/Chrome/Default/Bookmarks').json.roots.bookmark_bar.children.map(𐅜𐅫) }
	ι = ( use_chrome? chrome_bookmarks : safari_bookmarks )(ι)
	ι = walk_fold(ι,ι=> Tarr(ι)? ι.join('\n') : ι.ιs? (ι.name+'\n'+ι.ιs).replace(/\n/g,'\n  ') : ( !ι.name || !ι.ι || ι.ι === ι.name? ι.name||ι.ι : ι.name+' '+ι.ι ))
	sb.tab.push(ι) }

⧫. p ==> (ι=> node.fs.fstatSync(0).isFIFO()? shₐi`pbcopy`|>(=>∅) : ι===∅? clipboard.ι : ( clipboard.ι = ι ) ) …←({ cant_pool:✓ })

⧫. sb ==>{
	sb ← ((…a)=> node.fs.fstatSync(0).isFIFO()? shₐi`open -a 'Sublime Text.app' -f` |>(=>∅) : a.‖===0? sb.tab.active.ι : shₐi`'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' ${a}` |>(=>∅) )
		…←({ cant_pool:✓ })
	sb‘.tab .get= =>{
		r ← sbᵥ`[serialize(ι) for ι in [ι.view() for ι in sublime.windows() for ι in ι.sheets()] if ι]`
		r.active = sbᵥ`serialize(sublime.active_window().active_sheet().view())`
		;[…r,r.active].filter(ι=>ι).map(‘.ι .host={ enumerable:✗,
			get(){↩ sbᵥ` view = deserialize(${@}) ;view.substr(Region(0,view.size())) ` },
			set(ι){ sb_editᵥ(@)` view.replace(edit,Region(0,view.size()),${ι}) ` },
			} )
		r‘.push !>( .enumerable= ✗ ) .ι = λ(ι){ shₐ`${ζ_inspect(ι)} |`` open -a 'Sublime Text.app' -f` ;@.length = 0 ;(=> @ …← (sb.tab) ).in(0.02) } # ! wtf async/sync mix
		↩ r }
	↩ sb}
⧫[ 'sb[-1]'] ==> => sb.tab[-1].ι

################################## friend glue #################################
⧫. hsᵥ ==> (ss,…ιs)=>{
	ENC ← ι⇒
		: Tstr(ι)||Tnum(ι)? JSON.stringify(ι)
		: Tarr(ι)? '{'+ι.map(ENC).join(',')+'}'
		: '{'+_u(ι).map((ι,i)=>'['+ENC(i)+']='+ENC(ι)).join(',')+'}'
	ι ← simple_template(ss,ιs,ENC).join('')
	# t ← shᵥ`hs -c ${ι}`
	t ← shᵥ`/usr/local/bin/hs -c ${ι}`
	# t ← child_ process.spawnSync(which('hs'),['-c',ι]).stdout
	t ← (t+'').split('\n')[-1] ;↩ or∅( catch_ι(=> JSON.parse(t)),t ) }

⧫. tsᵥ ==> (ss,…ιs)=>{
	ENC ← JSON.stringify ;ι ← simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('')
	ι = 'require "totalspaces2" ;TS = TotalSpaces2 ;'+ι
	PORT = 34290
	R ← => JSON.parse(fs_ipc_emit(PORT,ι))[0]
	launch_serv ← =>{
		;(shᵥ`gem list`+'').re`(^|\n)totalspaces2 ` || ‽
		t ← φ`/tmp/evalserv_${random_id(9)}.rb`
		t.text = String.raw`#!/usr/bin/env ruby
			require "socket" ;require "json"
			server = TCPServer.new("localhost",${PORT})
			loop do
			  t = server.accept
			  r = JSON.generate([eval(File.read("/tmp/fs_ipc_#{${PORT}}"))])
			  t.print "HTTP/1.1 200 OK\r\n"+"Content-Type: text/plain\r\n"+"Content-Length: #{r.bytesize}\r\n"+"Connection: close\r\n"+"\r\n"+r
			  t.close
			end`
		shᵥ`chmod +x ${t}`
		node.child_process.spawn(t,{shell:✓,detached:✓,stdio:'ignore'}).unref()
		# process_spawn('/bin/sh',{ ,args:['-c',t+''] ,child:✗ })
		}
	try{↩ R() }catch(e){ e.status===7 && launch_serv() ;shᵥ`sleep 0.1` ;↩ R() } }

⧫. sbᵥ ==> (ss,…ιs)=>{
	ENC ← JSON.stringify ;ι ← simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('')
	φ`/tmp/sb𐅰𐅯𐅜𐅂𐅝`.ι = ι ;↩ JSON.parse(shᵥ`curl -s -X PUT localhost:34289`+'') |>(ι=> ι===null? ∅ : ι) }
⧫. sb_editᵥ ==> view=>(ss,…ιs)=>{ sbᵥ`edit(${view},${py(ss,…ιs)})` }

⧫. terminal_do_script ==>{
	sh.clear = String.raw`/usr/bin/clear && printf %s $'\e[3J'`
	↩ (a,b)=>{ φ`/tmp/__·`.ι = a ;osaᵥ`terminal: do script "·" …${b}` } }
⧫[ '·'] ==> =>{ t ← φ`/tmp/__·` ;postrun(t.text) ;t.ι = ∅ }

################################## see : data ##################################
⧫. Tag ==>{
	𐅝𐅯𐅩𐅝𐅞 ← {}
	𐅝𐅯𐅩𐅝𐅞.inspect = λ(d,opt){
		ks ← (…a)=> ≈( new Set(_u.keys(@)).-(['inspect','_']) ,new Set(a) )
		r ← [ opt.stylize(@.tag,'regexp') ]
		!ks('tag') && r.push( node.util.inspect( ks('tag','ι')? @.ι : Object.defineProperties({},_u(Object.getOwnPropertyDescriptors(@)).omit('tag','inspect','_')) ,opt) )
		↩ r.join(' ') }
	𐅝𐅯𐅩𐅝𐅞.≈ = λ(ι){ ι = Tstr(ι)? ι : ι[0] ;↩ @.tag === ι }
	↩ (tag,ι)=>{ r ← new_(𐅝𐅯𐅩𐅝𐅞) ;tag!==∅ &&( r.tag = tag ) ;ι!==∅ &&( r.ι = ι ) ;↩ r } }

⧫. d ==> (a='.')=>{
	# would be neat if this was .Trash aware
	sum ← 0
	q ← (ι,fl)=> log( (' '.×(17)+(ι+'').split('').reverse().join('').replace(/(...(?!$))/g,'$1,').split('').reverse().join('')).slice(-17)+'  '+fl )
	node.fs.readdirSync(a).map(fl=>{
		if( φ(fl).is_dir ){
			o ← process.stderr.write ;process.stderr.write = =>{} ;try{ t ← shᵥ`du -sk ${a}/${fl}` }catch(e){ t ← e.stdout } ;process.stderr.write = o
			b ← +((t+'').re`^\d+`||[0])[0] * 1024 }
		else b ← φ(fl).‖
		sum += b ;q(b,fl) })
	q(sum,a)

	progress_bar ← (L,at)=>( L -= 2 ,at = floor(at*L) ,'['+('='.×(L)+'>').slice(-at)+' '.×(L-at)+']' )
	[used,free] ← (shᵥ`df -P /`+'').split('\n')[1].split(/ +/g).slice(2).map(ι=> (ι|0)*512 )
	q(-free,'/ '+progress_bar(80-21,used/(used+free)))
	}

⧫. ⧗ ==> (f,opt={})=>{ var {TH=0.4} = opt
	# ! really should include a confidence interval or smth
	r←0 ;I←1 ;hr←hrtime() ;R ← => Unit(hrtime(hr) / r ,'s')
	t←f() ;r++
	if( T.Promise(t) ) ↩ Π(yes=>{ t.then(λ Λ(){ if( hrtime(hr) < TH ){ r++ ;f().then(Λ) }else yes(R()) }) })
	else{ for(;hrtime(hr) < TH;){ for(i←0;i<I;i++) f() ;r += I ;I = ceil(I*1.5) } ;↩ R() } }
⧫. ⧗1 ==> f=>{ hr ← hrtime() ;f() ;↩ Unit(hrtime(hr),'s') }

################################## see : <new> #################################
⧫. see ==>{
	my_identity ← simple_flesh(['see.ζ','default'])
	see ← ι=> electron_window_for(my_identity)(`see_render(${JSON.stringify(ι)})`)
	↩ see }
⧫. see_render ==>{
	{nk,norm∞} ← numeric2
	eval_html ← ι=> document.createElement('div') …←({ innerHTML:(ι+'').trim() }).childNodes[0]

	wh ← [700,100]
	see_freqs ← ι=>
		document.body.appendChild( eval_html(`
			<svg style=";fill:darkred ;background:#2a2626 ;width:${wh[0]} ;height:${wh[1]}">
				<g transform="scale(${wh[0]},${wh[1]})">
				${norm∞(ι).map((ι,i,L)=>
					`<rect class="bar" transform="translate(${i/L.‖},${1-ι})" width="${1/L.‖ - 1/wh[0]}" height="${ι}">
						</rect>` ).join('')}
					</g> </svg> `) )

	style` body{ ;background:#2a2626 } `
	# style` .bar { ;fill:darkred } `
	
	↩ ι=> ι.frequencies? see_freqs(ι.frequencies) : ‽ }

##################################### <new> ####################################
