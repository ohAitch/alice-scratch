// Algebraic JavaScript Specification https://github.com/fantasyland/fantasy-land is cute and might be relevant to further builtin design
// todo: module.exports seems to be calling itself twice on things and this is bad

E ← {} // exports
ˡ ← {} // local
patches ← []
P ← λ(ι){(_.isArray(ι)? ι : _(ι).pairs()).forEach(λ(t){name ← t[0]; ι ← t[1]
	name = name.split('.'); last ← name.pop()
	r ← λ(G){t ← name.reduce(λ(r,ι){↩ r[ι]},G); typeof(ι)==='function'? ((ι.name && (ι.super = t[last])), t[last] = ι) : def(t,last,ι.get)}
	r(global); patches.push(r)
	})}

def ← λ(o,name,get,set){set || (set = λ(ι){delete @[name]; @[name] = ι}); Object.defineProperty(o,name,{configurable:true, get:get, set:set}); ↩ o}
lazy ← λ(name,ι){↩ {get:λ(){↩ @[name] = ι()}}} //! def_lazy doesn't use this because def doesn't take this in as a format. but ... bleh?
def_lazy ← λ(o,name,ι){↩ def(o, name, λ(){↩ @[name] = ι()})}

;[ ['child_process'],['events','EventEmitter'],['http'],['https'],['module','Module'],['net'],['os'],['path'],['punycode'],['querystring'],['readline'],['repl'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['priorityqueuejs',,ˡ],['rwlock',,ˡ],
].map(λ(ι){def_lazy(ι[2]||E,ι[1]||ι[0],λ(){↩ require(ι[0])})})
_ ← E._

E._require_lazy = λ(require){↩ λ(ι,version){
	// try {↩ require_(ι)} catch (e) {if (!(e.code === "MODULE_NOT_FOUND")) throw e; ...}
	// ι === 'underscore'? E._ : ι === 'moment'? E.moment
	if (arguments.length === 1) ↩ require(ι)
	else {
		cache ← fs('~/.npm/'+ι+'/'+version).path
		fs(cache+'/ι').exists() || (
			print('[lazy require] installing',ι+'@'+version),
			fs(cache).exists() || bashᵥ('cd ~; npm cache add '+bash_encode(ι+'@'+version)),
			bashᵥ('cd '+bash_encode(cache)+' && npm i '+bash_encode(ι+'@'+version)+' && mv node_modules/'+bash_encode(ι)+' ι && rmdir node_modules'),
			print('[lazy require] done') )
		↩ require(cache+'/ι')}
	}}
Array.from? console.warn('Array.from polyfill is not needed') : (Array.from = λ(ι){r ← []; while (t = ι.next(), !t.done) r.push(t.value); ↩ r})
;(λ(){
fmt ← λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{depth:null})}
sublime_eval ← λ(ι){t ← JSON.parse(child_process.execSync('curl -s -X PUT 127.0.0.1:34289 --data-binary @-', {input:ι})); if (t !== null) ↩ t}
sublime_view_substr ← λ(a,b){↩ sublime_eval('r = view.substr(view.full_line(sublime.Region('+(a||'0')+','+(b||'view.size()')+')))')}
E.p = λ(ι){ι !== undefined || (ι = '')
	if (arguments.length === 0) ↩ child_process.execSync('pbpaste').toString()
	else {t ← child_process.spawn('pbcopy'); t.stdin.setEncoding('utf8'); ι.pipe? ι.pipe(t.stdin) : t.stdin.end(fmt(ι))} }
E.sb = λ(ι){↩ arguments.length === 0? sublime_view_substr() : child_process.spawn('open',['-a','Sublime Text.app','-f']).stdin.end(fmt(ι))}
})()
E.email = λ(){
	sb().split(/\n{3,}/g).map(λ(ι){t ← ι.split('\n'); ↩ ('mailto:'+t[0]+'?subject='+t[1]+'&body='+t.slice(2).join('\n')).replace(/\n/g,'%0A')})
		.map(λ(ι){osa('tell app "chrome" to open location '+osa_encode(ι))})
	osa('tell app "chrome" to activate') }
E.A = λ(ι){↩ Array.prototype.slice.call(ι)}
E.print = λ(){a ← A(arguments); process.stdout.write(a.map(λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{colors:true,depth:2})}).join(' ')+'\n'); ↩ a[-1]}
_(E).extend(_(Math).pick('abs','ceil','exp','floor','log','log10','log2','max','min','PI','pow','round','sqrt')); _(E).extend({ln:E.log, ln2:E.log2, ln10:E.log10})
E.multiline = λ(ι){ι = ι.toString().split('\n').slice(1,-1); t ← _.min(ι.map(λ(ι){↩ ι.match(/^\t*/)[0].length})); ι = ι.map(λ(ι){↩ ι.slice(t)}); ↩ (ι[0]==='' && ι[ι.length-1]===''? ι.slice(1,-1) : ι).join('\n')}
def_lazy(E,'moment',λ(){
	_moment ← require('moment')
	moment ← λ(ι){↩ typeof(ι)==='number' && arguments.length===1? _moment(ι*1000) : _moment.apply(@,arguments)}
	Object.setPrototypeOf(moment,_moment)
	moment.fn.valueOf = λ(){↩ +@._d/1000 + (@._offset||0)*60}
	moment.fn.toString = λ(){↩ @.utc().format('YYYY-MM-DD[T]HH:mm:ss[Z]')}
	moment.fn.inspect = λ(depth,opts){t ← @.toString(); ↩ true/*opts.colors*/? '\x1b[35m'+t+'\x1b[39m' : t}
	↩ moment})
E.λ = λ(ι){r ← λ(m){↩ ι[m]}; r.ι = ι; ↩ r}
P({ 'String.prototype.λ':{get:λ(){m←@; r ← λ(ι){↩ ι[m]}                                         ; r.ι = @; ↩ r}} })
P({ 'Number.prototype.λ':{get:λ(){m←@; r ← λ(ι){↩ ι[m]}                                         ; r.ι = @; ↩ r}} })
P({ 'RegExp.prototype.λ':{get:λ(){θ←@; r ← λ(ι){↩ ι === undefined || ι === null? ι : ι.match(θ)}; r.ι = @; ↩ r}} })
E.pipe_in_out = λ(f){
	read_all ← λ(θ/*Readable*/,cb){t ← []; θ.resume(); θ.setEncoding('utf8'); θ.on('data',λ(ι){t.push(ι)}); θ.on('end',λ(){cb(null,t.join(''))})}
	read_all(process.stdin, λ(e,ι){process.stdout.write(f(ι)+'')}) }
E.ζ2_compile = ζ2_compile
E.ζ2_compile['⁻¹'] = λ(ι){↩ ι.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$αβγδεζηθικλμνξπρστυφχψω]+)(\s*)(=?)/g, λ(ι,name,s,eq){↩ {'function':'λ','return':'↩','this':'@'}[ι] || (eq==='='? name+s+'←' : name+s+'←;')})}
E.ζ2_repl_start = λ(opts){
	//! aaaaa why does this break if i remove useGlobal:true ?
	repl._builtinLibs = []
	rRpc ← repl.REPLServer.prototype.complete; repl.REPLServer.prototype.complete = λ(line,cb){line.trim()===''? cb([]) : rRpc.call(@,line,cb)}
	self ← repl.start(_({useGlobal:true, ignoreUndefined:true, prompt:{split:λ(){↩ ['ζ₂ ']}, valueOf:λ(){↩ '\x1b[32mζ₂\x1b[39m '}}}).extend(opts))
	self.removeAllListeners('line')
	self.on('line',λ(cmd){
		err←; ret←;
		for(;;){
			code ← self.bufferedCommand + (cmd||'')
			if (code === '') break
			if (/(^\{[\s\S]*\}$)|(^λ\()/.test(code)) code = '('+code+')'
			if (code.match(/^>/)) code = '__SPECIAL__('+util.inspect(code.slice(1))+')' // hack: for apprentice
			try {t ← vm.createScript(ζ2_compile(code)+'\n', {filename:'repl', displayErrors:false})}
			catch (e) {
				if (e.name === 'SyntaxError' && /^(Unexpected end of input|Unexpected token)/.test(e.message)) {self.bufferedCommand += cmd+'\n'; self.outputStream.write('     '); ↩}
				typeof(e.stack)==='string' && (e.stack = e.stack.replace(/(\n    at )[\s\S]*/,'$1<repl>')); err = e; break}
			try {ret ← @.useGlobal? t.runInThisContext({displayErrors:false}) : t.runInContext(self.context,{displayErrors:false})}
			catch (e) {typeof(e.stack)==='string' && (e.stack = e.stack.replace(/^([\s\S]*)at repl:(.*)[\s\S]*?$/,'$1at <repl:$2>')); err = e; break}
		break}
		self.memory(cmd)
		if (err) self._domain.emit('error', err.err || err)
		self.bufferedCommand = ''
		if (!err && ret !== undefined) {self.context.__ = ret; self.outputStream.write(self.writer(ret)+'\n')}
		self.displayPrompt()
		})
	self.context.require = _require_lazy(self.context.require)
	module.exports(self.context)
	↩ self}

E.osa = λ(ι){child_process.exec('osascript -ss -e '+bash_encode(ι))}
E.osaᵥ = λ(ι){
	osa_parse_array ← λ(ι){↩ {'missing value':1,'':1}[ι.trim()]? undefined : JSON.parse(ι.split(/("(?:\\.|.)*?")/g).map(λ(ι){↩ /^"[\s\S]*"$/.λ(ι.replace(/\n$/,''))? ι.replace(/\n$/,'').replace(/\n/g,'\\n') : ι.replace(/\{/g,'[').replace(/\}/g,']')}).join(''))} // based on https://github.com/FWeinb/node-osascript/blob/master/lib/osa-parser.peg
	↩ osa_parse_array(child_process.execSync('osascript -ss -e '+bash_encode(ι))+'')}
E.bash = λ(ι){child_process.exec('bash -c '+bash_encode(ι))}
E.bashᵥ = λ(ι){↩ (child_process.execSync('bash -c '+bash_encode(ι))+'').replace(/\n$/,'')}

E.regex_encode = λ(ι){↩ ι.replace(/([.*+?^=!:${}()\[\]|\/\\])/g, '\\$1')}
E.bash_encode = λ(){↩ A(arguments).map(λ(ι){↩ "'"+ι.replace(/'/g,"'\\''")+"'"}).join(' ')}
E.basename_encode = λ(ι){↩ ι.replace(/\//g,'⟩')}
E.osa_encode = λ(ι){↩ '"'+ι.replace(/["\\]/g,'\\$&')+'"'} // probably incomplete

c_js ← λ(osa,ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ osa('tell app "google chrome" to tell '+tab+' of window 1 to set URL to '+osa_encode('javascript:'+ζ2_compile(ι)))}
c_js_sandbox ← λ(ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ JSON.parse(osaᵥ('tell app "google chrome" to execute window 1\'s '+tab+' javascript '+osa_encode(ι))||'""')}
jquery_script ← λ(extra){↩ "t ← document.createElement('script'); t.src = 'https://code.jquery.com/jquery-2.1.4.min.js'; "+(extra||"")+"; document.getElementsByTagName('head')[0].appendChild(t)"}
mk_eval ← λ(ι){↩ "eval("+JSON.stringify(ζ2_compile(ι))+")"}
E.chrome_js = λ(ι,tab){c_js(osa,ι+'; undefined',tab)}
E.chrome_jsᵥ = λ(ι,tab){c_js(osaᵥ,"t ← document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); ι ← "+mk_eval(ι)+"; t ← document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(ι); t2 ← document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); undefined",tab); ↩ c_js_sandbox("document.querySelectorAll('#applescript_hack')[0].textContent",tab)}
E.chrome_$ = λ(ι,tab){chrome_js("f ← λ(){"+ι+"}; if (window.jQuery) f(); else {"+jquery_script("t.onload = f")+"}",tab)}
E.chrome_$ᵥ = λ(ι,tab){r←; $null ← '__$null_'+Math.random().toString(36).slice(2); fst ← 1; while ((r=chrome_jsᵥ("if (window.jQuery){"+ι+"} else {"+(fst? (fst=0, jquery_script()) : "")+"; '"+$null+"'}",tab))===$null); ↩ r}

P({
'Function.prototype.P':λ(){ι←@; a ← A(arguments); ↩ λ(){↩ ι.apply(@,arguments.length === 0? a : a.concat(A(arguments)))}},
'Function.prototype.X':λ(n){ι←@; ↩ λ(){↩ ι.apply(@,A(arguments).slice(0,n))}},
'Array.prototype.mapcat':λ(f){↩ @.map(f)._.flatten(true)},
'String.prototype.repeat':λ(x){↩ x<=0? '' : Array(x+1).join(@)},
'Array.prototype.repeat':λ(x){↩ x<=0? [] : _.range(0,x).map(_.constant(@))._.flatten(true)},
'Function.prototype.inspect':λ(rec,ctx){t ← ζ2_compile['⁻¹'](@+'').replace(/^λ \(/,'λ(').match(/^.*?\)/); ↩ ctx.stylize('['+(t?t[0]:'λ ?(?)')+']', 'special')},
'String.prototype._':{get:λ(){↩ _(@)}},
'Array.prototype._':{get:λ(){↩ _(@)}},
'Buffer.prototype.inspect':λ ρ(){↩ ρ.super.call(@).replace(/(^<\w+)/,'$1['+@.length+']')},
'RegExp.prototype.genex_0':λ(){
	parse ← λ(ι){
		q ← λ(ι){↩ ι.match(/\(.*?\)|\[.*?\]|\\.|./g).map(λ(ι){↩ ι[0]==='('? q(ι.slice(1,-1)) : ι[0]==='['? {or:ι.slice(1,-1).split('')} : ι})}
		w ← λ(ι){if (!_.isArray(ι)) ↩ ι; t←; r ← []; while ((t=_.indexOf(ι,'|')) !== -1) {r.push(ι.slice(0,t)); ι = ι.slice(t+1)}; ↩ r.length? (r.push(ι),{or:r}) : ι.map(w)}
		↩ w(q(ι))}
	q ← λ(ι){↩ ι.or? ι.or.map(q) : _.isArray(ι)? ι.map(q).reduce(λ(a,b){↩ a.mapcat(λ(a){↩ b.map(λ(b){↩ a+b})})}) : [ι]}
	↩ q(parse(@.source)) },
'Function.prototype.in':λ(time){↩ !time || time <= 0? setImmediate(@) : setTimeout(@,time*1000)},
'Function.prototype.every':λ(time){↩ setInterval(@,time*1000)},
'Function.prototype.at':lazy('at',λ(){
	// robust to setTimeout taking extra time
	now ← λ(){↩ Date.now() / 1000}
	λs ← new ˡ.priorityqueuejs(λ(a,b){↩ b.time-a.time}); lock ← new ˡ.rwlock(); p←;
	enq ← λ(ι){lock.writeLock(λ(R){λs.enq(ι); R(); if (!P){P = true; (λ poll(){lock.writeLock(λ λ(R){
		t←; λs.size() === 0? (P = false) : !(λs.peek().time < now())? poll.in(0.1) : (t=λs.deq(), t.canceled || t.ι.in(), λ()); R&&R()
		}) })() } })}
	↩ λ(time){t ← {time:time, ι:@}; ↩ time < now()? (t.ι.in(), {clear:λ(){}}) : (enq(t), {clear:λ(){t.canceled = true}})} }),
})
P(/(Array|String|Buffer).prototype.-[01234]/.genex_0().map(λ(ι){i ← parseInt(ι[ι.length-1]); ↩ [ι, {get:λ(){↩ @.length<i? undefined : @[@.length-i]}, set:λ(ι){↩ @.length<i? ι : (@[@.length-i] = ι)}}]}))

def_lazy(E,'fs',λ(){t ← λ(path_){↩ new ˡ.Path(path_)}; Object.setPrototypeOf(t,require('fs')); ↩ t})
def_lazy(ˡ,'Path',λ(){
	// a file is a key-value pair in a sort of fuzzy-keyed dict with many types, but primarily "key array" and "byte array, usually interpreted as string"
	// represented as a Path, it has properties path_ and $/val/value/deref
	// a Path is normally just a fluent wrapper but can become a file descriptor holder or an event manager
	// maybe we can also pass it a type/format/view/mixin! eesh, maybe we need to fit it into the prototype system instead of just using a mixin...
	Path ← λ Path(path_){
		@.path_ = path_ instanceof Path? path_.path : path_.replace(/^~(?=\/)/,process.env.HOME)
		@.path = path_ instanceof Path? path_.path : path.normalize(@.path_+'/.')
		}
	def(Path.prototype,'$',λ(){↩ @._$()}, λ(ι){↩ @['='](ι)})
	// path_ manipulation
	Path.prototype.dir = λ(){↩ fs.statSync(@.path).isDirectory()}
	Path.prototype.exists = λ(){↩ fs.existsSync(@.path)}
	Path.prototype.resolve = λ(){↩ path.resolve(@.path)}
	Path.prototype.name = λ(ext){↩ path.basename(@.path,ext)}
	// find
		// it's really weird how this returns a thing that you can't actually pass to fs()
		// maybe we'll fix this by returning a more magical, jquery-like thing?
	Path.prototype.find = λ(sel){↩ Array.from(@.findˢ(sel))}
	Path.prototype.findˢ = λ*(sel){
		// does not handle uniqueness in selections
		// wtf is up with selectors only being a .find() thing and not a fs() thing? and not returning selections so they're not chainable?
		// doesn't normalize everything properly or reliably
		// doesn't follow symlinks (note: when you do follow symlinks, know that not all symlinks lead places)

		seq ← λ*(ι){for (i←0;i<ι.length;i++) yield ι[i]}
		WALK ← λ*(t,mode){
			switch (mode) {
				default: throw '↯'
				break; case '>': yield* seq(fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι}))
				break; case '*':
					root ← t+'/'
					//! bad - should use directed Dijkstra's from all roots with edge length equal to the number of files in a dir
					// sample impl:
						// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}
						// root ← '.'
						// dist ← {}; dist[root] = 0
						// next ← [root] // should be pqueue
						// out ← []
						// while (next.length) {t ← next._.min(λ(ι){↩ dist[ι]}); next = next._.without(t); out.push(t); at←; (at=all(t)).map(λ(ι){dist[ι] = dist[t] + at.length; next.push(ι)}) }
					// or just:
						// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}; root ← '.'; out ← []
						// (λ λ(ι,dist){out.push([dist,ι]); at←;(at=all(ι)).forEach(λ(t){λ(t,dist + at.length)})})(root,0)
						// q ← out._.sortBy(0)._.map(1)
					// note: as is will inf-loop on scary things
					walk_ ← λ*(ι){try {l ← fs.readdirSync(root+ι); for (i←0;i<l.length;i++){t ← ι+l[i]; try {fs.lstatSync(fs(root+t).path).isDirectory()? (yield root+t, yield* walk_(t+'/')) : yield root+t} catch (e) {}}} catch (e) {}}
					yield* walk_('')
				} }

		sel = sel.trim()
		if (sel === '') ↩;

		ERR ← λ(){throw Error('[ζ₂] selector is not supported: '+sel)}

		sel_a ← (' '+sel).replace(/(^|[^>* ])( +(?![>* ]))/g,'$1 * ').trim().split(/ +/)
		if (!sel_a.every(λ(ι){↩ ι.match(/^>|\*|\.\S+|#\S+$/)})) ERR()
		//! should be: if (!sel_a.every(λ(ι){↩ ι.match(/^(>|\*|\.\S+|#\S+)$/)})) ERR()

		r ← seq([@.path_])
		sel_a.forEach(λ(ι){
			r_ ← r
			temp ← (λ*(){t←; //r_ ← r
				sw←; switch (sw=ι[0], ι=ι.slice(1), sw) {
					default: ERR()
					break; case '>': case '*': while (t=r_.next(),!t.done) {t=t.value; yield* WALK(t, sw)}
					break; case '.': while (t=r_.next(),!t.done) {t=t.value; if (t.match(RegExp(regex_encode('.'+ι)+'$'))) yield t}
					break; case '#': while (t=r_.next(),!t.done) {t=t.value; if (t.match(RegExp(regex_encode(ι)+'$'))) {yield t; break}}
					} })()
			r = temp
			})

		yield* r}
	// misc
	Path.prototype.toString = λ(){↩ path.resolve(@.path).replace(RegExp('^'+regex_encode(process.env.HOME)+'(?=/)'),'~')}
	// content manipulation
	Path.prototype._$ = λ(){t ← @.path; ↩ !@.exists()? '' : @.dir()? (console.trace('[ζ₂] DEPRECATED dir_$'), fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι})) : fs.readFileSync(t)+''}
	Path.prototype['='] = λ(ι){
		// string: text file, Array: directory, etc
		// async should use like fs.createReadStream(ι.path).pipe(fs.createWriteStream(@.path))
		if (@.exists() && @.dir()) throw Error('writing to directories not implemented')
		mkdir_p ← λ ρ(ι){try {fs.statSync(ι).isDirectory() || fs.mkdirSync(ι)} catch (e) {if (e.code !== 'ENOENT') throw e; ρ(path.dirname(ι)); fs.mkdirSync(ι)}}
		mkdir_p(path.resolve(path.dirname(@.path)))
		fs.writeFileSync(@.path,ι) }
	↩ Path })

E.ζtoken = {}
λ prop_extend(from,to){Object.getOwnPropertyNames(from).forEach(λ(ι){Object.defineProperty(to,ι,Object.getOwnPropertyDescriptor(from,ι))})}
prop_extend(E,global)
module.exports = λ(to){to.ζtoken === E.ζtoken || (prop_extend(E,to), patches.forEach(λ(ι){ι(to)}))}

// -------------------------------- discarded ------------------------------- //

// String.prototype.replace_all = λ(find,replace){↩ @.replace(RegExp(regex_encode(find),'g'),replace)}
// create_getattr ← (λ(){
// 	proxy_boiler ← {getOwnPropertyDescriptor:λ(){}, getPropertyDescriptor:λ(){}, getOwnPropertyNames:λ(){↩[]}, getPropertyNames:λ(){↩[]}, defineProperty:λ(){}, delete:λ(){↩false}, fix:λ(){}, inspect:λ(){↩'[MAGIC-GET-ATTR]'}}
// 	↩ λ(get,set){↩ Proxy.create({get:λ(self,name){↩ proxy_boiler[name] || get(name)}, set:λ(self,name,ι){set(name,ι)}})} })()
// create_getattr(λ(n){@.$[n]},λ(n,ι){
// 			magic magic
// 			}),
// E.ζ2_bit_reverse_i = λ(length,ι){r ← 0; for (i←0;i<length;i++){r = (r << 1) | (ι & 1); ι = ι >> 1}; ↩ r}
// Path.prototype.parent = λ(){↩ fs(path.dirname(@.path))}
// // Path.prototype.slice = λ(i){↩ ζ2_def({},'$',λ(){},λ(ι){path_open(@,λ(){t ← Buffer(ι); fs.writeSync(@.fd,t,0,t.length,i); fs.ftruncateSync(@.fd,i + Buffer.byteLength(ι))})})}
// Path.prototype.splice = λ(idx,rm,ι){path_open(@,λ(fd){t←;
// 	ι = Buffer(ι)
// 	rm === ι.length || (t = Buffer(fs.statSync(@.path).size - (idx+rm)), fs.readSync(fd,t,0,t.length,idx+rm))
// 	fs.writeSync(fd,ι,0,ι.length,idx)
// 	rm === ι.length || fs.writeSync(fd,t,0,t.length,idx+ι.length)
// 	rm > ι.length && fs.ftruncateSync(fd,idx+ι.length+t.length)
// 	})}
