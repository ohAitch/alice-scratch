// Algebraic JavaScript Specification https://github.com/fantasyland/fantasy-land is cute and might be relevant to further builtin design
// todo: module.exports seems to be calling itself twice on things and this is bad

E ← {} // exports
ˡ ← {} // local
patches ← []
P ← λ(ι){(_.isArray(ι)? ι : _(ι).pairs()).forEach(λ(t){name ← t[0]; ι ← t[1]
	name = name.split('.'); last ← name.pop()
	r ← λ(G){t ← name.reduce(λ(r,ι){↩ r[ι]},G); typeof(ι)==='function'? ((ι.name && (ι.super = t[last])), t[last] = ι) : def(t,last,ι.get)}
	r(global); patches.push(r)
	})}

def ← λ(o,name,get,set){set || (set = λ(t){delete @[name]; @[name] = t}); Object.defineProperty(o,name,{configurable:true, get:get, set:set}); ↩ o}
lazy ← λ(name,ι){↩ {get:λ(){↩ @[name] = ι()}}}
def_lazy ← λ(o,name,ι){↩ def(o, name, λ(){↩ o[name] = ι()})}

;[ ['child_process'],['events','EventEmitter'],['http'],['https'],['net'],['os'],['path'],['punycode'],['querystring'],['readline'],['repl'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['priorityqueuejs',,ˡ],['rwlock',,ˡ],
	].map(λ(ι){def_lazy(ι[2]||E,ι[1]||ι[0],λ(){↩ require(ι[0])})})
_ ← E._

Array.from? console.warn('Array.from polyfill is done') : (Array.from = λ(ι){r ← []; while (t = ι.next(), !t.done) r.push(t.value); ↩ r})
;(λ(){
fmt ← λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{depth:null})}
sublime_eval ← λ(ι){t ← JSON.parse(child_process.execSync('curl -s -X PUT 127.0.0.1:34289 --data-binary @-', {input:ι})); if (t !== null) ↩ t}
sublime_view_substr ← λ(a,b){↩ sublime_eval('r = view.substr(view.full_line(sublime.Region('+(a||'0')+','+(b||'view.size()')+')))')}
E.p = λ(ι){ι !== undefined || (ι = '')
	if (arguments.length === 0) ↩ child_process.execSync('pbpaste').toString()
	else {t ← child_process.spawn('pbcopy'); t.stdin.setEncoding('utf8'); ι.pipe? ι.pipe(t.stdin) : t.stdin.end(fmt(ι))} }
E.sb = λ(ι){↩ arguments.length === 0? sublime_view_substr() : child_process.spawn('open',['-a','Sublime Text.app','-f']).stdin.end(fmt(ι))}
})()
E.email = λ(){
	sb().split(/\n{3,}/g).map(λ(ι){t ← ι.split('\n'); ↩ ('mailto:'+t[0]+'?subject='+t[1]+'&body='+t.slice(2).join('\n')).replace(/\n/g,'%0A')})
		.map(λ(ι){osa('tell application "chrome" to open location '+osa_encode(ι))})
	osa('tell application "chrome" to activate') }
E.A = λ(ι){↩ Array.prototype.slice.call(ι)}
E.print = λ(){a ← A(arguments); process.stdout.write(a.map(λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{colors:true,depth:2})}).join(' ')+'\n'); ↩ a[-1]}
_(E).extend(_(Math).pick('abs','ceil','exp','floor','log','log10','log2','max','min','PI','pow','round','sqrt')); _(E).extend({ln:E.log, ln2:E.log2, ln10:E.log10})
E.multiline = λ(ι){ι = ι.toString().split('\n').slice(1,-1); t ← _.min(ι.map(λ(ι){↩ ι.match(/^\t*/)[0].length})); ι = ι.map(λ(ι){↩ ι.slice(t)}); ↩ (ι[0]==='' && ι[ι.length-1]===''? ι.slice(1,-1) : ι).join('\n')}
def_lazy(E,'moment',λ(){
	_moment ← require('moment')
	moment ← λ(ι){↩ typeof(ι)==='number' && arguments.length===1? _moment(ι*1000) : _moment.apply(@,arguments)}
	Object.setPrototypeOf(moment,_moment)
	moment.fn.valueOf = λ(){↩ +@._d/1000 + (@._offset||0)*60}
	moment.fn.toString = λ(){↩ @.utc().format('YYYY-MM-DD[T]HH:mm:ss[Z]')}
	moment.fn.inspect = λ(depth,opts){t ← @.toString(); ↩ true/*opts.colors*/? '\x1b[35m'+t+'\x1b[39m' : t}
	↩ moment})
E.λ = λ(ι){r ← λ(m){↩ ι[m]}; r.ι = ι; ↩ r}
P({ 'String.prototype.λ':{get:λ(){m←@; r ← λ(ι){↩ ι[m]}                                         ; r.ι = @; ↩ r}} })
P({ 'Number.prototype.λ':{get:λ(){m←@; r ← λ(ι){↩ ι[m]}                                         ; r.ι = @; ↩ r}} })
P({ 'RegExp.prototype.λ':{get:λ(){θ←@; r ← λ(ι){↩ ι === undefined || ι === null? ι : ι.match(θ)}; r.ι = @; ↩ r}} })
E.pipe_in_out = λ(f){
	read_all ← λ(θ/*Readable*/,cb){t ← []; θ.resume(); θ.setEncoding('utf8'); θ.on('data',λ(ι){t.push(ι)}); θ.on('end',λ(){cb(null,t.join(''))})}
	read_all(process.stdin, λ(e,ι){process.stdout.write(f(ι))}) }
E.ζ2_compile = ζ2_compile
E.ζ2_compile_inverse = λ(ι){↩ ι.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$αβγδεζηθικλμνξπρστυφχψω]+)(\s*)(=?)/g, λ(ι,name,s,eq){↩ {'function':'λ','return':'↩','this':'@'}[ι] || (eq==='='? name+s+'←' : name+s+'←;')})}
E.ζ2_repl_start = λ(opts){
	//! aaaaa why does this break if i remove useGlobal:true ?
	repl._builtinLibs = []
	rRpc ← repl.REPLServer.prototype.complete; repl.REPLServer.prototype.complete = λ(line,cb){line.trim()===''? cb([]) : rRpc.call(@,line,cb)}
	self ← repl.start(_({useGlobal:true, ignoreUndefined:true, prompt:{split:λ(){↩ ['ζ₂ ']}, valueOf:λ(){↩ '\x1b[32mζ₂\x1b[39m '}}}).extend(opts))
	self.removeAllListeners('line')
	self.on('line',λ(cmd){
		err←; ret←;
		for(;;){
			code ← self.bufferedCommand + (cmd||'')
			if (code === '') break
			if (/(^\{[\s\S]*\}$)|(^λ\()/.test(code)) code = '('+code+')'
			if (code.match(/^>/)) code = '__SPECIAL__('+util.inspect(code.slice(1))+')' // hack: for apprentice
			try {t ← vm.createScript(ζ2_compile(code)+'\n', {filename:'repl', displayErrors:false})}
			catch (e) {
				if (e.name === 'SyntaxError' && /^(Unexpected end of input|Unexpected token)/.test(e.message)) {self.bufferedCommand += cmd+'\n'; self.displayPrompt(); ↩}
				typeof(e.stack)==='string' && (e.stack = e.stack.replace(/(\n    at )[\s\S]*/,'$1<repl>')); err = e; break}
			try {ret ← @.useGlobal? t.runInThisContext({displayErrors:false}) : t.runInContext(self.context,{displayErrors:false})}
			catch (e) {typeof(e.stack)==='string' && (e.stack = e.stack.replace(/^([\s\S]*)at repl:(.*)[\s\S]*?$/,'$1at <repl:$2>')); err = e; break}
		break}
		self.memory(cmd)
		if (err) self._domain.emit('error', err.err || err)
		self.bufferedCommand = ''
		if (!err && ret !== undefined) {self.context.__ = ret; self.outputStream.write(self.writer(ret)+'\n')}
		self.displayPrompt()
		})
	module.exports(self.context)
	↩ self}

E.osa = λ(ι){child_process.exec('osascript -ss -e '+bash_encode(ι))}
E.osaᵥ = λ(ι){
	osa_parse_array ← λ(ι){↩ {'missing value':1,'':1}[ι.trim()]? undefined : JSON.parse(ι.split(/("(?:\\.|.)*?")/g).map(λ(ι){↩ /^"[\s\S]*"$/.λ(ι.replace(/\n$/,''))? ι.replace(/\n$/,'').replace(/\n/g,'\\n') : ι.replace(/\{/g,'[').replace(/\}/g,']')}).join(''))} // based on https://github.com/FWeinb/node-osascript/blob/master/lib/osa-parser.peg
	↩ osa_parse_array(child_process.execSync('osascript -ss -e '+bash_encode(ι))+'')}
E.bash = λ(ι){child_process.exec('bash -c '+bash_encode(ι))}
E.bashᵥ = λ(ι){↩ (child_process.execSync('bash -c '+bash_encode(ι))+'').replace(/\n$/,'')}

E.regex_encode = λ(ι){↩ ι.replace(/([.*+?^=!:${}()\[\]|\/\\])/g, '\\$1')}
E.bash_encode = λ(){↩ A(arguments).map(λ(ι){↩ "'"+ι.replace(/'/g,"'\\''")+"'"}).join(' ')}
E.basename_encode = λ(ι){↩ ι.replace(/\//g,'⟩')}
E.osa_encode = λ(ι){↩ '"'+ι.replace(/["\\]/g,'\\$&')+'"'} // probably incomplete

E.chrome_js = λ(ι){osa('tell application "google chrome" to tell active tab of front window to set URL to '+osa_encode('javascript:'+ζ2_compile(ι+"; undefined")))}
E.chrome_jsᵥ = λ(ι){osaᵥ('tell application "google chrome" to tell active tab of front window to set URL to '+osa_encode('javascript:'+ζ2_compile("ι ← eval("+JSON.stringify(ζ2_compile(ι))+"); t ← document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); t ← document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(ι); t2 ← document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); undefined"))); ↩ JSON.parse(osaᵥ('tell application "google chrome" to execute window 1\'s active tab javascript '+osa_encode("document.querySelectorAll('#applescript_hack')[0].textContent"))||'""')}
E.chrome_jquery = λ(ι){chrome_js("(λ(f){if (window.jQuery) f(); else {t ← document.createElement('script'); t.src = 'https://code.jquery.com/jquery-2.1.4.min.js'; t.onload = f; document.getElementsByTagName('head')[0].appendChild(t)}})(λ(){$ ← window.$; "+ι+"})")}
E.chrome_jqueryᵥ = λ(ι){r←; $null ← '__$null_'+Math.random().toString(36).slice(2); if ((r=chrome_jsᵥ("(λ(f){if (window.jQuery) ↩ f(); else {t ← document.createElement('script'); t.src = 'https://code.jquery.com/jquery-2.1.4.min.js'; document.getElementsByTagName('head')[0].appendChild(t); ↩ '"+$null+"'}})(λ(){"+ι+"})"))===$null) while ((r=chrome_jsᵥ("(λ(f){if (window.jQuery) ↩ f(); else ↩ '"+$null+"'})(λ(){"+ι+"})"))===$null); ↩ r}
// https://projectnaptha.com/ chrome_jquery("$('a:contains(\"xkcd\")')[0].click()")
// https://projectnaptha.com/ chrome_jqueryᵥ("↩ $('a').map(λ(){↩ $(this).attr('href')}).toArray()")

P({
'Function.prototype.P':λ(){ι←@; a ← A(arguments); ↩ λ(){↩ ι.apply(@,arguments.length === 0? a : a.concat(A(arguments)))}},
'Function.prototype.X':λ(n){ι←@; ↩ λ(){↩ ι.apply(@,A(arguments).slice(0,n))}},
'Array.prototype.mapcat':λ(f){↩ _(@.map(f)).flatten(true)},
'String.prototype.repeat':λ(x){↩ x<=0? '' : Array(x+1).join(@)},
'Array.prototype.repeat':λ(x){↩ x<=0? [] : _.range(0,x).map(_.constant(@))._.flatten(true)},
'Function.prototype.inspect':λ(rec,ctx){t ← ζ2_compile_inverse(@+'').replace(/^λ \(/,'λ(').match(/^.*?\)/); ↩ ctx.stylize('['+(t?t[0]:'λ ?(?)')+']', 'special')},
'String.prototype._':{get:λ(){↩ _(@)}},
'Array.prototype._':{get:λ(){↩ _(@)}},
'Buffer.prototype.inspect':λ ρ(){↩ ρ.super.call(@).replace(/(^<\w+)/,'$1['+@.length+']')},
'RegExp.prototype.genex_0':λ(){
	parse ← λ(ι){
		q ← λ(ι){↩ ι.match(/\(.*?\)|\[.*?\]|\\.|./g).map(λ(ι){↩ ι[0]==='('? q(ι.slice(1,-1)) : ι[0]==='['? {or:ι.slice(1,-1).split('')} : ι})}
		w ← λ(ι){if (!_.isArray(ι)) ↩ ι; t←; r ← []; while ((t=_.indexOf(ι,'|')) !== -1) {r.push(ι.slice(0,t)); ι = ι.slice(t+1)}; ↩ r.length? (r.push(ι),{or:r}) : ι.map(w)}
		↩ w(q(ι))}
	q ← λ(ι){↩ ι.or? ι.or.map(q) : _.isArray(ι)? ι.map(q).reduce(λ(a,b){↩ a.mapcat(λ(a){↩ b.map(λ(b){↩ a+b})})}) : [ι]}
	↩ q(parse(@.source)) },
'Function.prototype.in':λ(time){↩ !time || time <= 0? setImmediate(@) : setTimeout(@,time*1000)},
'Function.prototype.every':λ(time){↩ setInterval(@,time*1000)},
'Function.prototype.at':lazy('at',λ(){
	// robust to setTimeout taking extra time
	now ← λ(){↩ Date.now() / 1000}
	λs ← new ˡ.priorityqueuejs(λ(a,b){↩ b.time-a.time}); lock ← new ˡ.rwlock(); p←;
	enq ← λ(ι){lock.writeLock(λ(R){λs.enq(ι); R(); if (!P){P = true; (λ poll(){lock.writeLock(λ λ(R){
		t←; λs.size() === 0? (P = false) : !(λs.peek().time < now())? poll.in(0.1) : (t=λs.deq(), t.canceled || t.ι.in(), λ()); R&&R()
		}) })() } })}
	↩ λ(time){t ← {time:time, ι:@}; ↩ time < now()? (t.ι.in(), {clear:λ(){}}) : (enq(t), {clear:λ(){t.canceled = true}})} }),
})
P(/(Array|String|Buffer).prototype.-[01234]/.genex_0().map(λ(ι){i ← parseInt(ι[ι.length-1]); ↩ [ι, {get:λ(){↩ @.length<i? undefined : @[@.length-i]}, set:λ(ι){↩ @.length<i? ι : (@[@.length-i] = ι)}}]}))

def_lazy(E,'fs',λ(){t ← λ(path_){↩ new ˡ.Path(path_)}; Object.setPrototypeOf(t,require('fs')); ↩ t})
def_lazy(ˡ,'Path',λ(){
	// a file is a key-value pair in a sort of fuzzy-keyed dict with many types, but primarily "key array" and "byte array, usually interpreted as string"
	// represented as a Path, it has properties path_ and $/val/value/deref
	// a Path is normally just a fluent wrapper but can become a file descriptor holder or an event manager
	// maybe we can also pass it a type/format/view/mixin! eesh, maybe we need to fit it into the prototype system instead of just using a mixin...
	Path ← λ Path(path_){
		@.path_ = path_ instanceof Path? path_.path : path_.replace(/^~(?=\/)/,process.env.HOME)
		@.path = path_ instanceof Path? path_.path : path.normalize(@.path_+'/.')
		}
	def(Path.prototype,'$',λ(){↩ @._$()}, λ(ι){↩ @['='](ι)})
	// path_ manipulation
	Path.prototype.dir = λ(){↩ fs.statSync(@.path).isDirectory()}
	Path.prototype.exists = λ(){↩ fs.existsSync(@.path)}
	Path.prototype.resolve = λ(){↩ path.resolve(@.path)}
	Path.prototype.name = λ(ext){↩ path.basename(@.path,ext)}
	// find
		// it's really weird how this returns a thing that you can't actually pass to fs()
		// maybe we'll fix this by returning a more magical, jquery-like thing?
	Path.prototype.find = λ(sel){↩ Array.from(@.findˢ(sel))}
	Path.prototype.findˢ = λ*(sel){
		// does not handle uniqueness in selections
		// wtf is up with selectors only being a .find() thing and not a fs() thing? and not returning selections so they're not chainable?
		// doesn't normalize everything properly or reliably
		// doesn't follow symlinks (note: when you do follow symlinks, know that not all symlinks lead places)

		seq ← λ*(ι){for (i←0;i<ι.length;i++) yield ι[i]}
		WALK ← λ*(t,mode){
			switch (mode) {
				default: throw '↯'
				break; case '>': yield* seq(fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι}))
				break; case '*':
					root ← t+'/'
					//! bad - should use directed Dijkstra's from all roots with edge length equal to the number of files in a dir
					// sample impl:
						// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}
						// root ← '.'
						// dist ← {}; dist[root] = 0
						// next ← [root] // should be pqueue
						// out ← []
						// while (next.length) {t ← next._.min(λ(ι){↩ dist[ι]}); next = next._.without(t); out.push(t); at←; (at=all(t)).map(λ(ι){dist[ι] = dist[t] + at.length; next.push(ι)}) }
					// or just:
						// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}; root ← '.'; out ← []
						// (λ λ(ι,dist){out.push([dist,ι]); at←;(at=all(ι)).forEach(λ(t){λ(t,dist + at.length)})})(root,0)
						// q ← out._.sortBy(0)._.map(1)
					// note: as is will inf-loop on scary things
					walk_ ← λ*(ι){try {l ← fs.readdirSync(root+ι); for (i←0;i<l.length;i++){t ← ι+l[i]; try {fs.lstatSync(fs(root+t).path).isDirectory()? (yield root+t, yield* walk_(t+'/')) : yield root+t} catch (e) {}}} catch (e) {}}
					yield* walk_('')
				} }

		sel = sel.trim()
		if (sel === '') ↩;

		ERR ← λ(){throw Error('[ζ₂] selector is not supported: '+sel)}

		sel_a ← (' '+sel).replace(/(^|[^>* ])( +(?![>* ]))/g,'$1 * ').trim().split(/ +/)
		if (!sel_a.every(λ(ι){↩ ι.match(/^>|\*|\.\S+|#\S+$/)})) ERR()
		//! should be: if (!sel_a.every(λ(ι){↩ ι.match(/^(>|\*|\.\S+|#\S+)$/)})) ERR()

		r ← seq([@.path_])
		sel_a.forEach(λ(ι){
			r_ ← r
			temp ← (λ*(){t←; //r_ ← r
				sw←; switch (sw=ι[0], ι=ι.slice(1), sw) {
					default: ERR()
					break; case '>': case '*': while (t=r_.next(),!t.done) {t=t.value; yield* WALK(t, sw)}
					break; case '.': while (t=r_.next(),!t.done) {t=t.value; if (t.match(RegExp(regex_encode('.'+ι)+'$'))) yield t}
					break; case '#': while (t=r_.next(),!t.done) {t=t.value; if (t.match(RegExp(regex_encode(ι)+'$'))) {yield t; break}}
					} })()
			r = temp
			})

		yield* r}
	// misc
	Path.prototype.toString = λ(){↩ path.resolve(@.path).replace(RegExp('^'+regex_encode(process.env.HOME)+'(?=/)'),'~')}
	// content manipulation
	Path.prototype._$ = λ(){t ← @.path; ↩ !@.exists()? '' : @.dir()? (console.trace('[ζ₂] DEPRECATED dir_$'), fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι})) : fs.readFileSync(t)+''}
	Path.prototype['='] = λ(ι){
		// string: text file, Array: directory, etc
		// async should use like fs.createReadStream(ι.path).pipe(fs.createWriteStream(@.path))
		if (@.exists() && @.dir()) throw Error('writing to directories not implemented')
		mkdir_p ← λ ρ(ι){try {fs.statSync(ι).isDirectory() || fs.mkdirSync(ι)} catch (e) {if (e.code !== 'ENOENT') throw e; ρ(path.dirname(ι)); fs.mkdirSync(ι)}}
		mkdir_p(path.resolve(@.parent().path))
		fs.writeFileSync(@.path,ι) }
	↩ Path })

λ prop_extend(from,to){Object.getOwnPropertyNames(from).forEach(λ(ι){Object.defineProperty(to,ι,Object.getOwnPropertyDescriptor(from,ι))})}
prop_extend(E,global)
E.ζtoken = {}
module.exports = λ(to){if (to.ζtoken === E.ζtoken) ↩; prop_extend(E,to); patches.forEach(λ(ι){ι(to)})}

// -------------------------------- discarded ------------------------------- //

// monkeypatch(λ(G){ G.Function.prototype.def = DEPRECATED(λ(m,get,set){Object.defineProperty(@.prototype,m,{configurable:true, enumerable:true, get:get, set:set}); ↩ @}) })
// E.poll = λ(f,cb){t←; (t=f())? cb.in(0,null,t) : poll.in(0.02,f,cb)}
// E.ζ2_memb_Emod_obj = λ(o,m,f){o[m] = f(o[m]); ↩ o}
// E.pad = λ(ι,s){↩ ι+s.slice(ι.length)}
// Array.prototype.zipmap = λ(f,ctx){↩ _.zip.apply(_,@).map(λ(ι){↩ f.apply(ctx,ι)})}
// String.prototype.replace_all = λ(find,replace){↩ @.replace(RegExp(regex_encode(find),'g'),replace)}
// Function.prototype.inherits = λ(super_){t ← λ(){}; t.prototype = super_.prototype; @.prototype = new t(); @.prototype.constructor = @; ↩ @}
// Path.prototype.cached = λ(){_$ ← @._$(); @._$ = λ(){↩ _$}; t ← @['=']; @['='] = λ(ι){_$ = ι; t(ι)}}

// create_getattr ← (λ(){
// 	proxy_boiler ← {getOwnPropertyDescriptor:λ(){}, getPropertyDescriptor:λ(){}, getOwnPropertyNames:λ(){↩[]}, getPropertyNames:λ(){↩[]}, defineProperty:λ(){}, delete:λ(){↩false}, fix:λ(){}, inspect:λ(){↩'[MAGIC-GET-ATTR]'}}
// 	↩ λ(get,set){↩ Proxy.create({get:λ(self,name){↩ proxy_boiler[name] || get(name)}, set:λ(self,name,ι){set(name,ι)}})} })()
// create_getattr(λ(n){@.$[n]},λ(n,ι){
// 			magic magic
// 			}),

// if (global.$) {
// keyinfo ← λ(key){
// 	t ← {'⇥':[9,'↓'],'↩':[13],'⎋':[27,'↑'],'←':[37,'↓'],'↑':[38,'↓'],'→':[39,'↓'],'↓':[40,'↓']}[key]||[]
// 	↩ {code: t[0] || typeof(key)==='number'? key : key.charCodeAt(0), $onfn: t[1]? {'↑':'keyup','↓':'keydown'}[t[1]] : 'keypress'} }
// $.prototype.on_key = λ(key,sel,cb0){if (!cb0) {cb0 = sel; sel = null}
// 	// t ← key.split(/(?=\.\w)/); key = t[0]; ns ← t.slice(1).join('')
// 	t ← keyinfo(key); @.on(t.$onfn/*+ns*/,sel,λ(e){if (e.which===t.code) ↩ cb0(e)}) }
// $.prototype.find_self = λ(sel){↩ @.find(sel).add(@.filter(sel))}
// }



// is_lazy ← λ(ι,name){t←; ↩ (t=Object.getOwnPropertyDescriptor(ι,name)) && (t=t.get) && t.ζ2_lazy}
// E.ζ2_bit_reverse_i = λ(length,ι){r ← 0; for (i←0;i<length;i++){r = (r << 1) | (ι & 1); ι = ι >> 1}; ↩ r}
// monkeypatch(λ(G){ G.Array.prototype.ζ2_take_while = λ(f){r ← []; _.any(@,λ(ι,i){t ← f(ι,i); t && r.push(ι); ↩ !t}); ↩ r} })
// E.ζ2_jsonclone = λ(ι){↩ ι===undefined? ι : JSON.parse(JSON.stringify(ι))}
// E.ζ2_now = DEPRECATED(λ ζ2_now(){↩ Date.now() / 1000})
// E.ζ2_i = DEPRECATED(λ ζ2_i(ι){↩ parseInt(ι)})
// E.ζ2_bind = DEPRECATED(λ ζ2_bind(o,ι){↩ o[ι].bind(o)})
// E.ζ2_bash_encode = DEPRECATED(E.bash_encode,'ζ2_bash_encode')
// monkeypatch(λ(G){ frames ← λ(){t ← Error.prepareStackTrace; Error.prepareStackTrace = λ(_,v){↩ v}; r ← new Error().stack.slice(1); Error.prepareStackTrace = t; ↩ r}; ('ˢ' in G) || Object.defineProperty(G,'ˢ',{get:DEPRECATED(λ multiline_silly(){t ← frames()[1]; ↩ t.getFunction().toString().replace(/^function /,'').split('\n').slice(t.getLineNumber() - 1).join('\n').slice(t.getColumnNumber() - 1).match(/\/\*([\s\S]*?)\*\//)[1]})}) })
// Path.prototype.as_type = DEPRECATED(λ Path_as_type(View){O_replace ← λ(ι,o){_.pairs(o).map(λ(kv){ι[kv[1]] = ι[kv[0]]; delete(ι[kv[0]])}); ↩ ι}; _(@).extend(O_replace(View,{'$':'_$'})); ↩ @}) // ⋈this is silly⋈
// Path.prototype.open = DEPRECATED(λ Path_open(f){path_open(@,f)})

// E.O = DEPRECATED(λ(){
// 	_O ← λ(ι){@.$ = ι}
// 	_O.prototype.set = λ(n,f){@.$[n] = f(@.$[n]); ↩ @.$}
// 	_O.prototype.def = λ(m,get,set){Object.defineProperty(@.$,m,{configurable:true, enumerable:true, get:get, set:set}); ↩ @.$}
// 	_O.prototype.replace = λ(o){θ ← @.$; _.pairs(o).map(λ(kv){θ[kv[1]] = θ[kv[0]]; delete(θ[kv[0]])}); ↩ @.$}
// 	↩ λ new_O(ι){↩ new _O(ι)} }())

// Path.prototype.parent = λ(){↩ fs(path.dirname(@.path))}
// Path.prototype.join = λ(){↩ fs(path.join.apply(path,[@.path].concat(A(arguments).map(λ(ι){↩ ι instanceof Path? ι.path : ι}))))}
// Path.prototype.stat = λ(){↩ fs.statSync(@.path)}
// Path.prototype.lines = λ(){t ← fs(@).$.split('\n'); t[-1]==='' && t.pop(); ↩ t}
// // i think slice maybe should actually replace splice?
// // Path.prototype.slice = λ(i){↩ ζ2_def({},'$',λ(){},λ(ι){path_open(@,λ(){t ← Buffer(ι); fs.writeSync(@.fd,t,0,t.length,i); fs.ftruncateSync(@.fd,i + Buffer.byteLength(ι))})})}
// Path.prototype.append = λ(ι){fs.appendFileSync(@.path,ι)}
// Path.prototype.unlink = λ(){fs.unlinkSync(@.path)}
// Path.prototype.rmrf = λ(){
// 	if (@.path === '/') throw Error('??? you tried to rmrf /')
// 	ˡ.rimraf.sync(@.path) }
// path_open ← λ(ι,f){fd ← fs.openSync(ι.path,'r+'); f.call(ι,fd); fs.closeSync(fd)}
// Path.prototype.ensure_eof_nl = λ(){path_open(@,λ(fd){
// 	size ← fs.statSync(@.path).size
// 	t ← Buffer(1); fs.readSync(fd,t,0,t.length,size - 1)
// 	if (t+'' !== '\n') {t ← Buffer('\n'); fs.writeSync(fd,t,0,t.length,size)}
// 	}); ↩ @}
// Path.prototype.splice = λ(idx,rm,ι){path_open(@,λ(fd){t←;
// 	ι = Buffer(ι)
// 	rm === ι.length || (t = Buffer(fs.statSync(@.path).size - (idx+rm)), fs.readSync(fd,t,0,t.length,idx+rm))
// 	fs.writeSync(fd,ι,0,ι.length,idx)
// 	rm === ι.length || fs.writeSync(fd,t,0,t.length,idx+ι.length)
// 	rm > ι.length && fs.ftruncateSync(fd,idx+ι.length+t.length)
// 	})}
