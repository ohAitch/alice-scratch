require_if ← λ(ι){try {↩ require(ι)} catch (e) {if (!(e.code === "MODULE_NOT_FOUND")) throw e}}
exports ← module.exports

node_path ← exports.path = require('path')
util ← exports.util = require('util')
repl ← require('repl')
vm ← require('vm')
child_process ← exports.child_process = require('child_process')

PQueue ← require_if('priorityqueuejs')
RWLock ← require_if('rwlock')
rimraf ← require_if('rimraf')
_ ← exports._ = require_if('underscore')
moment ← exports.moment = require_if('moment')

// todo: probably correct to lazy-load everything that's possible to
// Algebraic JavaScript Specification https://github.com/fantasyland/fantasy-land is cute and might be relevant to further builtin design
// todo: __ζ2_extend__ seems to be calling itself twice on things and this is bad

exports.__ζ2_extend__ = λ(to){to.__ζ2_extend__ === exports.__ζ2_extend__ || (_(to).extend(exports), monkeypatches.map(λ(f){f(to)}))}
monkeypatches ← []
monkeypatch ← λ(f){f(global); monkeypatches.push(f)}

// todo: refactor def, because it is awful

escape_regex ← λ(ι){↩ ι.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1')}
mkdir_p ← λ λ(ι){try {fs.statSync(ι).isDirectory() || fs.mkdirSync(ι)} catch (e) {if(!e.code==='ENOENT')throw e; λ(node_path.dirname(ι)); fs.mkdirSync(ι)}}
seq ← λ*(ι){for (i←0;i<ι.length;i++) yield ι[i]}
/*polyfill*/ Array.from || (Array.from = λ(ι){r ← []; while (t = ι.next(), !t.done) r.push(t.value); ↩ r})

exports.copy = λ(ι){
	t ← child_process.spawn('pbcopy')
	t.stdin.setEncoding('utf8')
	if (ι.pipe) ι.pipe(t.stdin)
	else t.stdin.end(
		Object.prototype.toString.call(ι) === '[object Object]'? util.inspect(ι, {depth:null}) :
		Object.prototype.toString.call(ι) === '[object Array]'? ι.map(λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι, {depth:null})}).join('\n') :
		Object.prototype.toString.call(ι) === '[object String]'? ι :
			ι.toString() )
	}
exports.paste = λ(){↩ child_process.execSync('pbpaste').toString()}
exports.ζ2_now = λ(){↩ Date.now() / 1000}
exports.ζ2_i = λ(ι){↩ parseInt(ι)}
exports.ζ2_bit_reverse_i = λ(length,ι){r ← 0; for (i←0;i<length;i++){r = (r << 1) | (ι & 1); ι = ι >> 1}; ↩ r}
ζ2_A ← exports.ζ2_A = λ(ι){↩ Array.prototype.slice.call(ι)}
monkeypatch(λ(G){ G.Function.prototype.P = λ(){if (arguments.length === 0) ↩ @; a ← ζ2_A(arguments); θ←@; ↩ λ(){↩ θ.apply(null,arguments.length === 0? a : a.concat(ζ2_A(arguments)))}} })
monkeypatch(λ(G){ G.Function.prototype.X = λ(n){θ←@; ↩ λ(){↩ θ.apply(null,ζ2_A(arguments).slice(0,n))}} })
monkeypatch(λ(G){ G.Array.prototype.ζ2_take_while = λ(f){r ← []; _.any(@,λ(ι,i){t ← f(ι,i); t && r.push(ι); ↩ !t}); ↩ r} })
monkeypatch(λ(G){ G.Array.prototype.ζ2_mapcat = λ(f){↩ _(@.map(f)).flatten(true)} })
exports.ζ2_repl_start = λ(opts){
	//! aaaaa why does this break if i remove useGlobal:true ?
	wrap ← λ(ι){t ← ι.replace(/\x1b\[.*?m/g,''); ↩ {$:ι, split:λ(){↩ [t]}, valueOf:λ(){↩ ι}}}
	t ← repl.start(_({useGlobal:true, ignoreUndefined:true, prompt:wrap('\x1b[32mζ₂\x1b[39m '),
		eval:λ(code,ctx,fl,cb){t←;
			if (ctx._ !== _) {ctx.__ = ctx._; ctx._ = _}
			if (ctx.fs !== fs && ctx.fs === require('fs')) ctx.fs = fs // hack: god, such a hack
			if (t=code.match(/^>(.*)/)) code = '__SPECIAL__('+util.inspect(t[1].trim())+')' // hack: for apprentice
			try {t = vm.createScript(exports.ζ2_compile(code), {filename:fl, displayErrors:false})}
			catch (e) {typeof(e.stack)==='string' && (e.stack = e.stack.replace(/(\n    at )[\s\S]*/,'$1<repl>')); cb(e,undefined); return}
			try {cb(undefined, @.useGlobal? t.runInThisContext({displayErrors:false}) : t.runInContext(ctx,{displayErrors:false}))}
			catch (e) {typeof(e.stack)==='string' && (e.stack = e.stack.replace(/^([\s\S]*)at repl:(.*)[\s\S]*?$/,'$1at <repl:$2>')); cb(e,undefined); return}
			},
		}).extend(opts))
	exports.__ζ2_extend__(t.context)
	// O(t).def('prompt',λ(){↩ t.prompt.$},λ(ι){t.prompt = wrap(ι)})
	↩ t}

O ← exports.O = λ(ι){↩ new _O(ι)}; _O ← λ(ι){@.$ = ι}
_O.prototype.set = λ(n,f){@.$[n] = f(@.$[n]); ↩ @.$}
_O.prototype.def = λ(m,get,set){Object.defineProperty(@.$,m,{configurable:true, enumerable:true, get:get, set:set}); ↩ @.$}
_O.prototype.replace = λ(o){θ ← @.$; _.pairs(o).map(λ(kv){θ[kv[1]] = θ[kv[0]]; delete(θ[kv[0]])}); ↩ @.$}
exports.ζ2_bind = λ(o,ι){↩ o[ι].bind(o)}
exports.ζ2_jsonclone = λ(ι){↩ ι===undefined? ι : JSON.parse(JSON.stringify(ι))}

sprint ← exports.sprint = λ(ι){↩ ι.map(λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{colors:true,depth:2})}).join(' ')}
print ← exports.print = λ(){a ← ζ2_A(arguments); process.stdout.write(sprint(a)+'\n'); ↩ a[-1]}
err ← exports.err = λ(ι){print.apply(null,['ζ2_err'].concat(ζ2_A(arguments))); throw Error(ι)}
_(exports).extend(_(Math).pick('abs','ceil','exp','floor','log','log10','log2','max','min','PI','pow','round','sqrt'))
_(exports).extend({ln: Math.log, ln2: Math.log2, ln10: Math.log10})
exports.multiline = λ(θ){ι ← θ.toString().split('\n').slice(1,-1); t ← Math.min.apply(null,ι.map(λ(ι){↩ ι.match(/^\t*/)[0].length})); ι = ι.map(λ(ι){↩ ι.slice(t)}); ↩ (ι[0]==="" && ι[ι.length-1]===""? ι.slice(1,-1) : ι).join('\n')}

monkeypatch(λ(G){ ('ˢ' in G) || Object.defineProperty(G,'ˢ',{get:λ(){t ← frames()[1]; ↩ t.getFunction().toString().replace(/^function /,'').split('\n').slice(t.getLineNumber() - 1).join('\n').slice(t.getColumnNumber() - 1).match(/\/\*([\s\S]*?)\*\//)[1]}}) })

exports.ζ2_gen2fn = λ(f){t ← f(); ↩ λ(){↩ t.next().value}}
monkeypatch(λ(G){ G.Function.prototype.def = λ(m,get,set){O(@.prototype).def(m,get,set); ↩ @} })
_ && monkeypatch(λ(G){ [G.Array,G.String,G.Buffer].forEach(λ(Class){ _.range(0,5).forEach(λ(i){Class.def('-'+i,λ(){↩ @.length<i? undefined : @[@.length-i]},λ(ι){↩ @.length<i? ι : (@[@.length-i] = ι)})}) }) })
monkeypatch(λ(G){ G.String.prototype.repeat = λ(x){↩ x<=0? '' : new Array(x+1).join(@)} })
monkeypatch(λ(G){ G.Array.prototype.repeat = λ(x){↩ x<=0? [] : _.range(0,x).map(_.constant(@))._.flatten(true)} })
monkeypatch(λ(G){ G.Array.def('_',λ(){↩ _(@)}) })
monkeypatch(λ(G){ G.Function.prototype.every = λ(time){args ← ζ2_A(arguments).slice(1); ↩ setInterval.apply(null,[@,time*1000].concat(args))} })
monkeypatch(λ(G){ G.Function.prototype.in = λ(time){args ← ζ2_A(arguments).slice(1); ↩ !time || time <= 0? setImmediate.apply(null,[@].concat(args)) : setTimeout.apply(null,[@,time*1000].concat(args))} })
monkeypatch(λ(G){t ← G.Buffer.prototype.inspect; G.Buffer.prototype.inspect.name === 'λ' || (G.Buffer.prototype.inspect = λ λ(){↩ t.call(@).replace(/(^<\w+)/,'$1['+@.length+']')}) })

if (PQueue && RWLock) {
// robust to setTimeout taking extra time
λs ← new PQueue(λ(a,b){↩ b.time-a.time}); lock ← new RWLock(); p←;
enq ← λ(ι){lock.writeLock(λ(R){λs.enq(ι); R(); if (!P){P = true; (λ poll(){lock.writeLock(λ λ(R){
	t←; λs.size() === 0? (P = false) : !(λs.peek().time < now())? poll.in(0.1) : (t=λs.deq(), t.canceled || t.f.in(), λ()); R&&R()
	}) })() } })}
monkeypatch(λ(G){ G.Function.prototype.at = λ(time){args ← ζ2_A(arguments).slice(1)
	t ← {time:time, f:@.P.apply(@,args)}
	if (time < now()) {t.f.in(); ↩ {clear:λ(){}}}
	else {enq(t); ↩ {clear:λ(){t.canceled = true}}} } })
}

// if (global.$) {
// keyinfo ← λ(key){
// 	t ← {'⇥':[9,'↓'],'↩':[13],'⎋':[27,'↑'],'←':[37,'↓'],'↑':[38,'↓'],'→':[39,'↓'],'↓':[40,'↓']}[key]||[]
// 	↩ {code: t[0] || typeof(key)==='number'? key : key.charCodeAt(0), $onfn: t[1]? {'↑':'keyup','↓':'keydown'}[t[1]] : 'keypress'} }
// $.prototype.on_key = λ(key,sel,cb0){if (!cb0) {cb0 = sel; sel = null}
// 	// t ← key.split(/(?=\.\w)/); key = t[0]; ns ← t.slice(1).join('')
// 	t ← keyinfo(key); @.on(t.$onfn/*+ns*/,sel,λ(e){if (e.which===t.code) ↩ cb0(e)}) }
// $.prototype.find_self = λ(sel){↩ @.find(sel).add(@.filter(sel))}
// }

if (moment) {m_old ← moment
moment = exports.moment = λ(i){↩ typeof(i)==='number' && arguments.length===1? m_old(i*1000) : m_old.apply(@,arguments)}
moment.__proto__ = m_old
moment.fn.valueOf = λ(){↩ +@._d/1000 + (@._offset||0)*60}
moment.fn.toString = λ(){↩ @.utc().format('YYYY-MM-DD[T]HH:mm:ss[Z]')}
moment.fn.inspect = λ(x,opts){t ← @.toString(); ↩ true/*opts.colors*/? '\x1b[35m'+t+'\x1b[39m' : t}
}

// --------------------------------- fs/Path -------------------------------- //

fs ← exports.fs = (λ(){t ← λ(path){↩ new Path(path)}; t.__proto__ = require('fs'); ↩ t})()
// a file is a key-value pair in a sort of fuzzy-keyed dict with many types, but primarily "key array" and "byte array, usually interpreted as string"
// represented as a Path, it has properties path and $/val/value/deref
// a Path is normally just a fluent wrapper but can become a file descriptor holder or an event manager
// maybe we can also pass it a type/format/view/mixin! eesh, maybe we need to fit it into the prototype system instead of just using a mixin...
Path ← /*fs.fn = */λ Path(path){
	@.path_ = path instanceof Path? path.path : path.replace(/^~(?=\/)/,process.env.HOME)
	@.path = path instanceof Path? path.path : node_path.normalize(@.path_+'/.')
	}
.def('$', λ(){↩ @._$()}, λ(ι){↩ @['='](ι)})
// path manipulation
Path.prototype.parent = λ(){↩ fs(node_path.dirname(@.path))}
Path.prototype.join = λ(){↩ fs(node_path.join.apply(node_path,[@.path].concat(ζ2_A(arguments).map(λ(ι){↩ ι instanceof Path? ι.path : ι}))))}
Path.prototype.stat = λ(){↩ fs.statSync(@.path)}
Path.prototype.dir = λ(){↩ fs.statSync(@.path).isDirectory()}
Path.prototype.resolve = λ(){↩ node_path.resolve(@.path)}
Path.prototype.exists = λ(){↩ fs.existsSync(@.path)}
Path.prototype.name = λ(ext){↩ node_path.basename(@.path,ext)}
// find
	// it's really weird how this returns a thing that you can't actually pass to fs()
	// maybe we'll fix this by returning a more magical, jquery-like thing?
Path.prototype.find = λ(sel){↩ Array.from(@.findˢ(sel))}
Path.prototype.findˢ = λ*(sel){
	// does not handle uniqueness in selections
	// wtf is up with selectors only being a .find() thing and not a fs() thing? and not returning selections so they're not chainable?
	// doesn't normalize everything properly or reliably
	// doesn't follow symlinks (note: when you do follow symlinks, know that not all symlinks lead places)

	WALK ← λ*(t,mode){
		switch (mode) {
			default: throw '↯'
			break; case '>': yield* seq(fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι}))
			break; case '*':
				root ← t+'/'
				//! bad - should use directed Dijkstra's from all roots with edge length equal to the number of files in a dir
				// sample impl:
					// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}
					// root ← '.'
					// dist ← {}; dist[root] = 0
					// next ← [root] // should be pqueue
					// out ← []
					// while (next.length) {t ← next._.min(λ(ι){↩ dist[ι]}); next = next._.without(t); out.push(t); at←; (at=all(t)).map(λ(ι){dist[ι] = dist[t] + at.length; next.push(ι)}) }
				// or just:
					// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}; root ← '.'; out ← []
					// (λ λ(ι,dist){out.push([dist,ι]); at←;(at=all(ι)).forEach(λ(t){λ(t,dist + at.length)})})(root,0)
					// q ← out._.sortBy(0)._.map(1)
				// note: as is will inf-loop on scary things
				walk_ ← λ*(ι){try {l ← fs.readdirSync(root+ι); for (i←0;i<l.length;i++){t ← ι+l[i]; try {fs.lstatSync(fs(root+t).path).isDirectory()? (yield root+t, yield* walk_(t+'/')) : yield root+t} catch (e) {}}} catch (e) {}}
				yield* walk_('')
			} }

	sel = sel.trim()
	if (sel === '') return

	ERR ← λ(){err('[ζ₂] selector is not supported: '+sel)}

	sel_a ← (' '+sel).replace(/(^|[^>* ])( +(?![>* ]))/g,'$1 * ').trim().split(/ +/)
	if (!sel_a.every(λ(ι){↩ ι.match(/^>|\*|\.\S+|#\S+$/)})) ERR()
	//! should be: if (!sel_a.every(λ(ι){↩ ι.match(/^(>|\*|\.\S+|#\S+)$/)})) ERR()

	r ← seq([@.path_])
	sel_a.forEach(λ(ι){
		r_ ← r
		temp ← (λ*(){t←; //r_ ← r
			sw←; switch (sw=ι[0], ι=ι.slice(1), sw) {
				default: ERR()
				break; case '>': case '*': while (t=r_.next(),!t.done) {t=t.value; yield* WALK(t, sw)}
				break; case '.': while (t=r_.next(),!t.done) {t=t.value; if (t.match(new RegExp(escape_regex('.'+ι)+'$'))) yield t}
				break; case '#': while (t=r_.next(),!t.done) {t=t.value; if (t.match(new RegExp(escape_regex(ι)+'$'))) {yield t; break}}
				} })()
		r = temp
		})

	yield* r}
// misc
Path.prototype.as_type = λ(View){_(@).extend(O(View).replace({'$':'_$'})); ↩ @} // ⋈this is silly⋈
// Path.prototype.cached = λ(){_$ ← @._$(); @._$ = λ(){↩ _$}; t ← @['=']; @['='] = λ(ι){_$ = ι; t(ι)}}
Path.prototype.toString = λ(){↩ @.resolve().replace(new RegExp('^'+escape_regex(process.env.HOME)+'(?=/)'),'~')}
// content manipulation
Path.prototype._$ = λ(){t ← @.path; ↩ !@.exists()? '' : @.dir()? (print('[ζ₂] [deprecated] dir.$'), fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι})) : fs.readFileSync(t)+''}
Path.prototype['='] = λ(ι){
	// string: text file, Array: directory, etc
	// async should use like fs.createReadStream(ι.path).pipe(fs.createWriteStream(@.path))
	if (@.exists() && @.dir()) throw Error('writing to directories not implemented')
	mkdir_p(@.parent().resolve())
	fs.writeFileSync(@.path,ι)
	}
Path.prototype.lines = λ(){t ← fs(@).$.split('\n'); ↩ t[-1]===''? t.slice(0,-1) : t}
Path.prototype.open = λ(f){fd ← fs.openSync(@.path,'r+'); f.call(@,fd); fs.closeSync(fd)}
// i think slice maybe should actually replace splice?
// Path.prototype.slice = λ(i){↩ ζ2_def({},'$',λ(){},λ(ι){@.open(λ(){t ← new Buffer(ι); fs.writeSync(@.fd,t,0,t.length,i); fs.ftruncateSync(@.fd,i + Buffer.byteLength(ι))})})}
Path.prototype.append = λ(ι){fs.appendFileSync(@.path,ι)}
Path.prototype.ensure_eof_nl = λ(){@.open(λ(fd){
	size ← @.stat().size
	t ← new Buffer(1); fs.readSync(fd,t,0,t.length,size - 1)
	if (t+'' !== '\n') {t ← new Buffer('\n'); fs.writeSync(fd,t,0,t.length,size)}
	}); ↩ @}
Path.prototype.splice = λ(idx,rm,ι){@.open(λ(fd){t←;
	ι = new Buffer(ι)
	rm === ι.length || (t = new Buffer(@.stat().size - (idx+rm)), fs.readSync(fd,t,0,t.length,idx+rm))
	fs.writeSync(fd,ι,0,ι.length,idx)
	rm === ι.length || fs.writeSync(fd,t,0,t.length,idx+ι.length)
	rm > ι.length && fs.ftruncateSync(fd,idx+ι.length+t.length)
	})}
Path.prototype.unlink = λ(){fs.unlinkSync(@.path)}
Path.prototype.rmrf = λ(){
	if (@.path === '/') err('??? you tried to rmrf /')
	rimraf.sync(@.path) }

// ----------------------------------- new ---------------------------------- //

exports.λ = λ(ι){r ← λ(i){↩ ι[i]}; r.ι = ι; ↩ r}
monkeypatch(λ(G){ G.String.def('λ',λ(){θ←@; r ← λ(ι){↩ ι[θ]}      ; r.ι = @; ↩ r}) })
monkeypatch(λ(G){ G.Number.def('λ',λ(){θ←@; r ← λ(ι){↩ ι[θ]}      ; r.ι = @; ↩ r}) })
monkeypatch(λ(G){ G.RegExp.def('λ',λ(){θ←@; r ← λ(ι){↩ ι.match(θ)}; r.ι = @; ↩ r}) })

exports.pipe_in_out = λ(f){
	read_all ← λ(θ/*Readable*/,cb){t ← []; θ.resume(); θ.setEncoding('utf8'); θ.on('data',λ(ι){t.push(ι)}); θ.on('end',λ(){cb(null,t.join(''))})}
	read_all(process.stdin, λ(e,ι){process.stdout.write(f(ι))}) }

;(λ(){
osa_gen ← λ(ι){↩ "osascript -ss "+ι.split(/; */).map(λ(ι){↩ "-e "+bash_encode(ι)}).join(" ")}
osa_parse_array ← λ(ι){if (ι!=='') ↩ JSON.parse(ι.split(/("(?:\\.|.)*?")/g).map(λ(ι){↩ /^"/.λ(ι)? ι : ι.replace(/\{/g,'[').replace(/\}/g,']')}).join(''))} // based on https://github.com/FWeinb/node-osascript/blob/master/lib/osa-parser.peg
exports.osa = λ(ι){child_process.exec(osa_gen(ι))}
exports.osaᵥ = λ(ι){↩ osa_parse_array(child_process.execSync(osa_gen(ι))+'')}
})()
exports.bash = λ(ι){child_process.exec("bash -c "+bash_encode(ι))}
exports.bashᵥ = λ(ι){↩ (child_process.execSync("bash -c "+bash_encode(ι))+'').replace(/\n$/,'')}

exports.bash_encode = exports.ζ2_bash_encode = λ(){↩ ζ2_A(arguments).map(λ(ι){↩ "'"+ι.replace(/'/g,"'\\''")+"'"}).join(" ")}
exports.basename_encode = λ(ι){↩ ι.replace(/\//g,'⟩')}
exports.osa_encode = λ(ι){↩ '"'+ι.replace(/["\\]/g,'\\$&')+'"'} // probably incomplete

// ----------------------------- discarded bits ----------------------------- //

// exports.poll = λ(f,cb){t←; (t=f())? cb.in(0,null,t) : poll.in(0.02,f,cb)}
// exports.ζ2_memb_Emod_obj = λ(o,m,f){o[m] = f(o[m]); ↩ o}
// exports.pad = λ(ι,s){↩ ι+s.slice(ι.length)}
// Array.prototype.zipmap = λ(f,ctx){↩ _.zip.apply(_,@).map(λ(ι){↩ f.apply(ctx,ι)})}
// String.prototype.replace_all = λ(find,replace){↩ @.replace(new RegExp(escape_regex(find),'g'),replace)}
// exports.ζ2_lazy = λ(o,m,f){ζ2_def(o,m,_.once(λ(){delete(o[m]); ↩ o[m] = f()}),λ(ι){delete(o[m]); ↩ o[m] = ι})}
// Function.prototype.inherits = λ(super_){t ← λ(){}; t.prototype = super_.prototype; @.prototype = new t(); @.prototype.constructor = @; ↩ @}

// create_getattr ← (λ(){
// 	proxy_boiler ← {getOwnPropertyDescriptor:λ(){}, getPropertyDescriptor:λ(){}, getOwnPropertyNames:λ(){↩[]}, getPropertyNames:λ(){↩[]}, defineProperty:λ(){}, delete:λ(){↩false}, fix:λ(){}, inspect:λ(){↩'[MAGIC-GET-ATTR]'}}
// 	↩ λ(get,set){↩ Proxy.create({get:λ(self,name){↩ proxy_boiler[name] || get(name)}, set:λ(self,name,ι){set(name,ι)}})} })()
// create_getattr(λ(n){@.$[n]},λ(n,ι){
// 			magic magic
// 			}),
