// ---------------------------------- util ---------------------------------- //
delete Object.prototype._

Pretty_Typed ← λ(type,ι){ @.type = type; _(@).assign(ι) }
Pretty_Typed.prototype.inspect = λ(d,opt){
	ty ← opt.stylize(@.type,'special')
	if (_(@).keys()._.isEqual(['type','ι']) && @.type!=='?scope') ↩ ty+' '+util.inspect(@.ι,opt)
	else{
		t ← _(_(@).pairs()._.object()).omit('type')
		if (@.found_by && @.ι) t.ι = {inspect(){↩ '...'}}
		if (@.type==='?scope') t.ι = {inspect(){↩ '...'}}
		t = util.inspect(t,opt); ↩ t[0]+ty+t.slice(1) } }
τ ← (type,ι)=> new Pretty_Typed(type,ι)
τι ← (type,ι)=> τ(type,{ι})

interesting ← ι=> 0?0 // ast -> bool
	: ι.type==='seq'? ι.ι.some(interesting)
	: ι.type==='js_data'? ι.ι !== undefined
	: true

// -------------- convert babylon ast into intermediate format -------------- //
parse ← code=>{
	t ← npm`babylon@6.14.1`.parse(ζ_compile(code),{allowReturnOutsideFunction:true})
	t = walk_obj_edit(t,ι=>{
		// --------------- error on asts i dont know how to handle -------------- //
		ι.directives && ( !ι.directives.length || ‽(ι) )
		if (ι.type==='VariableDeclaration') ι.kind==='var' || ‽(ι)
		if (ι.type==='VariableDeclarator') ι.id.type==='name' || ‽(ι)
		if (ι.type==='MemberExpression') (!ι.computed || ι.property.type==='name') || ‽(ι)
		if (ι.type==='ArrowFunctionExpression'||ι.type==='FunctionExpression') ( ι.generator===false && ι.async===false && ι.params.every(ι=> ι.type==='name') ) || ‽(ι)
		if (ι.type==='BinaryExpression') _(['+','*']).contains(ι.operator) || ‽(ι)
		if (ι.type==='ObjectProperty') ι.method===false || ‽(ι)
		// ----------------------- simplify babylon's ast ----------------------- //
		ι = _(ι).omit('start end loc directives leadingComments trailingComments __clone'.split(' '))
		ι = 0?0
		: ι.type==='File'? ι.program
		: ι.type==='Program'? τι('seq',ι.body)
		: ι.type==='VariableDeclaration'? τι('seq',ι.declarations)
		: ι.type==='VariableDeclarator'? τ('local_private_slot',{ name:ι.id, ι:ι.init })
		: ι.type==='Identifier'? τι('name',ι.name)
		: ι.type==='ExpressionStatement'? ι.expression
		: ι.type==='MemberExpression'? τ('member',{ o:ι.object, m: ι.computed? ι.property : τι('js_data',ι.property.ι) })
		: ι.type==='CallExpression'? (λ(){ o ← ι.callee; tname←; ↩ 0?0
			: o.type==='member'?
				τ('call',{ o:τ('member',{ o:
					τ('heap',{ name:tname=τι('name',rand_id(9)), ι:o.o }),
					m:o.m }), self:tname, a:ι.arguments })
			: τ('call',{ o, self:τι('js_data',undefined), a:ι.arguments })
			})()
		: ι.type==='NumericLiteral'? τι('js_data',ι.value)
		: ι.type==='StringLiteral'? τι('js_data',ι.value)
		: ι.type==='RegExpLiteral'? τι('js_data',RegExp(ι.pattern,ι.flags))
		: ι.type==='ObjectExpression'? τι('object',ι.properties.map(ι=>[ ι.computed? ι.key : τι('js_data',ι.key.ι), ι.value ]))
		: ι.type==='ArrowFunctionExpression'||ι.type==='FunctionExpression'?
			τ('function',{
				name:ι.id,
				params:[ι.type==='ArrowFunctionExpression'? undefined : 'this',…ι.params.map(ι=>ι.ι)],
				lexical_scopes:undefined,
				ι:ι.expression? ι.body : τι('seq',[ι.body,τι('js_data',undefined)]) })
			//! this should have bound the names in the function at “munge ast” time
			// ‡ this is the next step, right?
			// ‡ i want you to examine the entire plan and decide the next step, which could be this
			// we can find the lexical scopes at this time
		: ι.type==='BinaryExpression'? τ('builtin',{ f:ι.operator, a:[ι.left,ι.right] })
		: ι.type==='BlockStatement'? τι('seq',ι.body)
		: ι.type==='ReturnStatement'? τι('seq',[τι('set_result',ι.argument),τ('break_fn',{})])
		: ι
		↩ ι})
	// -------------------------------------------------------------------------- //
	opti_semantic ← ι=>{ // or simplify_or_enhance_semantics
		if (ι.type==='seq'){
			// seq[seq[]] -> seq[]
			ι.ι = ι.ι.mapcat(ι=> ι.type==='seq'? ι.ι : [ι])
			// break; foo() -> warning
			i ← ι.ι.findIndex(ι=> ι.type==='break_fn')
			dead ← i===-1? [] : ι.ι.splice(i+1,Infinity)
			if (dead.some(interesting)) cn.log('[warning]','you have interesting dead code',dead)
			// seq[ι] -> ι
			if (ι.ι.length===1) ι = ι.ι[0]
			}
		if (ι.type==='function'){
			edit ← false
			if (ι.ι.type==='seq' && ι.ι.ι[-1].type==='break_fn'){ ι.ι.ι.pop(); edit = true }
			if (ι.ι.type==='seq' && ι.ι.ι[-1].type==='set_result'){ ι.ι.ι[-1] = ι.ι.ι[-1].ι; edit = true }
			if (edit) ι.ι = opti_semantic(ι.ι)
			}
		↩ ι}
	t = walk_obj_edit(t,opti_semantic)
	// ------------------------- build lexical scopes ------------------------- //
	scopes ← [τι('?scope','global')]
	walk_both_obj(t,
		ι=>{ if (ι.type==='function'){ scopes.push(τι('?scope',ι)); ι.lexical_scopes = _.clone(scopes) } },
		ι=>{ if (ι.type==='function') scopes.pop() })
	// ‡ what is the appropriate format for lexical_scopes? especially considering i dont exactly want it printed. maybe change the printer to only print a function once, later referring to it by name? that would be weird, but...
	↩ t}

// ----------- convert my abstract data to native javascript data ----------- //
compile ← ι=> 0?0
	: ι.type==='js_data'? ι.ι
	: ι.type==='closure'? λ(…a){↩ compile(create_root_stack_and_eval(τ('call',{ o:ι, self:τι('js_data',@), a:a.map(ι=> τι('js_data',ι)) })).ι) }
	:( ι = τι('<not_compiled>',ι), cn.log(ι), ι )

// -------------------- eval my ast into my abstract data ------------------- //
create_root_stack_and_eval ← (ast,opt={})=>{
	var {global_={}} = opt
	heap ← {}
	stack ← [{}]
	ctx ← '?scope?global'
	// heap ← {}
	// global_ ← {}
	// ‡ no
	// ‡ we screwed up the :stack: thing
	// ‡ so when does :resolve: happen? i thought that was at compile time...
	// ‡ write out the new plan carefully; i think we can implement it in one go, but we need to be careful.
	// ‡ in es6 in 'use strict', afaict resolve happens -in effect- at compile time
	// ‡ in nonstrict eval can do weird things, but
	// ‡ i think we can make a plan that's compatible with not representing js semantics exactly?
	// // ---------- ‡ --------- //
	// ‡ there is no compile time; there is just execution
	// ‡ resolve first in local scope, then in higher scopes, then in global scope
	// // ‡ do not execute code in global scope, that is silly; if you want to do the js thing, detect global scope and change vars into global assignment
	// ‡ to do this we must be able to walk up the ast, or at least the scopes, from any position
	// ‡ 

	resolve ← (ι,ctx)=> heap[ι] || ctx.scope[ι] || global_[ι] || τ('‽',{ found_by:ι })
	// =>{t←; if (t=heap[ι]) ↩ t;
	// 	if (t=ctx.scope[ι]) ↩ t
	// 	// for(i←stack.length-1;i>=0;i--) if (t=stack[i][ι]) ↩ t;
	// 	if (t=global_[ι]) ↩ t; ↩ τ('‽',{ found_by:ι }) }

	eval_ ← ι=> 0?0
		: ι.type==='seq'? ι.ι.map(eval_)[-1]
			// (λ(){ t←; for(i←0;i<ι.ι.length;i++){ t = eval_(ι.ι[i]); if (t.type==='‽') ↩ [t,eval_(ι.ι.slice(i+1))] }; ↩ t })()
		: ι.type==='local_private_slot'? stack[-1][ι.name.ι] = eval_(ι.ι)
		: ι.type==='heap'?( heap[ι.name.ι] = eval_(ι.ι) )
		: ι.type==='name'? resolve(ι.ι)
		: ι.type==='call'? call(eval_(ι.o),[ι.self,…ι.a].map(eval_))
		: ι.type==='member'? (λ(){ o ← compile(eval_(ι.o)); m ← compile(eval_(ι.m)); Tstr(m) || ‽(ι); ↩ τι('js_data',o[m]) })()
		: ι.type==='function'? τ('closure',{ ι })
			// should it find the closure vars here? yes.
		: ι.type==='js_data' || ι.type==='closure'? ι
		: τι('<not_evald>',ι)

	call ← (o,a,r=undefined)=> 0?0
		: o.type==='js_data'? τι('js_data', compile(o).call(…a.map(compile)) )
		: o.type==='closure'?(
			stack.push(o.ι.params.map((k,i)=> [k,a[i]]).filter(ι=>ι[0])._.object()),
			(r = eval_(o.ι.ι)),
			stack.pop(),
			r )
		: τι('<not_evald>',ι)

	↩ {ι:eval_(ast), stack, heap} }

// ---------------------------------- test ---------------------------------- //
// code ← φ`~/file/code/scratch/ζ/parsimmon2.ζ`.text
// code ← `rand_id_ ← L=> L.map(ι=> rand( _.range(0,0x100).map(ι=> String.fromCodePoint(ι)).filter(ι=> ι.match(/[0-9a-z]/)) )).join(''); _.range(5).map(rand_id_)`
// code ← `q ← ι=> _.range(0,0x100); _.range(5).map(q)`
// code ← `q ← ι=> _.range(0,0x100); _.range(1).map(q)`
code ← `(λ a(){ b ← λ b(){ y ← 2; c ← λ c(){ ↩ {a:a.name,b:b.name,c:c.name,x,y} }; z ← 7; ↩ c }; x ← 5; ↩ b })()()()`
global_ ← _({ _, rand, String, }).map((ι,k)=> [k,τ('js_data',{ι,found_by:k})])._.object()
ast = parse(code)
t ← create_root_stack_and_eval(ast,{global_})
t = { ast, heap:t.heap, global_, ι:t.ι }
t

// ‡ figure out how you want to handle native exceptions, applicable on ι.type call and maybe member
