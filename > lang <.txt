we lack knowledge on:
	haskell
		syntax
		abstractions
		lens library
	algebraic datatypes (ocaml?)
	pattern matching (ocaml?)
		http://en.wikipedia.org/wiki/Perl_6_rules
	spend some hours playing with scipy.org/getting-started.html. maybe make something with it (http://vetta.org/2008/05/scipy-the-embarrassing-way-to-code/)
	async: now investigating F# and Haskell! see bookmarks. (also, c# await is nice)
	we've been too ugh about js harmony. look at all of its things?
	separators. which symbols and where should they be
		separatorless style works very well with atomically-delimited style
		the - general problem is that humans need delimiters? or - that the ways we express ourselves in text trip over each other and need delimiting?
	Julia makes it unusually easy to define custom numerical types and allow them to interact smoothly with other types – both built-in and user-defined. At first this may seem like a novelty, but many practical applications have emerged, from doing efficient computation with units to working conveniently with image data in hardware-friendly formats. This talk will start with some toy examples, then explore how Julia's "built-in" types are really just user-defined types that happen to be provided by default, and go on to examine some of the clever and practical ways that Julia's custom numerical types have been used to solve real-world problems. In the process, we'll cover some of the major concepts behind Julia, including multiple dispatch as its core paradigm and having an expressive language of types in a dynamic language.

http://elm-lang.org/
http://elm-lang.org/blog/Introducing-Elm-Reactor.elm

powerful collection manipulation
	https://en.wikipedia.org/wiki/Rank_(J_programming_language).
https://github.com/jashkenas/coffeescript/blob/master/src/grammar.coffee
https://github.com/jashkenas/coffeescript/blob/master/src/lexer.coffee
https://github.com/jashkenas/coffeescript/blob/master/src/rewriter.coffee
function syntax is decent: (a=1,b,c...) -> a * b with ending based on whitespace (AND a.b(c...) ↔ a.b.apply(a,c))
treats nonseparated symbols as a function call
fat arrow => binds the function to the current value of this
you can do slicing with ranges
@ is still an alias for this
consider aliasing :: to prototype
the postfix operator ? is like (v) -> v=!null
it has ?. and also ?(), but should have more general nullsafing
we have needs for syntax for: currying, binding (&. ?), async
unicode is tasty but many people absolutely will not type it. one easy way of doing unicode would be to have it strictly as a preprocessing step!
concatenation oughta be * but that is hard because reasons. what about ~ ?
generalized mutation operators (+=, swap!, etc) e.g. something like `(t=f()).string = t.string.toUpperCase()` -> `f().string ??? .toUpperCase()`
i have always wished there was some good way of doing units, like `16 newtons` or `6 meters` (could not super-smart primitive wrappers do the trick?)
problem of too much punctuation: ruby's end or algol's fi or od or esac is a very nice solution
ruby &:symbol is super cute
shit, it looks like both alignment and indentation are totally redundant

-------- don't forget --------
vanilla destructuring, plus ([open, contents..., close] =) and ([first, ..., last] =) and you've even got ({@name, @age, @height} =)
loop control flow is made out of list comprehensions
chained comparisons
