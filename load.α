#!/usr/bin/env node
//"use strict"

//repl ← require('repl')
fs ← require('fs')
_ ← require('../lib/underscore-min')
//module.exports.hex ←! hex

//__sub__ ← λ{__get__(v,b)}
__slice__ ← λ(v,a,b){return b=undefined? v.slice(a) : (v.slice(a,b))}
__sliceλ__ ← λ(a,b){return b=undefined? λ{v[a:]} : λ{v[a:b]}}

//===--------------------------------------------===// utils //===--------------------------------------------===//

print ← console.log.bind(console)
memoize_o ← λ(o,f){return λ(v){r ← own(o,v); return (r=undefined)? (oᵥ ←! f(v)) : r}}
merge_o ← λ(){r ← {}; Array.prototype.slice.apply(arguments).forEach(λ{Object.keys(v).forEach(λ(k){rₖ ←! vₖ})}); return r}
Object.map ←!  λ(v,f){f ← f || λ{[v,b]};    r ← {}; Object.keys(v).forEach(λ(k){t ← f.call(v, k, vₖ);	if (t) r[t₀] ←! t₁}); return r}
Object.mapv ←! λ(v,f){f ← f || λ{[v,true]}; r ← {};         seq(v).forEach(λ(v){t ← f(v);           	if (t) r[t₀] ←! t₁}); return r}
dict_by ← λ(v,f){return Object.mapv(v,λ{[f(v),v]})}
frequencies ← λ(v){r ← {}; v.forEach(λ{rᵥ ←! v in r? rᵥ+1 : 1}); return r}
pad_left ← λ(v,s,l){while (v.length < l) v ←! s + v; return v}
hex ← λ(v,l){return pad_left(v.toString(16),'0',l)}
now ← λ{Date.now() / 1000}
run ← {
	in:   λ(s,f){return {id:setTimeout( f,s*1000), cancel:λ{cancelTimeout( this.id)}}},
	every:λ(s,f){return {id:setInterval(f,s*1000), cancel:λ{cancelInterval(this.id)}}},
	tomorrow:λ(f){
		start ← new Date()
		cancel ← false
		r ← run.in(new Date(start).setHours(24,0,0,0)/1000 - start/1000,
			λ(){if (new Date().getDate() = start.getDate()) run.in(1,λ); else {if (¬cancel) f()}})
		return {cancel:λ(){cancel ←! true; r.cancel()}}}
	}
ord ← λ{v.charCodeAt(0)}
chr ← λ{String.fromCharCode(v)}
seq ← λ{v isa Array? v : typeof(v)='string'? v.split('') : Object.keys(v).map(λ(k){return [k,vₖ]})}
own ← λ(o,m){if (Object.prototype.hasOwnProperty.call(o,m)) return oₘ}
err ← λ(){print.apply(console, ['#error#:'].concat(Array.prototype.slice.apply(arguments))); throw Error()}
extend_function ← λ(f){r ← λ(){r ← f(); r.__proto__ ←! λ.prototype; return r}; r.prototype.__proto__ ←! Function.prototype; return r}
delset ← λ(o,m,v){if (v=undefined) delete(oₘ); else oₘ ←! v}
windows ← λ(n,l){r ← []; while (l.length ≥ n) {r.push(l[:n]); l ←! l[1:]} return r}
//guid ← λ{'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, λ(v){r ← Math.random()*16|0; return (v='x' ? r : (r&0x3|0x8)).toString(16)})}
empty ← λ{v.length=0}
is ← λ{v≠undefined}
String.prototype.repeat ←! λ{new Array(v+1).join(this)}
//Array.prototype.interpose ←! λ(sep){return this.map(λ{v.concat(sep)}).m_concat()[:-1]}
Array.prototype.m_concat ←! λ{Array.prototype.concat.apply([],this)}
Date.prototype.hours ←! λ(v){this.setHours(this.getHours()+v); return this}
Date.prototype.yyyy_mm_dd ←! λ(){m ← (this.getMonth()+1)+''; d ← this.getDate()+''; return this.getFullYear()+'-'+(m₁?m:'0'+m)+'-'+(d₁?d:'0'+d)}

//===--------------------------------------------===// characters //===--------------------------------------------===//

js_valid_symbol ← new (λ(){
	_short ← {' ':'_', '!':'1', '#':'3', '%':'5', '&':'7', '(':'9', ')':'0', '*':'8', '+':'p', ',':'C', '-':'m', '.':'d', '/':'s', ':':'c', '=':'E', '?':'q', '@':'2', '[':'L', '\\':'b', '^':'6', '`':'k', '{':'B', '|':'o', '~':'t', '…':'r', '←':'w', '→':'e', '¬':'n', '∀':'A', '≠':'N', 'ǂ':'ǂ', '<':'lt', '≤':'le', '>':'gt', '≥':'ge'}
	encode_short ← Object.map(_short,λ{[v,'ǂ'+b]})
	decode_short ← Object.map(_short,λ{[b,v]})
	is_start ← memoize_o(Object.mapv(';ǂ \t\n\x0b\x0c\x0d',λ{[v,false]}),λ(v){try {eval('var '+v )} catch (e) {return false} return true})
	is_part  ← memoize_o(Object.mapv(';ǂ \t\n\x0b\x0c\x0d',λ{[v,false]}),λ(v){try {eval('var a'+v)} catch (e) {return false} return true})
	encode_char ← memoize_o(encode_short, λ(v){return is_part(v)? v : 'ǂu'+hex(ord(v),4)})

	keywords ← ['break','do','instanceof','typeof','case','else','new','var','catch','finally','return','void','continue','for','switch','while','debugger','function','this','with','default','if','throw','delete','in','try','class','enum','extends','super','const','export','import','implements','let','private','public','yield','interface','package','protected','static']
	encode_keywords ← Object.mapv(keywords,λ{[v,'ǂ'+v]})
	decode_keywords ← Object.map(encode_keywords,λ{[b,v]})

	this.is_part ←! is_part
	this.encode ←! memoize_o(encode_keywords,λ(v){r ← seq(v).map(encode_char).join(''); return is_start(r₀)? r : 'ǂ'+r})
	this.decode ←! memoize_o(decode_keywords,λ(v){
		v ← v₀='ǂ'? v[1:] : v
		r ← ''; i←undefined; while ((i←!v.indexOf('ǂ')) ≠ -1) {
			r += v[0:i]; v ←! v[i+1:]
			if (v₀='u') {r += chr(parseInt(v[1:5],16)); v ←! v[5:]}
			else if (v₀='l' || v₀='g') {r += decode_short[v[:2]]; v ←! v[2:]}
			else {r += decode_short[v₀]; v ←! v[1:]}
			} return r+v})
	})
unicode ← λ(table){return {
	subscripts:   table.map(λ{v₀}).filter(λ{v≠'-'}),
	midscripts:   table.map(λ{v₁}),
	superscripts: table.map(λ{v₂}).filter(λ{v≠'-'}),
	subscript:   λ(f){return λ{seq(v).map(λ{f[v]}).join('')}}(Object.mapv(table.map(λ{[[v₁,v₀], [v₂,v₀]]}).m_concat(),λ{v})),
	midscript:   λ(f){return λ{seq(v).map(λ{f[v]}).join('')}}(Object.mapv(table.map(λ{[[v₀,v₁], [v₂,v₁]]}).m_concat(),λ{v})),
	superscript: λ(f){return λ{seq(v).map(λ{f[v]}).join('')}}(Object.mapv(table.map(λ{[[v₀,v₂], [v₁,v₂]]}).m_concat(),λ{v}))
	}}('₀0⁰ ₁1¹ ₂2² ₃3³ ₄4⁴ ₅5⁵ ₆6⁶ ₇7⁷ ₈8⁸ ₉9⁹ ₊+⁺ ₋-⁻ ₌=⁼ ₍(⁽ ₎)⁾ ₐaᵃ -bᵇ -cᶜ -dᵈ ₑeᵉ -fᶠ -gᵍ ₕhʰ ᵢiⁱ ⱼjʲ ₖkᵏ ₗlˡ ₘmᵐ ₙnⁿ ₒoᵒ ₚpᵖ ᵣrʳ ₛsˢ ₜtᵗ ᵤuᵘ ᵥvᵛ -wʷ ₓxˣ -yʸ -zᶻ -Aᴬ -Bᴮ -Dᴰ -Eᴱ -Gᴳ -Hᴴ -Iᴵ -Jᴶ -Kᴷ -Lᴸ -Mᴹ -Nᴺ -Oᴼ -Pᴾ -Rᴿ -Tᵀ -Uᵁ -Vⱽ -Wᵂ'.split(' '))

//===--------------------------------------------===// <edge> //===--------------------------------------------===//

running_as ← process.argv₁.match(~/[^\\]*\\[^\\]*$/)₀
print('--- running as:',running_as,'---')

Symbol ← λ(v,line){this.v ←! v; if (line) this.line ←! line}
	Symbol.prototype.space ←! λ(v){if (v=undefined) {return (this.space_before?'_':'')+'$'+(this.space_after?'_':'')} else {if (v₀≠'_') this.space_before ←! false; if (v₋₁≠'_') this.space_after ←! false; return this}}
	Symbol.prototype.space_before ←! true
	Symbol.prototype.space_after ←! true
	Symbol.prototype.inspect ←! λ{'`'+this.v}
	Symbol.prototype.with_v ←! λ(v){r ← new Symbol(v,this.line); if (¬this.space_before) r.space_before ←! false; if (¬this.space_after) r.space_after ←! false; return r}
	S ← λ(v){r ← new Symbol(v.replace(~/^ /,'').replace(~/ $/,'')); if (v₀≠' ') r.space_before ←! false; if (v₋₁≠' ') r.space_after ←! false; return r}
	symbol_set_decode ← λ(v){
		n ← v; s ← ''
		t ← v.match(~/^(([−↔±∓])\2*)(.*)$/);  s += t && t₁.length%2≠0? t₂ : '?'; v ← t? t₁[:Math.floor(t₁.length/2)]+t₃ : v
		t ← v.match(~/^(.*?)(([−↔±∓])\3*)$/); s += t && t₂.length%2≠0? t₃ : '?'; v ← t? t₂[:Math.floor(t₂.length/2)]+t₁ : v
		n ← v=''? n : v; s ← v=''? '??' : s
		return (symbol_set_table[s]||err('bad symbol set',s)).map(λ{new Symbol(n).space(v)})}
		symbol_set_table ← {
			'−−':['$'],
			'−↔':['$_'],
			'↔−':['_$'],
			'↔↔':['_$_'],
			'?−':['$','_$'],
			'?↔':['$_','_$_'],
			'−?':['$','$_'],
			'↔?':['_$','_$_'],
			'±±':['$','_$_'],
			'±∓':['$_','_$'],
			'??':['$','$_','_$','_$_']
			}
	symbol_set_decode_ ← λ{symbol_set_decode(v)₀.v}
SP ← {}

// hacks
se ← λ{(v isa Symbol) && v.v=b}
split_symbol ← λ(l,s){r ← [[]]; l.map(λ(v){if (se(v,s)) r.push([]); else r₋₁.push(v)}); return r}
has_sym ← λ(v,s){return v.some(λ{se(v,s)})}
split_slice ← λ(l){r ← split_symbol(l,':'); r ← [[(r₀₀=undefined? S('0') : r₀₀)]].concat(r[1:]).m_concat(); return r}
pr ← λ(){if (running_as = 'bin\\load.js') print.apply(this,['##'].concat(Array.prototype.slice.apply(arguments))); return arguments₀}

String.prototype.repr ←! String.prototype.repr_js ←! λ(){v ← this.valueOf(); return (v.match(~/'/g)||[]).length ≤ (v.match(~/"/g)||[]).length? //?
	"'"+seq(v).map(λ{{"'":"\\'",'\n':'\\n','\t':'\\t','\\':'\\\\'}ᵥ || (printable(v)? v : '\\u'+hex(ord(v),4))}).join('')+"'" :
	'"'+seq(v).map(λ{{'"':'\\"','\n':'\\n','\t':'\\t','\\':'\\\\'}ᵥ || (printable(v)? v : '\\u'+hex(ord(v),4))}).join('')+'"'}
RegExp.prototype.repr ←! RegExp.prototype.repr_js ←! λ{this+''}

printable ← λ{λᵥ}

repr_js_trans_infix ← merge_o({'&':'&&','|':'||','isa':'instanceof','=':'===','≠':'!==','≤':'<=','≥':'>='},dict_by('. * / % + - < > in && || +='.split(' '),λ{v}))
repr_js ← λ(v,line){rj ← λ{repr_js(v,line)}; mrj ← λ{v.map(rj).join(b||'')}; ln ← λ{(v && v.line && line? '\n'.repeat(λ(v){line₀ += v; return v}(Math.max(0, v.line-line₀))) : '')}
	return v=undefined? pr('<gah>',line₀) :
		v.repr_js? v.repr_js(line) :
		v isa Symbol? ln(v) + (v.space_before?' ':'') + (v.v='/'?'÷':v.v) + (v.space_after?' ':'') :
		v isa Array?
			empty(v)? '()' :
				v₀ isa Symbol? ln(v₀) + (
					v₀.v='__literal__'? v₁+'' :
					//v₀.v='__do__'? v.length=2? rj(v₁) : '{'+mrj(v[1:],';')+'}' :
					v₀.v='__do__e'? '('+rj(v₁)+')' :
					v₀.v='__do__s'? '{'+mrj(v[1:],';')+'}' :
					v₀.v='__get__'? '('+rj(v₁)+'['+rj(v₂)+'])' :
					v₀.v='__sub__'? '('+rj(v₁)+'['+rj(v₂)+'])' :
					v₀.v='__array__'? '['+mrj(v[1:],',')+']' :
					v₀.v='←'? 'var '+rj(v₁)+' = '+rj(v₂) :
					v₀.v='←!'? '('+rj(v₁)+' = '+rj(v₂)+')' :
					v₀.v='¬'? '(!'+rj(v₁)+')' :
					v₀.v='new'? 'new '+rj(v₁).replace(~/^\((.*)\)$/,'$1') :
					v₀.v='return'? 'return '+rj(v₁) :
					v₀.v='throw'? 'throw '+rj(v₁) :
					v₀.v='delete'? 'delete '+rj(v₁) :
					v₀.v='while'? 'while('+rj(v₁)+'){'+rj(v₂)+'}' :
					v₀.v='try'? 'try{'+rj(v₁)+'}catch(e){'+rj(v₂)+'}' :
					v₀.v='λ'? 'function λ('+mrj(v₁,',')+'){'+rj(v₂)+'}' :
					v₀.v='if'? '('+rj(v₁)+'?'+rj(v₂)+':'+rj(v₃)+')' :
					v₀.v='if_s'? 'if('+rj(v₁)+'){'+rj(v₂)+'}'+(v₃=undefined?'':'else{'+rj(v₃)+'}') :
					v₀.v='-' && v.length=2? '(-('+rj(v₁)+'))' :
					own(repr_js_trans_infix,v₀.v)? '('+rj(v₁)+repr_js_trans_infix[v₀.v]+rj(v₂)+')'  :
						'('+rj(v₀)+'('+mrj(v[1:],',')+'))' ) :
					rj(v₀)+'('+mrj(v[1:],',')+')' :
		typeof(v)='object'? '{'+Object.keys(v).map(λ(k){return rj(k)+':'+rj(vₖ)}).join(',')+'}' :
			'<what:'+v+'>'}
repr_js_file ← λ(form){return repr_js(form, [1])[1: -1].replace(~/ +/mg,' ').replace(~/^ /mg,'').replace(~/;$/m,'')}

string_reader ← λ(start,s,line){
	r ← ''
	while (true) {
		c ← s₀; s ←! slice_eof(s,1)
		if (c = start) return [r,s,line]
		if (c = '\\') {
			c ← s₀; s ←! slice_eof(s,1)
			if (c="'"||c='"'||c='\\') r += c
			else if (c='n') r += '\n'
			else if (c='t') r += '\t'
			else if (c='x') {r += chr(parseInt(s[:2],16)); s ←! slice_eof(s,2)}
			else if (c='u') {r += chr(parseInt(s[:4],16)); s ←! slice_eof(s,4)}
			else r += '\\'+c }
		else if (c = '\n') {line+=1; if (r ≠ '') r += '\n'}
		else r += c
	} }
	slice_eof ← λ(s,l){if (s.length < l) err('EOF while reading string'); return s[l:]}
regex_reader ← λ(start,s,line){
	t ← s.match(~/^((?:[^\/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*\/[a-z]*)/) || err('could not match regex: '+start+s[:10])
	return [eval('/'+t₁),s[t₁.length:],line]}

reader_or ← extend_function(λ{λ(start,s,line){
	return (λ[s₀]? λ[s₀](start+s₀,s[1:],line) : undefined) || (λ['']? λ[''](start,s,line) : undefined)}})
	reader_or.prototype.get ←! λ(s){return this[s₀]? (this[s₀] isa reader_or? this[s₀].get(s[1:]) : this[s₀]) : undefined}
	reader_or.prototype.set ←! λ(ss,r){
		seq(ss).map(λ(s){
			c ← s=''? '' : s₀; s ← s[1:]
			if (s ≠ '') (this[c] isa reader_or? this[c] : this[c] ←! new reader_or().set([''],own(this,c))).set([s],r)
			else delset(this,c,r)
		}.bind(this)); return this}
reader_macros ← new reader_or()
groups ← {}
anyfix_macros ← {}; anyfix_macros_set ← λ(ss,f){(ss isa Array? ss : [ss]).map(λ(s){symbol_set_decode(s).map(λ(s){
	v ← s.v; s ← s.space()
	if (f=undefined) {if (own(anyfix_macros,v)) {delete(anyfix_macros[v][s]); if (empty(Object.keys(anyfix_macros[v]))) delete(anyfix_macros[v])}}
	else {if (¬own(anyfix_macros,v)) {anyfix_macros[v] ←! {}} anyfix_macros[v][s] ←! f}
	}) }) }
lex ← λ(s){
	r ← [SP]
	t←undefined; if (t ←! s.match(~/^#!.*/)) {r.push(S('__literal__'),S('('),t₀,S(')')); s ←! s[t₀.length:]}
	r ← r.concat(lex_(s)); r.push(SP)
	i←1; while (i<r.length-1) {if (rᵢ isa Symbol) {
		if (r[i-1] ≠ SP) rᵢ.space_before ←! false
		if (r[i+1] ≠ SP) rᵢ.space_after ←! false } i+=1}
	r ← r.filter(λ{v ≠ SP})
	return r}
	lex_ ← λ(s){r ← []; line ← 1; while (s ≠ '') {t ← reader_macros('',s,line); r.push(t₀); s ←! t₁; line ←! t₂} return r}
group ← λ(g){
	group ← λ(g,l){
		e ← groups[g.v]
		r ← [g]; while (true) {
			if (empty(l)) err('unfinished group',g.line)
			if (se(l₀,e)) return [r,l[1:]]
			while (l₀ isa Symbol && own(groups,l₀.v)) {t ← group(l₀,l[1:]); r.push(t₀); l ←! t₁}
			if (se(l₀,e)) return [r,l[1:]]
			r.push(l₀); l ←! l[1:] } }
	r ← group(S('{'),g.concat([S('}')])); if (¬empty(r₁)) err(); return r₀}
anyfix_macro_eval ← λ(token){t ← anyfix_macro_eval_form([], [token]); if (t₁.length>0 || t₂.length>0) err(); return t₀}
anyfix_macro_eval_l ← λ(tokens){r ← []; while (tokens.length>0) {t ← anyfix_macro_eval_1(r,tokens); r ←! t₀; tokens ←! t₁} return r}
anyfix_macro_eval_form ← λ(buf,tokens,dont){while (¬(buf.length>1 || tokens.length=0 || (buf.length>0 && dont && dont(tokens)))) {t ← anyfix_macro_eval_1(buf,tokens); buf ←! t₀; tokens ←! t₁} return [buf₀,buf[1:],tokens]}
anyfix_macro_eval_1 ← λ(forms,tokens){
	v ← tokens₀; tokens ←! tokens[1:]
	if (v isa Array) {t ← ((anyfix_macros[v₀.v]||err(v₀))[v₀.space()]||err(v₀,v₀.space()))(forms,v₀, [v[1:]].concat(tokens)); forms ←! t₀; tokens ←! t₁}
	else if (v isa Symbol && own(anyfix_macros,v.v) && anyfix_macros[v.v][v.space()]) {t ← anyfix_macros[v.v][v.space()](forms,v,tokens); forms ←! t₀; tokens ←! t₁}
	else forms.push(v)
	return [forms,tokens]}

anyfix_macro_eval_p1 ← λ(forms,tokens){l ← forms.length; while (tokens.length>0 && forms.length < l+1) {t ← anyfix_macro_eval_1(forms,tokens); forms ←! t₀; tokens ←! t₁} return [forms,tokens]}

reader_macros.set([''], λ(_,s,l){
	is ← js_valid_symbol.is_part(s₀)
	r ← ''; while (s ≠ '' && ¬reader_macros.get(s) && js_valid_symbol.is_part(s₀) = is) {r += s₀; s ←! s[1:]}
	return [new Symbol(r,l),s,l]})
reader_macros.set([].concat(seq('()[]{}‹›.`~?:;,'), ['~@','¬in'],unicode.subscripts,unicode.subscripts.map(λ{'₋'+v})), λ{[new Symbol(v,c),b,c]})
reader_macros.set(' \t\x0c\x0d', λ{[SP,b,c]})
reader_macros.set('\n', λ{[SP,b,c+1]})
reader_macros.set(['//'], λ{[SP,b.replace(~/^.*/,''),c]})
reader_macros.set(['/*'], λ(_,s,l){t ← s.match(~/^[^]*?(\*\/|$)/)₀; return [SP,s[t.length:],l+(t.match(~/\n/g)||[]).length]})
reader_macros.set('\'"', string_reader)
reader_macros.set(['~/'], regex_reader)

; (['()','[]','{}','‹›']).map(λ{groups[v₀] ←! v₁})

; (λ(){
	vector ← λ(forms,sym,tokens){tokens₀ ←! anyfix_macro_eval_l(tokens₀); return [forms.concat([(has_sym(tokens₀,':')? [S('__sliceλ__')].concat(split_slice(tokens₀)) :
		[sym.with_v('__array__')].concat(tokens₀))]),tokens[1:]]}
	block ← λ(forms,sym,tokens){return [forms.concat([[S('__do__')].concat(tokens₀)]),tokens[1:]]}
anyfix_macros_set('[', vector)
anyfix_macros_set('−[', λ(forms,sym,tokens){return forms.length=0? vector([],sym,tokens) : [
	forms[: -1].concat(
		has_sym((tokens₀ ←! anyfix_macro_eval_l(tokens₀)),':')?
			[[S('__slice__'),forms₋₁].concat(split_slice(tokens₀))] :
			[[S('__sub__'),forms₋₁].concat(tokens₀)]
			),tokens[1:]]})
anyfix_macros_set('(',block)
anyfix_macros_set('−(', λ(forms,sym,tokens){return forms.length=0? block([],sym,tokens) : [forms[: -1].concat([[forms₋₁].concat(anyfix_macro_eval_l(tokens₀))]),tokens[1:]]})
})()
anyfix_macros_set('{', λ(forms,sym,tokens){
	r←undefined
	starts_like_dict ← λ{(v₀ isa Symbol || typeof(v₀)='string') && se(v₁,':')}
	if (starts_like_dict(tokens₀)) {
		r ←! {}; buf ← []; tokens_ ← tokens₀
		while (tokens_.length>0) {if (¬starts_like_dict(tokens_)) {err(tokens_)} t ← anyfix_macro_eval_form(buf,tokens_[2:],starts_like_dict); r[tokens_₀.v||tokens_₀] ←! t₀; buf ←! t₁; tokens_ ← t₂}
		r ←! [r].concat(buf)
		}
	else r ←! [[S('__do__s')].concat(anyfix_macro_eval_l(tokens₀))]
	return [forms.concat(r),tokens[1:]] })
anyfix_macros_set('‹', λ(forms,sym,tokens){err('‹› not implemented')})
anyfix_macros_set('.', λ(forms,sym,tokens){return [forms[: -1].concat([[sym,forms₋₁||err('bad .',forms₋₁,tokens),tokens₀]]),tokens[1:]]})
anyfix_macros_set([';',','], λ(forms,sym,tokens){return [forms,tokens]})
anyfix_macros_set(unicode.subscripts.concat(unicode.subscripts.map(λ{'₋'+v})),
	λ(forms,sym,tokens){return [forms[: -1].concat([[S('__sub__'),forms₋₁,sym.with_v(unicode.midscript(sym.v))]]),tokens]})
anyfix_macros_set('λ', λ(forms,sym,tokens){
	if (tokens₀ isa Array && tokens₀₀.v = '(') {
		p ← tokens₀[1:].filter(λ{¬se(v,',')}); tokens ← tokens[1:]
		// may disrespect precedence
		t ← anyfix_macro_eval_p1([],tokens); b ← t₀₀; tokens ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [forms.concat([[sym,p,b]]),tokens] }
	else if (tokens₀ isa Array && tokens₀₀.v = '{') {
		p ← [S('v'),S('b'),S('c')]
		// may disrespect precedence
		tokens₀₀.v ←! '(' //! gah
		t ← anyfix_macro_eval_p1([],tokens); b ← t₀₀; tokens ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [forms.concat([[sym,p, [S('return ')].concat([b])]]),tokens] }
	else return [forms.concat([sym]),tokens] })
anyfix_macros_gen ← λ(v,to){
	// this is horrifying and needs a good refactoring
	parse ← λ{v.match(~/(\[.*?\])|[^[\]]+/g).map(λ{v₀='['? [parse(v[1: -1])] : v.trim().split(' ')}).m_concat().filter(λ{v ≠ ''})}
	t ← parse(v); first ← t₀='…'; t ← first?t[1:]:t; n ← t₀; vs ← t[1:]
	anyfix_macros_set(n,λ(forms,sym,tokens){
		buf ← []
		r ← [to? sym.with_v(to) : sym]; if (first) r.push(forms₋₁≠undefined?forms₋₁:err())
		vs.forEach(λ(v,i){
			if (v='…') {
				dont ← vs[i+1] isa Array && vs[i+1]₀ ≠ '…'? vs[i+1]₀ : undefined
				t ← anyfix_macro_eval_form(buf,tokens,λ{se(v₀,dont)}); r.push(t₀); buf ←! t₁; tokens ←! t₂}
			else if (v isa Array) {
				tokens_ ← tokens
				buf_ ← buf
				r_ ← []
				vs_ ← v
				if (vs_.every(λ(v){
						if (v='…') {
							dont ← vs_[i+1] isa Array && vs_[i+1]₀ ≠ '…'? vs_[i+1]₀ : undefined
							t ← anyfix_macro_eval_form(buf_,tokens_,λ{se(v₀,dont)}); r_.push(t₀); buf_ ←! t₁; tokens_ ←! t₂}
						else {
							if (buf_.length=0 && se(tokens_₀,v))
								tokens_ ←! tokens_[1:]
							else return false
						}
						return true
					})) {
					tokens ←! tokens_
					r ←! r.concat(r_)
					buf ←! buf_
				}
			}
			else err('|'+v+'|')
		})
		return [(first?forms[: -1]:forms).concat([r],buf),tokens]
	}) }
anyfix_macros_gen('if … [:] … [else …]','if_s')
anyfix_macros_gen('… ? … [:] …','if')
anyfix_macros_gen('while … [:] …')
anyfix_macros_gen('return […]') // !!
anyfix_macros_gen('throw …')
anyfix_macros_gen('try … [catch …] [finally …]') // !!
anyfix_macros_gen('new …')
anyfix_macros_gen('¬− …')
anyfix_macros_gen('… isa …')
anyfix_macros_gen('… in …')
anyfix_macros_gen('… ¬in …')
anyfix_macros_gen('… * …')
anyfix_macros_gen('… / …')
anyfix_macros_gen('… % …') //-
anyfix_macros_gen('… + …')
anyfix_macros_gen('… - …')
anyfix_macros_gen('↔-− …') // !!
anyfix_macros_gen('… = …')
anyfix_macros_gen('… ≠ …')
anyfix_macros_gen('… < …')
anyfix_macros_gen('… > …')
anyfix_macros_gen('… ≤ …')
anyfix_macros_gen('… ≥ …')
anyfix_macros_gen('… & …'); anyfix_macros_gen('… && …') //-
anyfix_macros_gen('… | …'); anyfix_macros_gen('… || …') //-
anyfix_macros_gen('… ← …')
anyfix_macros_gen('… ←! …')
anyfix_macros_gen('… += …')

read ← λ(s){
	seq(s).map(λ{printableᵥ ←! true})
	// lex: characters are lexed into tokens with λ(rest_characters) → [token,rest_characters]
	// group: tokens are grouped into tokens so that this is higher-priority than any other anyfix macro
	// anyfix: tokens naming anyfix macros are expanded into forms with λ(previous_forms,symbol,rest_tokens) → [previous_forms,rest_tokens], but they are not allowed to eat more than the last form of previous_forms . these functions may be called multiple times, so they should be pure.

	// ?: forms naming macros are expanded into forms
	// ?: forms are translated into javascript
	r ← anyfix_macro_eval(group(lex(s)))
	pr(r)
	return r}

compile_f ← λ(_in,out){fs.writeFileSync(out,repr_js_file(read(fs.readFileSync(_in).toString())))}

compile_f(process.argv₂.replace('.a','.α'),process.argv₃)

// shuffle anyfix macros so that they actually have access to the entire previous part and just don't use it ?

// when we construct an object in the anyfix macros with Object.mapv, it throws away much information
// line [[S('__slice__'),v].concat(split_slice(tokens₀))] groups up the slice arguments way too much

//# we have left it unclear what exactly the goal is, and i believe we may be suffering from scope creep http://publications.gbdirect.co.uk/c_book/chapter7///how_the_preprocessor_works.html
//i want
//#require
//possibly a #use like thing but that probably should not be a primitive?

// oh dear. we may want standard macros to get their arguments with partial but incomplete anyfix parsing.

//{expr,} is a void block, and {expr} is not a void block
// ,, ought to mean ,undefined, or somesuch
// return, ought to return undefined

// output js "return(v)" not "return v"

// try compiling an empty file

// todo: [for] generator expression, non-lazy
// todo: (for) generator expression, lazy
// todo: {for} generator expression, set
// todo: {: for} generator expression, object
// todo?: v{} call
// todo: either (replace Ca with [] and [] with [__array__]) or (replace Ca with ())

// todo: r ← [1 2 3]; r[1:2] ←! [5 5]; r = [1 5 5 3]
// todo: more meanings of ?

// later
// ` ~ ~@
//	tight					…++	…--
//	prefix					+…	bit~…
//	bitwise					bit|	bit^	bit&	bit>>>	bit>>	bit<<
//	assignment				+=	-=	*=	/=	&=	|=	bit<<=	bit>>=	bit>>>=	bit&=	bit^=	bit|=
//	statement				delete …	yield …

// derp, if ~/ is regex ~" should be too

// ¬in has to be a reader macro too ...

// fix the "at ╬╗ (c:\User" shit
