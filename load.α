#!/usr/bin/env node
//"use strict"
//repl ← require('repl')
fs ← require('fs')
_ ← require('../lib/underscore-min')
//module.exports.hex ←! hex

__sub__ ← λ{v[b]}
__slice__ ← λ(a,b){return b=undefined? v.slice(a) : (v.slice(a,b))}
__sliceλ__ ← λ(a,b){return b=undefined? λ{v[a:]} : λ{v[a:b]}}

//===--------------------------------------------===// utils //===--------------------------------------------===//

print ← console.log.bind(console)
memoize_o ← λ(o,f){return λ(v){r ← own(o,v); return r = undefined? (oᵥ ←! f(v)) : r}}
//merge_o ← λ(a,b){for (k in b) aₖ ←! bₖ; return a}
merge_o ← λ(a,b){r ← {}; Object.keys(a).forEach(λ(k){rₖ ←! aₖ}); Object.keys(b).forEach(λ(k){rₖ ←! bₖ}); return r}
Object.map ←!  λ(v,f){f ← f || λ{[v,b]};    r ← {}; Object.keys(v).forEach(λ(k){t ← f.call(v, k, vₖ);	if (t) r[t₀] ←! t₁}); return r}
Object.mapv ←! λ(v,f){f ← f || λ{[v,true]}; r ← {};              v.forEach(λ(v){t ← f(v);           	if (t) r[t₀] ←! t₁}); return r}
dict_by ← λ(v,f){return Object.mapv(v,λ{[f(v),v]})}
frequencies ← λ(v){r ← {}; v.forEach(λ{rᵥ ←! v in r? rᵥ+1 : 1}); return r}
now ← λ{Date.now() / 1000}
run ← {
	in:   λ(s,f){return {id:setTimeout( f,s*1000), cancel:λ{cancelTimeout( this.id)}}},
	every:λ(s,f){return {id:setInterval(f,s*1000), cancel:λ{cancelInterval(this.id)}}},
	tomorrow:λ(f){
		start ← new Date()
		cancel ← false
		r ← run.in(new Date(start).setHours(24,0,0,0)/1000 - start/1000,
			λ(){if (new Date().getDate() = start.getDate()) run.in(1,λ); else {if (¬cancel) f()}})
		return {cancel:λ(){cancel ←! true; r.cancel()}}}
	}
ord ← λ{v.charCodeAt(0)}
chr ← λ{String.fromCharCode(v)}
seq ← λ{typeof v = 'string'? v.split('') : v instanceof Array? v : Object.keys(v).map(λ(k){return [k,vₖ]})}
extend_function ← λ(f){r ← λ(){r ← f(); r.__proto__ ←! λ.prototype; return r}; r.prototype.__proto__ ←! Function.prototype; return r}
own ← λ(o,m){if (Object.prototype.hasOwnProperty.call(o,m)) return oₘ}
delset ← λ(o,m,v){if (v = undefined) delete oₘ; else oₘ ←! v}
String.prototype.repeat ←! λ{new Array(v+1).join(this)}
//Array.prototype.interpose ←! λ(sep){return this.map(λ{v.concat(sep)}).m_concat()[:-1]}
windows ← λ(n,l){r ← []; while (l.length ≥ n) {r.push(l[:n]); l ←! l[1:]} return r}
err ← λ(v){throw Error(v)}
Array.prototype.m_concat ←! λ{Array.prototype.concat.apply([],this)}
pad_left ← λ(v,s,l){while (v.length < l) v ←! s + v; return v}
hex ← λ(v,l){return pad_left(v.toString(16),'0',l)}
Date.prototype.hours = λ(v){this.setHours(this.getHours()+v); return this}
Date.prototype.yyyy_mm_dd = λ(){m ← (this.getMonth()+1)+''; d ← this.getDate()+''; return this.getFullYear()+'-'+(m₁?m:'0'+m)+'-'+(d₁?d:'0'+d)}
guid ← λ{'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, λ(v){r ← Math.random()*16|0; return (v='x' ? r : (r&0x3|0x8)).toString(16)})}

//===--------------------------------------------===// characters //===--------------------------------------------===//

js_valid_symbol ← new (λ(){
	_short ← {' ':'_', '!':'1', '#':'3', '%':'5', '&':'7', '(':'9', ')':'0', '*':'8', '+':'p', ',':'C', '-':'m', '.':'d', '/':'s', ':':'c', '=':'E', '?':'q', '@':'2', '[':'L', '\\':'b', '^':'6', '`':'k', '{':'B', '|':'o', '~':'t', '…':'r', '←':'w', '→':'e', '¬':'n', '∀':'A', '≠':'N', 'ǂ':'ǂ', '<':'lt', '≤':'le', '>':'gt', '≥':'ge'}
	encode_short ← Object.map(_short,λ{[v,'ǂ'+b]})
	decode_short ← Object.map(_short,λ{[b,v]})
	is_start ← memoize_o(Object.mapv(seq(';ǂ \t\n\x0b\x0c\x0d'),λ{[v,false]}),λ(v){try {eval('var '+v )} catch (e) {return false} return true})
	is_part  ← memoize_o(Object.mapv(seq(';ǂ \t\n\x0b\x0c\x0d'),λ{[v,false]}),λ(v){try {eval('var a'+v)} catch (e) {return false} return true})
	encode_char ← memoize_o(encode_short, λ(v){return is_part(v)? v : 'ǂu'+hex(ord(v),4)})

	keywords ← ['break','do','instanceof','typeof','case','else','new','var','catch','finally','return','void','continue','for','switch','while','debugger','function','this','with','default','if','throw','delete','in','try','class','enum','extends','super','const','export','import','implements','let','private','public','yield','interface','package','protected','static']
	encode_keywords ← merge_o(Object.mapv(keywords,λ{[v,'_'+v]}), Object.mapv(keywords,λ{['_'+v,'ǂ_'+v]}))
	decode_keywords ← Object.map(encode_keywords,λ{[b,v]})

	this.is_part ←! is_part
	this.encode ←! memoize_o(encode_keywords,λ(v){r ← seq(v).map(encode_char).join(''); return is_start(r₀)? r : 'ǂ'+r})
	this.decode ←! memoize_o(decode_keywords,λ(v){
		v ← v₀='ǂ'? v[1:] : v
		r ← ''; i←null; while ((i←!v.indexOf('ǂ')) ≠ -1) {
			r += v[0:i]; v ←! v[i+1:]
			if (v₀='u') {r += chr(parseInt(v[1:5],16)); v ←! v[5:]}
			else if (v₀='l' || v₀='g') {r += decode_short[v[:2]]; v ←! v[2:]}
			else {r += decode_short[v₀]; v ←! v[1:]}
			} return r+v})
	})
unicode ← λ(table){
	subscripts:   table.map(λ{v₀}).filter(λ{v≠'-'}),
	midscripts:   table.map(λ{v₁}).filter(λ{v≠'-'}),
	superscripts: table.map(λ{v₂}).filter(λ{v≠'-'}),
	subscript:   λ(f){return λ{seq(v).map(λ{f[v]}).join('')}}(Object.mapv(table.map(λ{[[v₁,v₀],[v₂,v₀]]}).m_concat(),λ{v})),
	midscript:   λ(f){return λ{seq(v).map(λ{f[v]}).join('')}}(Object.mapv(table.map(λ{[[v₀,v₁],[v₂,v₁]]}).m_concat(),λ{v})),
	superscript: λ(f){return λ{seq(v).map(λ{f[v]}).join('')}}(Object.mapv(table.map(λ{[[v₀,v₂],[v₁,v₂]]}).m_concat(),λ{v}))
	}('₀0⁰ ₁1¹ ₂2² ₃3³ ₄4⁴ ₅5⁵ ₆6⁶ ₇7⁷ ₈8⁸ ₉9⁹ ₊+⁺ ₋-⁻ ₌=⁼ ₍(⁽ ₎)⁾ ₐaᵃ -bᵇ -cᶜ -dᵈ ₑeᵉ -fᶠ -gᵍ ₕhʰ ᵢiⁱ ⱼjʲ ₖkᵏ ₗlˡ ₘmᵐ ₙnⁿ ₒoᵒ ₚpᵖ ᵣrʳ ₛsˢ ₜtᵗ ᵤuᵘ ᵥvᵛ -wʷ ₓxˣ -yʸ -zᶻ -Aᴬ -Bᴮ -Dᴰ -Eᴱ -Gᴳ -Hᴴ -Iᴵ -Jᴶ -Kᴷ -Lᴸ -Mᴹ -Nᴺ -Oᴼ -Pᴾ -Rᴿ -Tᵀ -Uᵁ -Vⱽ -Wᵂ'.split(' '))

//===--------------------------------------------===// <edge> //===--------------------------------------------===//

Symbol ← λ(v,line){this.v ←! v; if (line) this.line ←! line}
	Symbol.prototype.space ←! λ{(this.space_before?'_':'')+'$'+(this.space_after?'_':'')}
	Symbol.prototype.space_before ←! true
	Symbol.prototype.space_after ←! true
	Symbol.prototype.inspect ←! λ{'`'+this.v}
	Symbol.prototype.with_v ←! λ(v){r ← new Symbol(v,this.line); if (¬this.space_before) r.space_before = false; if (¬this.space_after) r.space_after = false; return r}
	S ← λ(v){r ← new Symbol(v.replace(~/^ /,'').replace(~/ $/,'')); if (v₀≠' ') r.space_before ←! false; if (v₋₁≠' ') r.space_after ←! false; return r}
SP ← {}

// hacks
js_valid_symbol_encode ← λ{own({'=':'===','←!':'=','←':'=','≠':'!==','≤':'<=','≥':'>=','¬':'!','₋₁':'.slice(-1)[0]','₀':'[0]','₁':'[1]','₂':'[2]','₃':'[3]','ᵥ':'[v]','ᵢ':'[i]','ₖ':'[k]','ₘ':'[m]','isa':'instanceof'},v) || (own(Object.mapv('< > , . : ; + - * / || && ? += ++ if else for return in new typeof delete try catch while this switch case throw break continue'.split(' ')),v)?v:null) || (v.match(~/^\d/)?v:null) || js_valid_symbol.encode(v)}
split_symbol ← λ(l,s){r ← [[]]; l.map(λ(v){if (v isa Symbol && v.v = s) r.push([]); else r₋₁.push(v)}); return r}
has_sym ← λ(v,s){return v.some(λ{v isa Symbol && v.v=s})}
split_slice ← λ(l){r ← split_symbol(l,':'); r ← [(r₀.length = 0? [S('0')] : r₀)].concat(r[1:]); return r₁.length = 0? r[:1] : r}
ran_as ← process.argv₁.match(~/[^\\]*\\[^\\]*$/)₀
pr ← λ(){if (ran_as = 'bin\\load.js') print.apply(this,['##'].concat(Array.prototype.slice.apply(arguments))); return arguments₀}
Array.prototype.map2 ←! λ(f){r ← []; if (this.length=0) return r; i←0; while (i<this.length-1) {r.push(f(thisᵢ,this[i+1])); i++} r.push(f(this₋₁,null)); return r}

printable ← λ{(0x20≤ord(v) && ord(v)<0x7f) || js_valid_symbol.is_part(v)}

repr_js ← λ(v){return v}
repr_js_lexed ← λ(v,line,next){mrj ← λ{v.map2(λ{repr_js_lexed(v,line,b)}).join('')}
	return v isa Symbol? (v.line && line? '\n'.repeat(λ(v){line₀ += v; return v}(Math.max(0, v.line-line₀))) : '') +
		(v.space_before?' ':'') +
		(next isa Symbol && next.v='←'? 'var ' : '') +
		(	(v.v='λ' && (next isa Array && next₀.v='('))? 'function λ' :
			(v.v='λ' && (next isa Array && next₀.v='{'))? λ(r){next.splice(1,0,S('return ')); return r}('function λ'+'(v,b,c)') :
				js_valid_symbol_encode(v.v)
				) +
		(v.space_after && ¬(next isa Symbol && next.space_before)?' ':'') :
	v isa Array?
		v₀.v='[' && ¬v₀.space_before && has_sym(v,':')?
			'.slice('+split_slice(v[1:]).map(mrj).join(',')+')' :
			v₀.v + mrj(v[1:]) + groups[v₀.v] :
	typeof v = 'string'? (v.match(~/'/g)||[]).length ≤ (v.match(~/"/g)||[]).length?
		"'"+seq(v).map(λ{{"'":"\\'",'\n':'\\n','\t':'\\t','\\':'\\\\'}ᵥ || (printable(v)? v : '\\u'+hex(ord(v),4))}).join('')+"'" :
		'"'+seq(v).map(λ{{'"':'\\"','\n':'\\n','\t':'\\t','\\':'\\\\'}ᵥ || (printable(v)? v : '\\u'+hex(ord(v),4))}).join('')+'"' :
	v isa RegExp? v+'' :
		'<what:'+v+'>'}
repr_js_lexed_file ← λ(forms){mrj ← λ{v.map2(λ{repr_js_lexed(v,line,b)}).join('')}
	line ← [1]
	return '#!/usr/bin/env node\n'+mrj(forms).replace(~/^ /mg,'').replace(~/^(.*)\n/,'//$1')
	}

string_reader ← λ(start,s,line){
	r ← ''
	while (true) {
		c ← s₀; s ←! slice_eof(s,1)
		if (c = start) return [r,s,line]
		if (c = '\\') {
			c ← s₀; s ←! slice_eof(s,1)
			if (c="'"||c='"'||c='\\') r += c
			else if (c='n') r += '\n'
			else if (c='t') r += '\t'
			else if (c='x') {r += chr(parseInt(s[:2],16)); s ←! slice_eof(s,2)}
			else if (c='u') {r += chr(parseInt(s[:4],16)); s ←! slice_eof(s,4)}
			else r += '\\'+c }
		else if (c = '\n') {line++; if (r ≠ '') r += '\n'}
		else r += c
	} }
	slice_eof ← λ(s,l){if (s.length < l) err('EOF while reading string'); return s[l:]}
regex_reader ← λ(start,s,line){
	t ← s.match(~/^((?:[^\/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*\/[a-z]*)/) || err('could not match regex: '+start+s[:10])
	return [eval('/'+t₁),s[t₁.length:],line]}

reader_or ← extend_function(λ{λ(start,s,line){
	return (λ[s₀]? λ[s₀](start+s₀,s[1:],line) : null) || (λ['']? λ[''](start,s,line) : null)}})
	reader_or.prototype.get ←! λ(s){return this[s₀]? (this[s₀] isa reader_or? this[s₀].get(s[1:]) : this[s₀]) : null}
	reader_or.prototype.set ←! λ(ss,r){
		seq(ss).map(λ(s){
			c ← s=''? '' : s₀; s ← s[1:]
			if (s ≠ '') (this[c] isa reader_or? this[c] : this[c] ←! new reader_or().set([''],own(this,c))).set([s],r)
			else delset(this,c,r)
		}.bind(this)); return this}
reader_macros ← new reader_or()
groups ← {}
anyfix_macros ← {}; anyfix_macros_set ← λ(ss,f){ss.map(λ(s){
	if      (typeof s = 'string' && f = undefined) delete anyfix_macros[s]
	else if (typeof s = 'string' && f ≠ undefined) anyfix_macros[s] ←! {'_$_':f,'$_':f,'_$':f,'$':f}
	else if (typeof s ≠ 'string' && f = undefined) delete anyfix_macros[s.v][s.space()]
	else if (typeof s ≠ 'string' && f ≠ undefined) {if (¬own(anyfix_macros,s.v)) anyfix_macros[s.v] ←! {}; anyfix_macros[s.v][s.space()] ←! f}
	})}
lex ← λ(s){r ← []; line ← 1; while (s ≠ '') {form ← reader_macros('',s,line); r.push(form₀); s ←! form₁; line ←! form₂} return r}
group ← λ(g,l){
	if (l = undefined) {r ← group(S('{'),g.concat([S('}')])); if (r₁.length > 0) err(); return r₀[1:]}
	else {
		e ← groups[g.v]
		r ← [g]; while (true) {
			if (l.length = 0) err('unfinished group'+repr_js_lexed(r))
			if (l₀ isa Symbol && l₀.v = e) return [r,l[1:]]
			while (l₀ isa Symbol && own(groups,l₀.v)) {t ← group(l₀,l[1:]); r.push(t₀); l ←! t₁}
			if (l₀ isa Symbol && l₀.v = e) return [r,l[1:]]
			r.push(l₀); l ←! l[1:] }
	} }
anyfix_macro_eval ← λ(forms){r ← []; while (forms.length > 0) {t ← anyfix_macro_eval_1(r,forms); r ←! t₀; forms ←! t₁} return r}
anyfix_macro_eval_n ← λ(n,forms){r ← []; while (forms.length > 0 && r.length < n) {t ← anyfix_macro_eval_1(r,forms); r ←! t₀; forms ←! t₁} return [r,forms]}
anyfix_macro_eval_1 ← λ(r,forms){
	l ← r.length
	while (forms.length > 0 && r.length < l+1) {
		v ← forms₀; forms ←! forms[1:]
		//[r[:-1] forms] ← 
		if (v isa Array) {
			t ← anyfix_macros[v₀.v][v₀.space()](r₋₁,v₀,[anyfix_macro_eval(v[1:])].concat(forms))
			r ←! r[:-1].concat(t₀); forms ←! t₁ }
		else if (v isa Symbol && own(anyfix_macros,v.v)) {
			t ← anyfix_macros[v.v][v.space()](r₋₁,v,forms)
			r ←! r[:-1].concat(t₀); forms ←! t₁ }
		else r.push(v)
	} return [r,forms]}

reader_macros.set([''], λ(_,s,l){
	is ← js_valid_symbol.is_part(s₀)
	r ← ''; while (s ≠ '' && ¬reader_macros.get(s) && js_valid_symbol.is_part(s₀) = is) {r += s₀; s ←! s[1:]}
	return [new Symbol(r,l),s,l]})
reader_macros.set([].concat(seq('()[]{}‹›.`~?:;,'),['~@'],unicode.subscripts,unicode.subscripts.map(λ{'₋'+v})), λ{[new Symbol(v,c),b,c]})
reader_macros.set(' \t\x0c\x0d', λ{[SP,b,c]})
reader_macros.set('\n', λ{[SP,b,c+1]})
reader_macros.set(['//'], λ{[SP,b.replace(~/^.*/,''),c]})
reader_macros.set(['/*'], λ(_,s,l){t ← s.match(~/^[^]*?\*\//)₀; return [SP,s[t.length:],l+t.match(~/\n/g).length]})
reader_macros.set('\'"', string_reader)
reader_macros.set(['~/'], regex_reader)

;['()','[]','{}','‹›'].map(λ{groups[v₀] ←! v₁})

// token macros

;(λ(){
	vector ← λ(v,sym,rest){return [(v=undefined?[]:[v]).concat([(has_sym(rest₀,':')? [S('__sliceλ__')].concat(split_slice(rest₀)) :
		[sym.with_v('__array__')].concat(rest₀))]),rest[1:]]}
	block ← λ(v,sym,rest){return [(v=undefined?[]:[v]).concat([[S('__do__')].concat(rest₀)]),rest[1:]]}
anyfix_macros_set(['['], vector)
anyfix_macros_set([S('['),S('[ ')], λ(v,sym,rest){return v=undefined? vector(v,sym,rest) : [
	(has_sym(rest₀,':')?
		[[S('__slice__'),v].concat(split_slice(rest₀))] :
		[[S('__sub__'),v].concat(rest₀)]
		),rest[1:]]})
anyfix_macros_set(['('],block)
anyfix_macros_set([S('('),S('( ')], λ(v,sym,rest){return v=undefined? block(v,sym,rest) : [[[v].concat(rest₀)],rest[1:]]})
})()
anyfix_macros_set(['{'], λ(v,sym,rest){
	return [(v=undefined?[]:[v]).concat([(has_sym(rest₀,':')?
		Object.mapv(windows(2,split_symbol(rest₀,':')),λ{[v₀₋₁.v,v₁₀]}) :
		[S('__do__')].concat(rest₀))]),rest[1:]] })
anyfix_macros_set(['‹'], λ(v,sym,rest){err('‹› not implemented')})
anyfix_macros_set(['.'], λ(v,sym,rest){return [[[sym,v||(pr(v,rest), err('bad .')),rest₀]],rest[1:]]})
anyfix_macros_set([';',','], λ(v,sym,rest){t ← anyfix_macro_eval_1([],rest); return [[v].concat(t₀),t₁]})
anyfix_macros_set(unicode.subscripts.concat(unicode.subscripts.map(λ{'₋'+v})),
	λ(v,sym,rest){return [[[S('__sub__'),v,sym.with_v(unicode.midscript(sym.v))]],rest]})
anyfix_macros_set(['?'], λ(v,sym,rest){
	t ← anyfix_macro_eval_n(2,rest); ac ← t₀; rest ← t₁
	if (¬(ac.length = 2 && ac₁ isa Symbol && ac₁.v = ':')) {pr(ac); err('bad ?:')}
	// may disrespect precedence
	t ← anyfix_macro_eval_n(2,rest); b ← t₀₀; rest ← t₀[1:].concat(t₁)
	return [[[sym.with_v('__if__'),v,ac₀,b]],rest]})
anyfix_macros_set(['λ'], λ(v,sym,rest){
	if (rest₀ isa Array && rest₀₀.v = '(') {
		p ← rest₀[1:].filter(λ{¬(v isa Symbol && v.v = ',')}); rest ← rest[1:]
		// may disrespect precedence
		pr(rest)
		t ← anyfix_macro_eval_1([],rest); b ← t₀₀; rest ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [[[sym,p,b]],rest] }
	else if (rest₀ isa Array && rest₀₀.v = '{') {
		p ← [S('v'),S('b'),S('c')]
		// may disrespect precedence
		t ← anyfix_macro_eval_1([],rest); b ← t₀₀; rest ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [[[sym,p,b]],rest] }
	else return [[v,sym],rest] })
/*anyfix_macros_set(['if'], λ(v,sym,rest){
	t ← anyfix_macro_eval_expr(rest); q ← t₀; rest ← t₁
	t ← anyfix_macro_eval_expr(rest); q ← t₀; rest ← t₁
	if expr [:] expr [else] expr
})*/
anyfix_macros_gen ← λ(v){
	parse ← λ{v.match(~/(\[.*?\])|[^[\]]+/g).map(λ{v₀='['? [parse(v[1:-1])] : v.trim().split(' ')}).m_concat()}
	[ '…', [ ':' ], '…', [ 'else', '…' ] ]
	t ← parse(v); n ← t₀; v ← t[1:]
	anyfix_macros_set([n],λ(form,sym,rest){
		r ← []
		v.forEach(λ(v){
			if (v='…') {t ← anyfix_macro_eval_expr(rest); return [(form=undefined?[]:[form]).concat([t₀]), rest]}
			else if (v instanceof Array) {
				
			}
			else
		})
	})
}
anyfix_macros_gen('if … [:] … [else …]')
//anyfix_macros_set(['while'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['return'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['throw'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['try'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['new'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['¬'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['typeof'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['*'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['/'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['+'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['-'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['isa'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['in'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['¬in'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['='], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['≠'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['<'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['>'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['≤'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['≥'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['&','&&'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['|','||'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['←'], λ(v,sym,rest){err('not yet defined')})
//anyfix_macros_set(['←!'], λ(v,sym,rest){err('not yet defined')})


// __do__

read ← λ(s){
	r ← [SP];
	t←null; if (t ←! s.match(~/^#!.*/)) {r.push(S('__literal__'),S('('),t₀,S(')')); s ←! s[t₀.length:]}
	r ← r.concat(lex(s)); r.push(SP)
	i←1; while (i<r.length-1) {if (rᵢ isa Symbol) {
		if (r[i-1] ≠ SP) rᵢ.space_before ←! false
		if (r[i+1] ≠ SP) rᵢ.space_after ←! false } i++}
	r ← r.filter(λ{v ≠ SP})
	r ← group(r)
	pr(repr_js(anyfix_macro_eval(r)))
	return r}

compile_f ← λ(_in,out){fs.writeFileSync(out,repr_js_lexed_file(read(fs.readFileSync(_in).toString())))}

compile_f(process.argv₂.replace('.a','.α'),process.argv₃)

print('--- ran as:',ran_as,'---')

// shuffle anyfix macros so that they actually have access to the entire previous part and just don't use it ?

// when we construct an object in the anyfix macros with Object.mapv, it throws away much information
// line [[S('__slice__'),v].concat(split_slice(rest₀))] groups up the slice arguments way too much

//# we have left it unclear what exactly the goal is, and i believe we may be suffering from scope creep http://publications.gbdirect.co.uk/c_book/chapter7///how_the_preprocessor_works.html
//i want
//#require
//possibly a #use like thing but that probably should not be a primitive?

// oh dear. we may want standard macros to get their arguments with partial but incomplete anyfix parsing.

//{expr,} is a void block, and {expr} is not a void block

// output js "return(v)" not "return v"

// try compiling an empty file

// todo: [for] generator expression, non-lazy
// todo: (for) generator expression, lazy
// todo: {for} generator expression, set
// todo: {: for} generator expression, object
// todo?: v{} call
// todo: either (replace Ca with [] and [] with [__array__]) or (replace Ca with ())

// todo: r ← [1 2 3]; r[1:2] ←! [5 5]; r = [1 5 5 3]
// todo: more meanings of ?

// later
// ` ~ ~@
//	tight					…++	…--
//	prefix					+…	bit~…
//	bitwise					bit|	bit^	bit&	bit>>>	bit>>	bit<<
//	assignment				+=	-=	*=	/=	&=	|=	bit<<=	bit>>=	bit>>>=	bit&=	bit^=	bit|=
//	statement				delete …	yield …

// derp, if ~/ is regex ~" should be too