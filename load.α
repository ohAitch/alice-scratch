#!/usr/bin/env node
//"use strict"

//repl ← require('repl')
fs ← require('fs')
_ ← require('../lib/underscore-min')

//module.exports.hex ←! hex

argv ← process.argv[2:]
argv₀ ←! argv₀.replace('.a','.α')

print ← console.log.bind(console)
memoize_o ← λ(o,f){return λ{v in o? oᵥ : (oᵥ ←! f(v))}}
merge_o ← λ(a,b){for (k in b) aₖ ←! bₖ; return a}
Object.map ←!  λ(v,f){f ←! f || λ{[v,b]};    r ← {}; Object.keys(v).forEach(λ(k){t ← f.call(v, k, vₖ);	if (t) r[t₀] ←! t₁}); return r}
Object.mapv ←! λ(v,f){f ←! f || λ{[v,true]}; r ← {};              v.forEach(λ(v){t ← f(v);          	if (t) r[t₀] ←! t₁}); return r}
now ← λ{Date.now() / 1000}
run ← {
	in:   λ(s,f){return {id:setTimeout( f,s*1000), cancel:λ{cancelTimeout( this.id)}}},
	every:λ(s,f){return {id:setInterval(f,s*1000), cancel:λ{cancelInterval(this.id)}}},
	tomorrow:λ(f){
		start ← new Date()
		cancel ← false
		r ← run.in(new Date(start).setHours(24,0,0,0)/1000 - start/1000,
			λ(){if (new Date().getDate() = start.getDate()) run.in(1,λ); else {if (¬cancel) f()}})
		return {cancel:λ(){cancel ←! true; r.cancel()}}}
	}
ord ← λ{v.charCodeAt(0)}
chr ← λ{String.fromCharCode(v)}
seq ← λ{typeof v = 'string'? v.split('') : v}
extend_function ← λ(f){r ← λ(){r ← f(); r.__proto__ ←! λ.prototype; return r}; r.prototype.__proto__ ←! Function.prototype; return r}
own ← λ(o,m){if (o.hasOwnProperty(m)) return oₘ}
delset ← λ(o,m,v){if (v = undefined) delete oₘ; else oₘ ←! v}
String.prototype.repeat ←! λ{new Array(v+1).join(this)}

pad_left ← λ(v,s,l){while (v.length < l) v ←! s + v; return v}
hex ← λ(v,l){return pad_left(v.toString(16),'0',l)}
js_valid_symbol ← new (λ(){
	_short ← {' ':'_', '!':'1', '#':'3', '%':'5', '&':'7', '(':'9', ')':'0', '*':'8', '+':'p', ',':'C', '-':'m', '.':'d', '/':'s', ':':'c', '=':'E', '?':'q', '@':'2', '[':'L', '\\':'b', '^':'6', '`':'k', '{':'B', '|':'o', '~':'t', '…':'r', '←':'w', '→':'e', '¬':'n', '∀':'A', '≠':'N', 'ǂ':'ǂ', '<':'lt', '≤':'le', '>':'gt', '≥':'ge'}
	encode_short ← Object.map(_short,λ{[v,'ǂ'+b]})
	decode_short ← Object.map(_short,λ{[b,v]})
	is_start ← memoize_o({';':false,' ':false,'ǂ':false},λ(v){try {eval('var '+v )} catch (e) {return false} return true})
	is_part  ← memoize_o({';':false,' ':false,'ǂ':false},λ(v){try {eval('var a'+v)} catch (e) {return false} return true})
	encode_char ← memoize_o(encode_short, λ(v){return is_part(v)? v : 'ǂu'+hex(ord(v),4)})

	keywords ← ['break','do','instanceof','typeof','case','else','new','var','catch','finally','return','void','continue','for','switch','while','debugger','function','this','with','default','if','throw','delete','in','try','class','enum','extends','super','const','export','import','implements','let','private','public','yield','interface','package','protected','static']
	encode_keywords ← merge_o(Object.mapv(keywords,λ{[v,'_'+v]}), Object.mapv(keywords,λ{['_'+v,'ǂ_'+v]}))
	decode_keywords ← Object.map(encode_keywords,λ{[b,v]})

	this.is_part ←! is_part
	this.encode ←! memoize_o(encode_keywords,λ(v){r ← seq(v).map(encode_char).join(''); return is_start(r₀)? r : 'ǂ'+r})
	this.decode ←! memoize_o(decode_keywords,λ(v){
		v ← v₀ = 'ǂ'? v[1:] : v
		r ← ''; var i; while ((i←!v.indexOf('ǂ')) ≠ -1) {
			r += v[0:i]; v ←! v[i+1:]
			if (v₀ = 'u') {r += chr(parseInt(v[1:5],16)); v ←! v[5:]}
			else if (v₀ = 'l' || v₀ = 'g') {r += decode_short[v[:2]]; v ←! v[2:]}
			else {r += decode_short[v₀]; v ←! v[1:]}
			} return r+v})
	})

Symbol ← λ(v,line){this.v ←! v; if (line) this.line ←! line}
S ← λ(v,line){return new Symbol(v,line)}

printable ← λ{(0x20≤ord(v) && ord(v)<0x7f) || js_valid_symbol.is_part(v)}
repr_js ← λ(v,line){return\
	typeof v = 'string'? (v.match(/'/g)||[]).length ≤ (v.match(/"/g)||[]).length?
		"'"+seq(v).map(λ{{"'":"\\'",'\n':'\\n','\t':'\\t','\\':'\\\\'}ᵥ || (printable(v)? v : '\\u'+hex(ord(v),4))}).join('')+"'" :
		'"'+seq(v).map(λ{{'"':'\\"','\n':'\\n','\t':'\\t','\\':'\\\\'}ᵥ || (printable(v)? v : '\\u'+hex(ord(v),4))}).join('')+'"' :
	//v instanceof Array?
	v instanceof Symbol? v.line? '\n'.repeat(λ(v){line₀ += v; return v}(Math.max(0, v.line-line₀))) + v.v : v.v :
		'<what>'}
repr_js_file ← λ(forms){
	line ← [1]
	return '#!/usr/bin/env node\n'+forms.map(λ{repr_js(v,line)}).join(',').split('\n').map(λ{'console.log('+repr_js(v)+')'}).join('\n')
}

reader_or ← extend_function(λ{λ(start,s,line){return (λ[s₀]? λ[s₀](start+s₀,s[1:],line) : null) || (λ['']? λ[''](start,s,line) : null)}})
	reader_or.prototype.get ←! λ(s){return this[s₀]? (this[s₀] instanceof reader_or? this[s₀].get(s[1:]) : this[s₀]) : null}
	reader_or.prototype.set ←! λ(ss,r){
		seq(ss).map(λ(s){
			c ← s = ''? '' : s₀; s ← s[1:]
			if (s ≠ '') (this[c] instanceof reader_or? this[c] : this[c] ←! new reader_or().set([''],own(this,c))).set([s],r)
			else delset(this,c,r)
		}.bind(this)); return this}

string_reader ← λ(start,s,line){
	r ← ''
	var indent
	for (;;) {
		c ← s₀; s ←! slice_eof(s,1)
		if (c = start) return [r,s,line]
		if (c = '\\') {
			c ←! s₀; s ←! slice_eof(s,1)
			switch (c) {
				case "'": case '"': case '\\': break
				case 'n': c ←! '\n'; break
				case 't': c ←! '\t'; break
				case 'x': c ←! chr(parseInt(s[:2],16)); s ←! slice_eof(s,2); break
				case 'u': c ←! chr(parseInt(s[:4],16)); s ←! slice_eof(s,4); break
				default: c ←! '\\'+c; break
			}
		} else if (c = '\n') {
			if (r = '') c ←! ''
			line++
			s ←! slice_eof(s,indent ←! indent || s.match(/^[ \t]*/)₀.length)}
		r += c
	} }
	slice_eof ← λ(s,l) {if (s.length < l) throw 'EOF while reading string'; return s[l:]}

readers ← new reader_or()

readers.set('\'"', string_reader)
//readers.set(['~/'], regex_reader)
readers.set(['//'], λ{['',b.replace(/^[^\n]+/,''),c+1]})
readers.set(' \t\x0c\x0d', λ{['',b,c]})
readers.set('\n', λ{['',b,c+1]})

readers.set(seq('()[]{}‹›.`~,:;').concat(['~@']), λ{[S(v,c),b,c]})
readers.set(_.range(0,0x80).map(chr).filter(λ{v.match(/[a-zA-Z0-9_$%]/)}), λ(c,s,l){r ← s.match(/^[a-zA-Z0-9_$%]*/)₀; return [S(c+r,l),s[r.length:],l]})
readers.set([''], λ(c,s,l){r ← c; while (¬readers.get(s)) {r += s₀; s ←! s[1:]} return [S(r,l),s,l]})

read ← λ(s){r ← []; line ← 1
	t ← s.match(/^#!.*/); if (t) {r.push(S('__literal__'),S('('),t₀,S(')')); s ←! s[t₀.length:]}
	while (s ≠ '') {form ← readers('',s,line); r.push(form₀); s ←! form₁; line ←! form₂} return r}

compile_f ← λ(f){fs.writeFileSync('bin/'+f.replace('.α','.js'),repr_js_file(read(fs.readFileSync(f).toString())))}
compile_f(argv₀)

/*
# and then strip whitespace
# for tokens, detect space-operator-space space-operator operator-space operator, tag as 'space_both' 'space_after' 'space_before' 'space_neither'
# or, don't have those four categories; just convert space before and space after into prefix and postfix (or: do this only at a later level)

# and then make groups:
for v in ['()','[]','{}','‹›']: reader_group(v)

# ,; are the void operators and return nothing at all?

# we have left it unclear what exactly the goal is, and i believe we may be suffering from scope creep http://publications.gbdirect.co.uk/c_book/chapter7/how_the_preprocessor_works.html

#define (you can comment out newlines with a backslash)
#include (<header>, "file")
#if elif else ifdef ifndef (taking in constant expressions with arithmetical operators, and taking in definedness)

i want

#require
possibly a #use like thing but that probably should not be a primitive?

#define name tokens
#define name(comma, separated, list) tokens
#define name[comma, separated, list] tokens
#define name[comma, separated, list] tokens


{expr,} is a void block, and {expr} is not a void block, and i think {expr } and {expr\n} should probably be the same as {expr}
"var name =" is probably "name ←"
"name =" could be "name ←!". am not sure.
*/