#!/usr/bin/env ζ
chokidar ← npm('chokidar@1.4.1')

// this is not quite right. like, the thing we're pretending to be is a giant stream of all filesystem events. filtering through that by a filesystem set selector is outside the scope of EventEmitter.
// it probably ought to be using reactive programming?

// huh, we could/should implement it as a library that logs all (requested) filesystem events whether or not its caller is running ?
// that would require reliable long-running processes

pad ← λ(ι,s){↩ ι+s.slice(ι.length)}
fsʷ ← new EventEmitter().on('newListener',λ(fl,f){
	if (fl !== (fl=fs(fl).path)) {fsʷ.on(fl,f); process.nextTick(λ(){ fsʷ.removeListener(fl,f) }); ↩}
	fsʷ._events[fl] || chokidar.watch(fl,{ignoreInitial:true,alwaysStat:true})
		.on('error',λ(ι){console.error('[fs_watch] wat '+ι)})
		.on('all',λ(ev,ι,stat){t ← {'addDir':'add','unlinkDir':'unlink'}; type ← t[ev]||ev; fsʷ.emit(fl, ι, {type, dir: !!t[ev], stat, time: type==='unlink'? new Date() : stat.ctime})})
	})

process.chdir(fs('~/ali/scratch').path)
fsʷ.on('.', λ(fl,{type,dir,time}){if (dir || /(^|\/)\.history(\/|$)/.λ(fl)) ↩
	print(moment(time), pad(type,' '.repeat(6)), fl)
	fs('.history/'+moment(time).toISOString()+' '+(type==='unlink'?'X':'=')+' '+basename_encode(fl)).$ = type==='unlink'? '' : fs(fl).$
	})
