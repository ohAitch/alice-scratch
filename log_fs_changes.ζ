#!/usr/bin/env ζ
chokidar ← npm`chokidar@1.7.0`

APP ← '[φΔs]'

// this is not quite right. like, the thing we're pretending to be is a giant stream of all filesystem events. filtering through that by a filesystem set selector is outside the scope of EventEmitter.
// it probably ought to be using reactive programming?

// huh, we could/should implement it as a library that logs all (requested) filesystem events whether or not its caller is running ?
// that would require reliable long-running processes

log2 ← (…a)=> φ`/tmp/log_φΔs.txt`.text += [APP,…a].join(' ')+'\n'

fsʷ ← new EventEmitter().on('newListener',λ(fl,f){
	if (fl !== (fl=φ(fl)+'')){ fsʷ.on(fl,f); process.nextTick(λ(){ fsʷ.removeListener(fl,f) }); ↩ }
	fsʷ._events[fl] || chokidar.watch(fl,{ignoreInitial:true,alwaysStat:true})
		.on('error',λ(ι){ console.error('[fs_watch] wat '+ι) })
		.on('all',λ(ev,ι,stat){ t ← {'addDir':'add','unlinkDir':'unlink'}; type ← t[ev]||ev; fsʷ.emit(fl, ι, {type, dir: !!t[ev], stat, time: type==='unlink'? new Date() : stat.ctime}) })
	})

φ.cwd = φ`~/file/notes`
fsʷ.on('.', λ(fl,{type,dir,time}){if (dir || fl.re`(^|/)\.archive(/|$)` || /\.(?:gif|jpg|mov|mp3|pages|pdf|png)$/.λ(fl)) ↩
	log2(time.ymdhmss, pad_r(type,' '.repeat(6)), fl)
	//! ? φl ← φ(fl,{exists:type!=='unlink'}); φ`.archive/${time.ymdhmss} ${φl.exists?'=':'X'} ${fl}`.buf = φl.buf
	φ`.archive/…${fl==='#auto/Local/Auto Save Session.sublime_session' && '.sublime/'}${time.ymdhmss} ${type==='unlink'?'X':'='} ${fl}`.buf = type==='unlink'? '' : φ(fl).buf
	})

// bug: this only gets subfiles if they were new since the last version *and* their folders were not



// this is pretty fucked up

// // ------- so let's add another fucked up bit, and watch for doi files ------ //
// E.has_doi = φι=>{
// 	is_doi ← re`(doi:|doi\.org/) *…${npm`doi-regex@0.1.4`().source}`.i
// 	↩ Π((yes,no)=> !φι.match(/\.pdf$/i)? yes(false) : npm`textract@2.1.1`.fromFileWithPath(φι,(e,ι)=> e? no(e) : yes(is_doi.test(ι)) ) ) }
// chokidar.watch(φ`~/Downloads`+'',{depth:0,alwaysStat:true}).on('all',λ(ev,ι){
// 	if (φ(ι).φ`..`+''===φ`~/Downloads`+'') {
// 		has_doi(ι).then(t=>{ if (t) {
// 			hsᵥ`hs.alert(${'moving paper '+φ(ι).name+' to mendeley'})`
// 			fs.rename(ι,φ`~/Documents/Mendeley Desktop/${φ(ι).name}`+'')
// 			} })
// 		} })

// ---------- so let's add another fucked up bit, and poll spotify ---------- //
spotify_state ← ()=>{ var [[id,playL,size],volume,state,at] = osaᵥ`spotify: { {id, played count, duration} of current track, sound volume, player state, player position }`; t ← osaᵥ`get volume settings`; ↩ { time:Time().i, track:{ id,size,playL, }, spotify_volume:volume, volume:t['output volume'], muted:t['output muted'], at, action:state.ι/*∈['stopped','playing','paused']*/, } }
;(()=>{ φ`~/file/spotify.txt`.text += util_inspect_autodepth(spotify_state())+'\n' }).every(10)

// ---------- so let's add another fucked up bit, and kill DS_Store --------- //
chokidar.watch(φ`~/Downloads`+'',{depth:0,alwaysStat:true}).on('all',λ(ev,ι){
	if (φ(ι).φ`..`+''===φ`~/Downloads`+'')
	if (φ(ι).name === '.DS_Store')
		shᵥ`rm ${ι}`
	})
