(ns shiny.core
  (:refer-clojure :exclude [print]) ;! bwah why do i have to repeat this... i think i can fix it by importing everything through rainboom? idk...
  (:use rainboom)
  
  (:use [clojure.pprint :only [pprint]])
  (:use penumbra.opengl)
  (:require [cantor.core :as ct])
  (:require [penumbra.app :as app])
  (:require [penumbra.text :as text])
  (:require [penumbra.time :as time])
  (:require [penumbra.data :as data])
  )
;;;
; pointers to brain
;   ACM meeting shiny screen with lights and pretty
;   soaring 3d built on lisp
;   built on lisp built on Unsafe
;;;
; some repl funcs ; they don't belong in this file but meh
(defmacro work-on [ns] (def working-ns ns))
(defn rl [] (load-file (str (str-replace working-ns "." "/")".clj")) (use working-ns))
;
(work-on shiny.core)
;;;
(defn intersect-1d [[x x2] [x' x2']] ‹‹x <= x2'› and ‹x2 <= x'››)
(defn intersect-2d [[x x2 y y2] [x' x2' y' y2']] ‹(intersect-1d [x y] [x' y']) and (intersect-1d [x2 y2] [x2' y2'])›)
;;;

(def* *dim* (ct/vec2 #i10 #i10))

(defn wrap
  "Makes the position wrap around from right to left, bottom to top"
  [pos]
  (ct/sub
   (ct/map*
    mod
    (ct/add pos *dim*)
    (ct/mul *dim* #i2))
   *dim*))
;
(defn expired? [x]
  ((:expired? x)))

(defn render [x]
  ((:render x)))

(defn radius [x]
  (if (number? (:radius x))
    (:radius x)
    ((:radius x))))

(defn position [x]
  (if (ct/cartesian? (:position x))
    (:position x)
    ((:position x))))

(defn intersects? [a b]
  (let [min-dist (+ (radius a) (radius b))
        dist (ct/sub (position a) (position b))]
    (>= (* min-dist min-dist) (ct/length-squared dist))))

(defn rand-color [a b]
  (map #(+ % (rand (- %2 %))) a b))


;;asteroids

(defn sphere-vertices
  [lod]
  (for [theta (range #i0 #i361 (/ #i360 lod))]
    (for [phi (range #i-90 #i91 (/ #i180 (/ lod #i2)))]
      (ct/cartesian (ct/polar3 theta phi)))))

(defn rand-vector []
  (ct/normalize (ct/cartesian (ct/polar3 (rand #i360) (rand #i360)))))

(defn offset-vertex
  "Expand if on one side of a plane, contract if on the other"
  [v vertex]
  (if (neg? (ct/dot v (ct/normalize vertex)))
    (ct/mul vertex 1.01)
    (ct/mul vertex 0.99)))

(defn offset-sphere [v vertices]
  (map (fn [arc] (map #(offset-vertex v %) arc)) vertices))

(defn gen-asteroid-vertices
  "Procedurally generate perturbed sphere"
  [lod iterations]
  (let [s (iterate #(offset-sphere (rand-vector) %) (sphere-vertices lod))]
    (nth s iterations)))

(defn draw-asteroid [vertices]
  (doseq [arcs (partition #i2 #i1 vertices)]
    (draw-quad-strip
     (doseq [[a b] (map list (first arcs) (second arcs))]
       (vertex a) (vertex b)))))

(defn gen-asteroid-geometry [lod iterations]
  (create-display-list (draw-asteroid (gen-asteroid-vertices lod iterations))))

(defn init-asteroids []
  (def asteroid-meshes (doall (take 20 (repeatedly #(gen-asteroid-geometry #i12 #i100))))))
;
(defn gen-asteroid [& args]
  (let [params (merge
                {:position (ct/vec2 #i0 #i0)
                 :radius #i1
                 :theta (rand #i360)
                 :speed #i1}
                (apply hash-map args))
        birth (app/now)
        elapsed #(- (app/now) birth)
        asteroid (nth asteroid-meshes (rand-int 20))
        velocity (ct/mul (ct/cartesian (:theta params)) (:speed params))
        position #(wrap (ct/add (:position params) (ct/mul velocity (elapsed))))]
    {:expired? #(< (:radius params) 0.25)
     :position position
     :radius (:radius params)
     :render #(push-matrix
                (translate (position))
                (rotate (* (:speed params) (elapsed) #i-50) #i1 #i0 #i0)
                (rotate (:theta params) #i0 #i1 #i0)
                (apply scale (->> params :radius repeat (take 3)))
                (color 0.6 0.6 0.6)
                (call-display-list asteroid))}))

;;particles

(defn textured-quad []
  (draw-quads
   (texture #i0 #i0) (vertex #i-1 #i-1)
   (texture #i1 #i0) (vertex  #i1 #i-1)
   (texture #i1 #i1) (vertex  #i1  #i1)
   (texture #i0 #i1) (vertex #i-1  #i1)))
;
(defn init-particles []
  (def particle-tex
       (let [[w h] [#i32 #i32]
             dim (ct/vec2 w h)
             tex (create-byte-texture w h)]
      (data/overwrite!
       tex
       (apply concat
              (for [x (range w) y (range h)]
                (let [pos (ct/div (ct/vec2 x y) dim)
                      i (Math/exp (* #i16 (- (ct/length-squared (ct/sub pos (ct/vec2 0.5 0.5))))))]
                  [#i1 #i1 #i1 i]))))
      tex))
  (def particle-quad
    (create-display-list (textured-quad))))

(defn draw-particle [position radius tint]
  (push-matrix
    (apply color tint)
    (translate position)
    (scale radius radius)
    (call-display-list particle-quad)))

(defn gen-particle [& args]
  (let [params (merge
                {:position (ct/vec2 #i0 #i0)
                 :theta (rand #i360)
                 :speed #i1
                 :radius (+ 0.25 (rand 0.5))
                 :color [#i1 #i1 #i1]
                 :lifespan #i1}
                (apply hash-map args))
        birth (app/now)
        velocity (ct/mul (ct/cartesian (ct/polar2 (:theta params))) (:speed params))
        elapsed #(- (app/now) birth)
        position #(wrap (ct/add (:position params) (ct/mul velocity (elapsed))))]
    {:expired? #(> (- (app/now) birth) (:lifespan params))
     :position position
     :radius (:radius params)
     :render #(draw-particle
               (position)
               (:radius params)
               (concat (:color params) [(max #i0 (- #i1 (Math/pow (/ (elapsed) (:lifespan params)) #i3)))]))}))

;;spaceship

(defn draw-fuselage [] ;;should be hung in the Louvre
  (color #i1 #i1 #i1)
  (draw-triangles
   (vertex -0.4 -0.5) (vertex #i0 -0.4) (vertex #i0 0.5)
   (vertex 0.4 -0.5) (vertex #i0 -0.4) (vertex #i0 0.5)))

(defn init-spaceship []
  (def fuselage (create-display-list (draw-fuselage))))

(defn fire-bullet [state]
  (let [ship (:spaceship state)]
    (assoc state
      :bullets
      (conj
       (:bullets state)
       (gen-particle
        :position (:position ship)
        :theta (:theta ship)
        :speed #i15
        :radius 0.25
        :color [#i0 #i0 #i1]
        :lifespan #i2)))))

(defn emit-flame [state]
  (when (app/key-pressed? :up)
    (let [ship (:spaceship state)
          offset (- (rand #i30) #i15)
          theta (+ #i180 (:theta ship) offset)
          particles (:particles state)
          position (ct/add (:position ship) (ct/cartesian (ct/polar2 theta 0.3)))
          velocity (ct/polar (ct/add (:velocity ship) (ct/cartesian theta)))]
      (assoc state
        :particles (conj particles
                         (gen-particle
                          :position position
                          :theta (.theta velocity)
                          :speed (.r velocity)
                          :radius 0.25
                          :color (rand-color [#i1 0.5 0.7] [#i1 #i1 #i1])
                          :lifespan (/ (Math/cos (ct/radians (* #i3 offset))) 2.5)))))))
;
(defn update-spaceship [dt ship]
  (let [p     (:position ship)
        v     (:velocity ship)
        theta (:theta ship)
        theta (condp (fn [x _] (app/key-pressed? x)) nil
                :left  (rem (+ theta (* #i360 dt)) #i360)
                :right (rem (- theta (* #i360 dt)) #i360)
                theta)
        a     (if (app/key-pressed? :up)
                  (ct/mul (ct/cartesian theta) #i3)
                  (ct/vec2 #i0 #i0))
        v     (ct/add v (ct/mul a dt))
        p     (wrap (ct/add p (ct/mul v dt)))]
    (assoc ship
      :theta theta
      :position p
      :velocity v)))

(defn draw-spaceship [ship]
  (push-matrix
    (translate (:position ship))
    (rotate (- (:theta ship) #i90) #i0 #i0 #i1)
    (call-display-list fuselage)))

(defn gen-spaceship []
  {:position (ct/vec2 #i0 #i0)
   :radius 0.5
   :velocity (ct/vec2 #i0 #i0)
   :theta #i0
   :birth (app/now)})

;;game state

(defn reset
  "Reset to initial game state."
  [state]
  (assoc state
    :spaceship (gen-spaceship)
    :asteroids (take 4 (repeatedly
                        #(let [theta (rand #i360)
                               pos (ct/cartesian (ct/polar2 theta #i2))]
                           (gen-asteroid :position pos :theta theta :speed (rand)))))))

(defn split-asteroid
  "Turn asteroid into four sub-asteroids."
  [asteroid]
  (when (< 0.25 (radius asteroid))
    (take 4
      (repeatedly
       #(gen-asteroid
         :position (position asteroid)
         :radius (/ (radius asteroid) #i2)
         :speed (/ 1.5 (radius asteroid)))))))

(defn gen-explosion
  "Create particles within a given color range."
  [num object [lo-color hi-color] speed]
  (take num
    (repeatedly
     #(gen-particle
       :position (position object)
       :speed (rand speed)
       :color (rand-color lo-color hi-color)
       :lifespan #i2))))

(defn explode-asteroids
  "Turn asteroid into sub-asteroids and explosion particles."
  [asteroids state]
  (assoc state
    :asteroids (concat
                 (:asteroids state)
                 (mapcat split-asteroid asteroids))
    :particles (concat
                 (:particles state)
                 (mapcat #(gen-explosion (* (radius %) #i1000) % [[#i1 0.5 #i0] [#i1 #i1 0.2]] #i10) asteroids))))

(defn check-complete
  "Are all the asteroids gone?"
  [state]
  (if (zero? (count (:asteroids state)))
    (reset state)
    state))

(defn check-ship
  "Has the ship collided with any asteroids?"
  [state]
  (let [ship (:spaceship state)
        asteroids (:asteroids state)
        hit (filter #(intersects? ship %) asteroids)
        missed (filter #(not (intersects? ship %)) asteroids)]
    (if (some #(intersects? ship %) asteroids)
      (assoc state
        :asteroids (concat missed (mapcat split-asteroid hit))
        :spaceship (gen-spaceship)
        :particles (concat (:particles state) (gen-explosion #i300 ship [[#i0 #i0 0.6] [0.5 0.5 #i1]] #i7)))
      state)))

(defn check-asteroids
  "Have the asteroids collided with any bullets?"
  [state]
  (let [bullets (:bullets state)
        asteroids (:asteroids state)
        collisions (for [a asteroids, b bullets :when (intersects? a b)] [a b])
        q (set (map first collisions))
        hit (filter q asteroids)
        missed (filter #(not (q %)) asteroids)
        bullets (remove (set (map second collisions)) bullets)
        particles (:particles state)]
    (explode-asteroids
     hit
     (assoc state
       :particles (remove expired? particles)
       :bullets (remove expired? bullets)
       :asteroids missed))))

(defn update-collisions [state]
  (binding [*dim* (:dim state)]
    (-> state check-asteroids check-ship check-complete)))

;;game loop

(defn init [state]
  (app/title! "Asteroids")
  (app/vsync! true)
  (app/key-repeat! false)
  (init-asteroids)
  (init-particles)
  (init-spaceship)
  (enable :blend)
  (blend-func :src-alpha :one-minus-src-alpha)
  (app/periodic-update! #i25 update-collisions)
  (app/periodic-update! #i50 emit-flame)
  (reset state))

(defn reshape [[x y w h] state]
  (let [dim (ct/vec2 (* (/ w h) #i10) #i10)]
    (frustum-view #i45 (/ w h) 0.1 #i100)
    (load-identity)
    (translate #i0 #i0 (- (* 2.165 (.y dim))))
    (assoc state
      :dim dim)))
;
(defn key-press [key state]
  (cond
   (= key " ") (fire-bullet state)
   (= key :escape) (app/pause!)
   (= key "1") (app/speed! 0.5)
   (= key "2") (app/speed! #i1)
   (= key "3") (app/speed! #i2)
   :else state))

(defn update [[dt time] state]
  (binding [*dim* (:dim state)]
    (assoc state
      :spaceship (update-spaceship dt (:spaceship state)))))
;
(defn display [[dt time] state]
  (text/write-to-screen (str (int (/ #i1 dt)) " fps") #i0 #i0)
  (binding [*dim* (:dim state)]
    (with-enabled :texture-2d
      (with-texture particle-tex
        (doseq [p (concat (:particles state) (:bullets state))]
          (render p))))
    (with-disabled :texture-2d
      (with-render-mode :wireframe
        (doseq [a (:asteroids state)]
          (render a)))
      (draw-spaceship (:spaceship state)))
    (app/repaint!)))

(defn start []
  (app/start
   {:reshape reshape, :init init, :key-press key-press, :update update, :display display} 
   {:dim *dim*}))
(println "you rock! woohoo~")