(ns penbra.opengl.context
  (:use [penbra.opengl core]
        [penbra opengl]
        [penbra.opengl.geometry :only [basic-renderer]])
  (:require [penbra.data :as data]
            [penbra.opengl.capabilities :as cap])
  (:import [org.lwjgl.opengl Display]))

;;;

(defn- draw []
  (with-projection (ortho-view -1 1 1 -1 -1 1)
    (push-matrix
     (load-identity)
     (gl,active-texture :texture0)
     (color 1 1 1)
     (draw-quads
      (texture 0 1) (vertex -1 -1 0)
      (texture 1 1) (vertex 1 -1 0)
      (texture 1 0) (vertex 1 1 0)
      (texture 0 0) (vertex -1 1 0)))))

(defn draw-frame-buffer
  ([w h]
     (draw-frame-buffer 0 0 w h))
  ([x y w h]
     (with-viewport [x y w h]
       (call-display-list (force *display-list*)))))

(defn create-context []
  {:display-list (delay (create-display-list (draw)))
   :texture-pool (data/create-cache)
   :font-cache (atom {})})

(defn current []
  {:display-list *display-list*
   :texture-pool *texture-pool*
   :font-cache *font-cache*})

(defn destroy
  ([]
     (destroy (current)))
  ([context]
     (data/clear! (:texture-pool context))))

(defmacro with-context [context & body]
  `(let [context-exists?# ~context
         context# (or ~context (create-context))]
     (binding [*display-list* (:display-list context#)
               *texture-pool* (:texture-pool context#)
               *font-cache* (:font-cache context#)
               *read-format* cap/read-format
               *renderer* basic-renderer]
       (try
        ~@body
        (finally
         (when-not context-exists?#
           (destroy context#)))))))

