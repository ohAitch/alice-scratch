// https://projecteuler.net/problem=570
// 2016-10-07

// ------------------------------------ 1 ----------------------------------- //

1,6,6*(6-1),6*((6-1)*3+(6-2)*2)

1 , (1+2+3)*1 , (1+2+3)*(2+3)*1, (1+2+3)*(2*((2+2)*1) + 3*((2+3)*1))

1 = 1
6 = 6 * 1
30 = 6 * [X,1,2,3,4,5]
138 = 6 * [0:X,1:[X,1,2,X,4,5],2:[X,1,2,3,X,5],3:[X,1,2,3,4,5],4:[X,1,2,3,4,5],5:[X,1,2,3,4,5]]
636 = 6 *
	0:X
	1:[0:X,1:[X,1,2,X,X,5],2:[X,1,2,3,X,5],3:X            ,4:[X,1,2,3,4,5],5:[X,1,2,X,4,5]]
	2:[0:X,1:[X,1,2,X,4,5],2:[X,1,2,X,X,5],3:[X,1,2,3,4,5],4:[X,1,2,3,4,5],5:[X,1,2,3,X,5]]
	3:[0:X,1:[X,1,2,X,4,5],2:[X,1,2,3,X,5],3:[X,1,2,3,4,5],4:[X,1,2,3,4,5],5:[X,1,2,3,4,5]]
	4:[0:X,1:[X,1,2,X,4,5],2:[X,1,2,3,X,5],3:[X,1,2,3,4,5],4:[X,1,2,3,4,5],5:[X,1,2,3,4,5]]
	5:[0:X,1:[X,1,2,X,4,5],2:[X,1,2,3,X,5],3:[X,1,2,3,4,5],4:[X,1,2,3,4,5],5:[X,1,2,3,4,5]]

A←(n)=> [1,6,30,138,636][n]
lost←(n)=> n===0? 0 : A(n-1)*6 - A(n)
B←(n)=> n===0? 0 : lost(n) + B(n-1)*6 //- ?

// ------------------------------------ 2 ----------------------------------- //

rotate ← ([s,a,b,c])=> [ [s,s,a,b], [s,s,a,c], [s,s,b,c], [a+1,s,a,a], [b+1,s,b,b], [c+1,s,c,c], ].filter(ι=>ι[0]<=2)

S_1 ← [ ['1000',1] ]
S←(n)=> _.range(n-1).reduce(ι=> ι.mapcat(rotate), S_1)
R ← ι=> ι._.countBy(0)

bench(()=> S(9) )

// ------------------------------------ 3 ----------------------------------- //

Bignum ← npm('bignumber.js@2.4.0')

transitions ← (λ(){
	rotate ← ([s,a,b,c])=> [ [s,s+1,a,b], [s,s+1,a,c], [s,s+1,b,c], [a+1,s+1,a,a], [b+1,s+1,b,b], [c+1,s+1,c,c], ].filter(ι=>ι[0]<=3)
	r2 ← ι=> rotate(ι.split('').map(parseInt.X)).map(ι=> ι.join(''))
	ι ← ['1000']; t←; while(!_.isEqual( ι._.countBy(), (t=[…ι,…ι.mapcat(r2)]._.uniq())._.countBy() )) ι = t
	↩ ι.map(ι=> [ι,r2(ι)._.countBy()._.pairs()])._.object()
	// { '1000': [ [ '1200', 6 ] ],
	//   '1200': [ [ '1200', 3 ], [ '1220', 2 ], [ '3222', 1 ] ],
	//   '1220': [ [ '1200', 1 ], [ '1220', 2 ], [ '1222', 1 ], [ '3222', 2 ] ],
	//   '1222': [ [ '1222', 3 ], [ '3222', 3 ] ],
	//   '3222': [ [ '3422', 6 ] ],
	//   '3422': [ [ '3422', 3 ], [ '3442', 2 ] ],
	//   '3442': [ [ '3422', 1 ], [ '3442', 2 ], [ '3444', 1 ] ],
	//   '3444': [ [ '3444', 3 ] ] }
	})()

S_1 ← { '1000':new Bignum(1) }
S_next ← ι=>{ r ← transitions._.keys().map(ι=>[ι,new Bignum(0)])._.object(); for(var x of ι._.pairs()) for(var y of transitions[x[0]]) r[y[0]] = r[y[0]].add(x[1].mul(y[1])); ↩ r }
// S←(n)=> _.range(n-1).reduce(ι=> S_next(ι), S_1)
AB←(n)=>{ t ← S(n); ↩ [t['1000'].add(t['1200']).add(t['1220']).add(t['1222']), t['3222'].add(t['3422']).add(t['3442']).add(t['3444'])] }
gcd ← (a,b)=> b.isZero()? a : gcd(b, a.mod(b))
G←(n)=>{ t ← gcd(…AB(n)); t.gte(Number.MAX_SAFE_INTEGER) && ‽(n,t); ↩ t|0 }

// ‡ but thats n², so transform it like
S_cache ← {n:1,ι:S_1}
S ← n=>{ r ← n===S_cache.n+1?( S_cache.n++, S_cache.ι = S_next(S_cache.ι) ): _.range(n-1).reduce(ι=> S_next(ι), S_1); S_cache.n = n; S_cache.ι = r; ↩ r }

_.range(3,1e7+1).map(ι=>( ι%1000===0&&cn.log(Time(),ι), G(ι) )).reduce(add)

// ------------------------------------ 4 ----------------------------------- //
Bignum ← npm('bignumber.js@2.4.0')

transitions ← [
	[ 3,2,0,1,0,0,0 ],
	[ 1,2,1,2,0,0,0 ],
	[ 0,0,3,3,0,0,0 ],
	[ 0,0,0,0,6,0,0 ],
	[ 0,0,0,0,3,2,0 ],
	[ 0,0,0,0,1,2,1 ],
	[ 0,0,0,0,0,0,3 ]]
S_2 ← [ 6,0,0,0,0,0,0 ].map(ι=> new Bignum(ι))
mmulv2 ← (m,v)=>{ r ← v.map(()=> new Bignum(0)); L ← v.length; for(iv←0;iv<L;iv++) for(im←0;im<L;im++) r[im] = r[im].add(v[iv].mul(m[iv][im])); ↩ r }
S_next ← ι=> mmulv2(transitions,ι)
// S←(n)=> _.range(n-2).reduce(ι=> S_next(ι), S_2)
// AB←(n)=>{ t ← S(n); ↩ [t[0]+t[1]+t[2], t[3]+t[4]+t[5]+t[6] }
AB←(n)=>{ t ← S(n); ↩ [t[0].add(t[1]).add(t[2]), t[3].add(t[4]).add(t[5]).add(t[6])] }
// gcd ← (a,b)=> b>0? gcd(b, a%b) : a
gcd ← (a,b)=> b.isZero()? a : gcd(b, a.mod(b))
// G←(n)=> gcd(…AB(n))
G←(n)=>{ t ← gcd(…AB(n)); t.gte(Number.MAX_SAFE_INTEGER) && ‽(n,t); ↩ t|0 }

S_cache ← {n:2,ι:S_2}
S ← n=>{ n >= 2 || ‽; r ← n===S_cache.n+1?( S_cache.n++, S_cache.ι = S_next(S_cache.ι) ): _.range(n-2).reduce(ι=> S_next(ι), S_2); S_cache.n = n; S_cache.ι = r; ↩ r }

// _.range(3,1e7+1).map(ι=>( ι%1000===0&&cn.log(Time(),ι), G(ι) )).reduce(add)
// this will solve it in ~80000 years, let's see if we can go faster

n > 1         => G(n) =0% 2*3
n = 11 % 20   => G(n) =0% 5 WHICH the second number will too
n = 104 % 272 => G(n) =0% 17 WHICH the second number will too
n = 43 % 342  => G(n) =0% 19 WHICH the second number will too
n = 246 % 253 => G(n) =0% 23 WHICH the second number will too
n = 273 % 812 => G(n) =0% 29 WHICH the second number will too
n = 500 % 930 => G(n) =0% 31 WHICH the second number will too
n = 64 % 1640 => G(n) =0% 41 WHICH the second number will too

‡ iiinteresting


‡‡‡ what does it look like? S(n), what does S(n) *look* like, i want to see it ‡‡‡
‡‡‡ that would be REAL data science. i kind of feel like that is cheating, like actually i should research awesome shit and become awesome
