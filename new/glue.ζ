â§«. hsáµ¥ ==> (ss,â€¦Î¹s)=>{
	ENC â† Î¹â‡’
		: Tstr(Î¹)||Tnum(Î¹)? JSON.stringify(Î¹)
		: Tarr(Î¹)? '{'+Î¹.map(ENC).join(',')+'}'
		: '{'+_u(Î¹).map((Î¹,i)=>'['+ENC(i)+']='+ENC(Î¹)).join(',')+'}'
	Î¹ â† simple_template(ss,Î¹s,ENC).join('')
	# t â† sháµ¥`hs -c ${Î¹}`
	t â† sháµ¥`/usr/local/bin/hs -c ${Î¹}`
	# t â† child_ process.spawnSync(which('hs'),['-c',Î¹]).stdout
	t â† (t+'').split('\n')[-1] ;â†© orâˆ…( catch_Î¹(=> JSON.parse(t)),t ) }

â§«. tsáµ¥ ==> (ss,â€¦Î¹s)=>{
	ENC â† JSON.stringify ;Î¹ â† simple_template(ss,Î¹s).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('')
	Î¹ = 'require "totalspaces2" ;TS = TotalSpaces2 ;'+Î¹
	PORT = 34290
	R â† => JSON.parse(fs_ipc_emit(PORT,Î¹))[0]
	launch_serv â† =>{
		;(sháµ¥`gem list`+'').re`(^|\n)totalspaces2 ` || â€½
		t â† Ï†`/tmp/evalserv_${ğŸ²id.greek(9)}.rb`
		t.text = String.raw`#!/usr/bin/env ruby
			require "socket" ;require "json"
			server = TCPServer.new("localhost",${PORT})
			loop do
			  t = server.accept
			  r = JSON.generate([eval(File.read("/tmp/fs_ipc_#{${PORT}}"))])
			  t.print "HTTP/1.1 200 OK\r\n"+"Content-Type: text/plain\r\n"+"Content-Length: #{r.bytesize}\r\n"+"Connection: close\r\n"+"\r\n"+r
			  t.close
			end`
		sháµ¥`chmod +x ${t}`
		shâ‚lone`${t}` !>(â™“_sub) }
	try{â†© R() }catch(e){ e.status===7 && launch_serv() ;sháµ¥`sleep 0.1` ;â†© R() } }

â§«. sbáµ¥ ==> (ss,â€¦Î¹s)=>{
	ENC â† JSON.stringify ;Î¹ â† simple_template(ss,Î¹s).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('')
	Ï†`/tmp/sbğ…°ğ…¯ğ…œğ…‚ğ…`.Î¹ = Î¹ ;â†© JSON.parse(sháµ¥`curl -s -X PUT localhost:34289`+'') |>(Î¹=> Î¹===null? âˆ… : Î¹) }
â§«. sb_editáµ¥ ==> view=>(ss,â€¦Î¹s)=>{ sbáµ¥`edit(${view},${py(ss,â€¦Î¹s)})` }

â§«. terminal_do_script ==>{
	sh.clear = String.raw`/usr/bin/clear && printf %s $'\e[3J'`
	â†© (a,b)=>{ Ï†`/tmp/__Â·`.Î¹ = a ;osaáµ¥`terminal: do script "Â·" â€¦${b}` } }
â§«[ 'Â·'] ==> =>{ t â† Ï†`/tmp/__Â·` ;postrun(t.text) ;t.Î¹ = âˆ… }

#################################### module ####################################
# Î³.node = {} ;ğ…©ğ…‹ â† (a,b)=> nodeâ€˜[a] .thunk==> require(b) ;npm`builtin-modules@2.0.0`.map(Î¹=>ğ…©ğ…‹(Î¹,Î¹)) ;ğ…©ğ…‹('EventEmitter','events') ;ğ…©ğ…‹('Module','module')
# Î³._u = npm`underscore@1.8.3` # lodash is better than underscore except for _()
# Î³._l = npm`lodash@4.17.4`
# Î³._ = _u
# Î³.require_new = Î¹=> (ğ…ƒğ…œğ…ğ…°ğ…¯||(ğ…ƒğ…œğ…ğ…°ğ…¯= npm`require-uncached@1.0.3` ))( (Î¹+'').replace(/^\.(?=\/)/,Ï†.cwd) ) ;ğ…ƒğ…œğ…ğ…°ğ…¯â†;

# Î³.npm = (â€¦a)=>{ Î¹â†a[0]+'' ;â†© Î¹.includes('@')? require(npm_init(â€¦a)) : 'npm`'+Î¹+'@'+sháµ¥`npm show ${Î¹} version`+'`' }
# npm_init â† (id_ver,sub='')=>{ id_ver+=''
# 	ğ…« â† Ï†`/usr/local/lib/ğ…ªğ…©modu/${id_ver+'__'+process.versions.modules}/node_modules`
# 	# to match ABI, https://github.com/electron/electron/blob/master/docs/tutorial/using-native-node-modules.md
# 	if(! ğ…«.âˆƒ ) sháµ¥`cd ${ğ…«.dir_ensure.Ï†`..`} && npm --cache-min=Infinity install ${id_ver}`
# 	â†© ğ…«.Ï†`${id_ver.split('@')[0]}`+sub }
# # in theory, log whenever somebody uses an outdated lib
