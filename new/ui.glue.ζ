‚ß´. go_to ==> (‚Ä¶a)=>{ # synonyms? ,go_to ,open ,search
	opt ‚Üê !Tprim(a[-1])? a.pop() : {}
	type ‚Üê a.‚Äñ===1? ‚àÖ : a.shift()
	Œπ ‚Üê a[0]
	{new:new_,focus,in_app,sb_view_file_name} ‚Üê { ,new:‚úó ,focus:‚úì ,in_app:‚àÖ ,sb_view_file_name:‚àÖ } ‚Ä¶‚Üê (opt)

	is_url ‚Üê .re`^((https?|chrome-extension)://|file:|mailto:)`
	searchify ‚Üê Œπ=> 'https://www.google.com/search?q='+encodeURIComponent(Œπ)

	in_app && (in_app = in_app.toLowerCase())

	focus || nacksoft

	# windows_in_current_space_in_app ‚Üê app=> hs·µ•`json(hs.fnutils.imap( hs.window.filter.new(false):setAppFilter(${app},{visible=true,currentSpace=true}):getWindows() ,function(x) return x:id() end))`
	# apps_with_windows_in_current_space ‚Üê => hs·µ•`json(hs.fnutils.imap( hs.window.filter.new(false):setAppFilter('default',{visible=true,currentSpace=true}):getWindows() ,function(x) return x:application():name() end))`

	############################ go to specific chrome ###########################
	# this contained some "is_chromeapp_active" code which we don't need because Signal transitioned to electron
	# 	# System Events got an error: osascript is not allowed assistive access
	# 	# compile_mapping(M('c',' ;'+js`terminal_do_script(${sh`Œ∂ --fresh ${js`(‚Ä¶${osa_activate_thing·µ•+''})('chrome')`} ;exit`})`)).Œπ,
	#  
	# 	t ‚Üê [2,1] ;chrome_simple_js_·µ•(`alert('foo')`,{window:t[0],tab:t[1]})

	if( !type){ !new_ || ‚ÄΩ
		if( !is_url(Œπ)) Œπ = searchify(Œπ)
		if( !in_app && Œπ.re`^file:`){
			file ‚Üê decodeURI(Œπ).replace(re`^file:(//)?`,'')
			if( file[0]!=='/') file = node.path.normalize(node.path.join( œÜ(sb_view_file_name||‚ÄΩ).œÜ`..`+'' ,file ))
			if( œÜ(file).is_dir) in_app = 'path finder'
			else if( ['.pdf','.m4a','.epub','.mobi'].includes(node.path.extname(file)));
			else if( ['.png','.jpg'].includes(node.path.extname(file))) in_app = '#ql'
			else in_app = 'sublime text'
			[À£,p,r] ‚Üê decodeURI(Œπ).re`^(.*?:)([^]*)` ;Œπ ‚Üê p+r.replace(/[^\/]+/g,encodeURIComponent.X)
			}
		if( in_app==='#ql') sh‚Çê`( &>/dev/null qlmanage -p ${file} &)`
		else{
			in_app ||( in_app = 'chrome' )
			if( in_app==='chrome'){
				t ‚Üê osa·µ•`chrome: URL of tabs of windows`.find_index_deep(t=> t===Œπ) ;if( t)
					{ [window_,tab] ‚Üê t ;osa‚Çê`chrome: set active tab index of window ${window_+1} to ${tab+1}` ;osa‚Çê`chrome: activate` ;‚Ü© } }
			if( Œπ.re`^chrome-extension://`) sh·µ•`duti -s com.google.Chrome chrome-extension` # bug workaround
			sh·µ•`open ‚Ä¶${in_app && sh`-b ${in_app |> (@device_memo(Œπ=> catch_Œπ(=> osa·µ•`id of app ${Œπ}`) ))}`} ${!focus && '-g'} ${Œπ}`
			}
		if( focus && in_app==='path finder') osa‚Çê`${in_app}: activate`
		}
	else if( type==='app'){ ( !new_ && focus && !in_app )||‚ÄΩ ;app ‚Üê Œπ
		# ! should gather most of this information periodically async & record it. should use FRP.
		hint_screen ‚Üê { ,'sublime text':2 ,'path finder':3 ,'github desktop':4 }
		isnt_standalone ‚Üê { ,ibooks:1 ,preview:1 }
		hint_screen[app] && robot_key_tap('^'+hint_screen[app])
		isnt_standalone[app]? osa·µ•`${app}: if it is running then ;activate ;end if` : osa·µ•`${app}: activate`
		}
	else if( type==='screen'){ ( !new_ && focus && !in_app && /^[1-9]$/.test(Œπ+'') )||‚ÄΩ ;robot_key_tap('^'+Œπ) }
	else if( type==='path'){ ( !new_ && focus )||‚ÄΩ
		# ! i think this might be a pretty badly designed type
		new_ = ‚úì
		if( Œπ.re`^(?:code|consume|documents|history|notes|pix)/.{1,80}:\d+:`){ !in_app || ‚ÄΩ # ! duplication with sublime/User/it.py:FIND_RESULT
			# in_app = 'sublime text'
			[À£,Œπ,line] ‚Üê Œπ.re`^(.+):(\d+):$`
			Œπ = œÜ('~/file/'+Œπ)
			sh·µ•`'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' ${Œπ}:${line}` ;‚Ü© }
		if( in_app==='terminal'){
			here ‚Üê hs·µ•`json(hs.fnutils.imap( hs.window.filter.new(false):setAppFilter('Terminal',{visible=true,currentSpace=true}):getWindows() ,function(x) return x:id() end))` # ... the behavior changed. fuck
			unbusy ‚Üê => osa·µ•`terminal: id of windows where busy = false`
			available ‚Üê Set(here).‚à©(unbusy())[0]
			terminal_do_script( sh`cd ${Œπ} ;‚Ä¶${!available && sh.clear}` ,osa`‚Ä¶${!!available && osa`in (window 1 whose id = ${available})`} ;‚Ä¶${focus && 'activate'}` ) ;‚Ü© }
		else go_to(encodeURI('file:'+œÜ(Œπ).root('/')),{in_app,focus,sb_view_file_name})
		}
	else ‚ÄΩ }

‚ß´. notify ==> Œπ=>{
	Tstr(Œπ) &&( Œπ = Œπ.re`\n`? Œπ.re`^(.*?)\n([^]*)`.slice(1) : Œπ.re` `? Œπ.re`^(.*?) ([^]*)`.slice(1) : [Œπ] )
	‚Ü© net1.device_listen().then(H=>{
	r ‚Üê H.just_first_json()
	hs·µ•`hs.notify.new(
		function(x) ;x:withdraw() ;simple_send(${H.at},{ at=x:actualDeliveryDate() }) end
		,{ title=${Œπ[0]} ,informativeText=${or‚àÖ(Œπ[1],'')} ,otherButtonTitle='\u{2063}' ,actionButtonTitle='\u{2063}' }
		):send()`
	‚Ü© r }) }

# ‚ß´. set_newtab_bg ==> Œπ=> sh·µ•`ln -sf ${Œπ} ~/code/scratch/user.net/chrome:newtab/it.jpg`
‚ß´. set_newtab_bg ==> Œπ=>{
	d ‚Üê @device0`chrome:newtab`.o
	d.œÜ`it.html`.text = js` <meta charset="utf-8"> <title>‚†Ä</title> <style>
		html,body {
			;height:100% ;width:100% ;margin:0
			;background:url(${Œπ}) ;background-position:50% 50% ;background-size:cover
			} </style> `
	d.œÜ`manifest.json`.json = { ,manifest_version:2 ,name:'newtab' ,version:'1' ,description:'' ,chrome_url_overrides:{ ,newtab:'it.html' } } }

# Œ≥.üéµ = Œπ=> sh‚Çêlone`afplay ${Œπ}`
# Œ≥.üéµd = Œπ=> net1._0_œÜ_seenbydevice0(`https://www.dropbox.com/s/${Œπ}?dl=1`).then(Œπ=>üéµ(Œπ.o))
# Œ≥‚Äò.nacksoft .get==> üéµd`kaphh65p0obaq93/nacksoft.wav`

##################################### bash #####################################
‚ß´. x ==>{
	set_term_title ‚Üê Œπ=> process.stdout.write('\x1b]0;'+Œπ+'\x07')
	this_term_is_frontmost ‚Üê =>{ t ‚Üê üé≤id(25) ;set_term_title(t) ;r ‚Üê osa·µ•`terminal: frontmost of (windows whose custom title = ${t})`[0] ;set_term_title('') ;‚Ü© r }
	‚Ü© (=>{ E ‚Üê process.env.? |0
		this_term_is_frontmost() ||( E===0? say`‚úì` : (say`‚úó` ,osa·µ•`terminal: activate`) )
		E===0? postrun('exit') : ( process.exitCode = E )
		}) }

################################### electron ###################################
# ‚ß´. electron_window_for ==> id=> (‚Ä¶a)=> electron_window(id,‚Ä¶a) # deprecated?
‚ß´. electron_window ==>{
	# interaction with previous versions: unsolved
	êÖ© ‚Üê {
		,init:=> _electron__start_my().Œ†
		,Œπ: @device0`êÖ∞êÖÉêÖ¨êÖ¶êÖúelectron`
		# @proc alive_at: time of last message received from
		# @proc path_to
		,path_init:=> !êÖ©.Œπ.Œπ? Œ†x() :( êÖ©.path_to = net1.open_send(êÖ©.Œπ.Œπ[1]) !>(.then(Œπ=> Œ†or(Œπ.Œ†`close`,Œπ.Œ†`end`).then(=> êÖ©.path_to = ‚àÖ ) ,=>‚àÖ)) )
		,path_to:‚àÖ
		}
	send_to_my ‚Üê Œπ=>{
		êÖØ ‚Üê => êÖ©.path_init() !>(.then(s=> stream4.send_json(s)(Œπ) ,=>‚àÖ))
		êÖØ().catch(=>{
			lock('êÖÇêÖÇêÖ™êÖØêÖ© electron init').then(
				,un=> êÖ©.init().then(Œπ=>{ un() ;êÖ©.Œπ.Œπ = Œπ ;êÖØ().catch(=>‚àÖ) } ,un)
				,=> /* retry once */ (=> êÖØ().catch(=>‚àÖ) ).in(1/*holy shit cheating*/)
				)
			}) }
	‚Ü© (id,‚Ä¶a)=>{ Œπ ‚Üê a.pop() ;Tfun(Œπ) &&( Œπ = js`(‚Ä¶${Œπ+''})(... ${a})` ) ;send_to_my({,id,code:Œπ}) } }
‚ß´. _electron__start_my ==>{
	start_el_app ‚Üê (code,‚Ä¶a)=>{
		cmd ‚Üê npm`electron@1.8.2-beta.2` ;t ‚Üê cmd_log_loc(cmd)
		c2 ‚Üê `require('/usr/local/bin/Œ∂') ;(${code})(${a.join(',')})`
		node.child_process.spawn(sh`${cmd} ${simple_as_file(c2)}`,{ ,shell:‚úì ,detached:‚úì ,stdio:['ignore',node.fs.openSync(t.out,'a+'),node.fs.openSync(t.err,'a+')] })
		|>(Œπ=> [Œπ,‚Ä¶Œπ.stdio,Œπ.channel].map(Œπ=>Œπ&&Œπ.unref()) )
		}
	‚Ü© => @deviceŒ†(re=> start_el_app(re=>{ ;el ‚Üê require('electron') ;el.app.Œ†`ready`.then(=>{
		el.ipcMain.on('eval_main',(ev,Œπ)=> eval(Œπ)(êÖ¶d.get(ev.sender))) ;êÖ¶ ‚Üê Œπ=> êÖ¶d.set(Œπ.webContents,Œπ) ;êÖ¶d ‚Üê new WeakMap()
		el.app.on('window-all-closed',=> el.app.hide() )
		imgur`1uoWV5c`.then(Œπ=> el.app.dock.setIcon(Œπ.@device) )
		on_msg ‚Üê ({,id,code})=>{ w ‚Üê êÖÆêÖ≠êÖ∞êÖÇêÖÆ‚Äò[id]
			send ‚Üê Œπ=> w.Œπ.webContents.executeJavaScript(Œπ+';0')
			if(! w.Œπ ){
				t ‚Üê w.Œπ = new el.BrowserWindow({ ,show:‚úó ,frame:‚úó }) !>(êÖ¶)
				t.loadURL('about:blank')
				t.Œ†`closed`.then(=> w.‚àÉ = ‚úó )
				send(`
					require('/usr/local/bin/Œ∂')
					Œ≥.el = require('electron')
					Œ≥.eval_main = f=> el.ipcRenderer.send('eval_main',f+'') `)
				t.Œ†`ready-to-show`.then(=> t.show()) }
			send(code) } ;êÖÆêÖ≠êÖ∞êÖÇêÖÆ ‚Üê {}
		net1.device_listen().then(H=>{ ;H.on('connection',s=> stream4.as_json(s).on(on_msg) ) ;re(H.at) })
		})},re) ) }

################################################################################
‚ß´. say ==> Œπ=>{ ;hs·µ•`hs.alert(${Œπ+''})` ;nacksoft }

# Œ∂_repl_start ‚Üê =>{
# 	# i know how to make the good repl for ct. i want to, but im tired
# 	diesis_compile ‚Üê Œπ=>{t‚Üê;
# 		# of course this is lovely but it is a dead end - we want Sight
# 		lock ‚Üê 0?0
# 			: ['ct','chrome_tabs','ps2','d','bookmarks'].‚à™([]).has(Œπ)? Œπ+'()'
# 			: (t= Œπ.re`^f(?: (.+))?$` )? js`go_to('path',${t[1]||'.'})`
# 			: Œπ
# 		lock===Œπ || log('‚õì  '+lock)
# 		‚Ü© lock }
# 	# @2018-01-04 current priority is to work on seeing first; merging w Œ∂_repl_start
# 	# '\x1b[30m\x1b[42mŒ∂\x1b[0m '
# 	‚Ü© (f=> f.call( node.repl.start({ ,useGlobal:‚úì ,prompt:'\x1b[30m\x1b[100m‚Ä°\x1b[0m ' }) ))(Œª(){
# 	@.In = [] ;@.Out = []
# 	super_ ‚Üê @.completer ;@.completer = Œª(line,cb){ line.trim()===''? cb(‚àÖ,[]) : super_.call(@,line,cb) }
# 	@.removeAllListeners('line').on('line',Œª(line){
# 		@.context.rl = @
# 		@.context.E = @.context # ! what?
# 		if( @.bufferedCommand ){ Œπ ‚Üê @.history ;Œπ.reverse() ;t ‚Üê Œπ.pop() ;Œπ[-1] += '\n'+t ;Œπ.reverse() }
# 		code ‚Üê @.bufferedCommand+line
# 		code = diesis_compile(code)
# 		if( Œ∂_verify_syntax(code) ){ @.bufferedCommand = code+'\n' ;@.outputStream.write('    ') ;‚Ü© }
# 		try{ Œπ ‚Üê (0,eval)(Œ∂_compile(code)) }catch(e){ error ‚Üê e }
# 		@.bufferedCommand = ''
# 		if( code ){
# 			œÜ`~/.archive_Œ∂`.text = œÜ`~/.archive_Œ∂`.text + JSON.stringify({ ,time:Time() ,code }) + '\n'
# 			@.In.push(code) ;@.Out.push(error || Œπ)
# 			}
# 		if( error ) @._domain.emit('error' ,error.err || error)
# 		else{
# 			if( T.Promise(Œπ) ) @.context‚Äò.__ .f1Œπ= Œπ
# 			else if( Œπ!==‚àÖ ) @.context.__ = Œπ
# 			try{ t ‚Üê Œ∂_inspect(Œπ,{ colors:@.outputStream.isTTY }) }catch(e){ t ‚Üê '<repl inspect failed>:\n'+(e&&e.stack) }
# 			@.outputStream.write(t && t+'\n') }
# 		@.displayPrompt()
# 		})
# 	@.removeAllListeners('SIGINT').on('SIGINT',Œª(){
# 		is_line ‚Üê @.bufferedCommand+@.line
# 		@.clearLine()
# 		if( is_line ){ @.bufferedCommand = '' ;@.displayPrompt() } else @.close()
# 		})
# 	delete @.context._ ;@.context._ = _u
# 	‚Ü© @ }) }
