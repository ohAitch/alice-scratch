â§«. moon ==> Î¹=>{ Î¹||(Î¹=Time()) ;m â† [â€¦'ğŸŒ‘ğŸŒ’ğŸŒ“ğŸŒ”ğŸŒ•ğŸŒ–ğŸŒ—ğŸŒ˜'] ;ph â† npm`suncalc@1.7.0`.getMoonIllumination(Î¹).phase ;â†© m[round(ph*m.â€–)%m.â€–] }

##################################### parse ####################################
â§«. regex_set ==> Î¹=>{
	# ! low quality ,scrap
	Î¹ = (Î¹+'').replace(/\n$/,'')
	tâ†[] ;[â€¦[â€¦Î¹].âˆª([])]._.sortBy().map(Î¹=>{ Î¹ = ord(Î¹) ;t[-1]&&t[-1][1] === Î¹-1? (t[-1][1] = Î¹) : t.push([Î¹,Î¹]) })
	x â† Î¹=>{ Î¹ = chr(Î¹) ;â†© {'-':1,']':1,'\\':1}[Î¹]? '\\'+Î¹ : Î¹==="'"? Î¹ : node.util.inspect(Î¹).slice(1,-1).replace(/\\u00/g,'\\x') }
	Î¹ = t.map(Î¹=> Î¹[0] === Î¹[1]? x(Î¹[0]) : Î¹[0] === Î¹[1]-1? x(Î¹[0])+x(Î¹[1]) : x(Î¹[0])+'-'+x(Î¹[1]) ).join('')
	â†© Î¹ }

â§«. schema ==>{
	sc_merge â† (a,b)=>{ ak â† _u.keys(a) ;bk â† _u.keys(b) ;bk.-(ak).forEach(k=> a[k] = b[k]) ;ak.âˆ©(bk).forEach(k=> a[k] = !Tprim(a[k])? sc_merge(a[k],b[k]) : !Tprim(b[k])? 'error' : a[k]) ;â†© a }
	â†© Î¹=> T.boolean(Î¹)? âœ“ : Tstr(Î¹)? '' : Tnum(Î¹)? 0 : Tarr(Î¹)? !Î¹.â€–? [] : [Î¹.map(schema).fold(sc_merge)] : _u.pairs(Î¹).map(Î¹=> [Î¹[0],schema(Î¹[1])])._.object()
	}

#################################### numeric ###################################
â§«. numeric2 ==>{
	nk â† npm`numeric@1.2.6`
	norm01 â† Î¹=> normâˆ(nk.sub( Î¹ ,Î¹.fold(nk.min.XX) ))
	normâˆ â† Î¹=> nk.div( Î¹ ,Î¹.fold(nk.max.XX) )
	norm1 â† Î¹=> nk.div( Î¹ ,Î¹.fold(nk.add.XX) )
	L2 â† (a,b)=> _.zip(a,b).map(([a,b])=> (a-b)^2 ).fold(nk.add.XX) ^(1/2)
	mean â† Î¹=> nk.diveq( Î¹.fold(nk.add.XX) ,Î¹.â€– )
	normâˆ_affine_sorted_E â† Î¹=>( nk.subeq(Î¹,Î¹[0]) ,nk.diveq(Î¹,Î¹[-1]) )
	infer0 â† (Î¹,x)=>{ x *= Î¹.â€–-1 ;i â† x|0 ;x â† x%1 ;Î¹ â† [Î¹[i%Î¹.â€–],Î¹[(i+1)%Î¹.â€–]] ;â†© nk.add(â€¦_u.zip(Î¹,[1-x,x]).map(Î¹=>nk.mul(â€¦Î¹))) }
	â†© {,nk,norm01,normâˆ,norm1,mean,normâˆ_affine_sorted_E,infer0,L2} }
â§«. normal_PDF ==> x=>{ Î¼ â† 0 ;Ïƒ â† 1 ;v â† Ïƒ**2 ;â†© 1/sqrt(v*Ï„)*exp(-((x-Î¼)**2)/(2*v)) }
â§«. normal_CDF ==> x=>{ Î¼ â† 0 ;Ïƒ â† 1 ;â†© (1 + npm`math-erf@1.0.0`( (x-Î¼) / (Ïƒ*sqrt(2)) ))/2 }

##################################### color ####################################
â§«. color ==>{
	color â† npm`color@2.0.1`
	color.interpolate_0 = (c,x)=>{ x *= c.â€– ;i â† x|0 ;â†© c[i%c.â€–].mix(c[(i+1)%c.â€–] ,x%1) }
	color.interpolate_1 = (c,x)=>{ x *= c.â€–-1 ;i â† x|0 ;â†© c[i%c.â€–].mix(c[(i+1)%c.â€–] ,x%1) }
	color.prototypeâ€˜.i .get= Î»(){ Î¹ â† @.rgb().color ;â†© ( Î¹[0]<<24 | Î¹[1]<<16 | Î¹[2]<<8 | 0xff )>>>0 }
	IN â† Î¹=> color(Î¹).lab() |>(Î¹=> [â€¦Î¹.color,Î¹.valpha])
	UN â† Î¹=> color.lab(â€¦Î¹)
	color.infer0 = (c,x)=> numeric2.infer0(c.map(IN),x)|>(UN)
	â†© color }

# ###################################### seq #####################################
# ğ…¯ğ…©ğ…ªğ…¨ğ…ƒ â† Î»*(Î¸){ for(;Î¸.i<Î¸.l.â€–;) yield Î¸.l[Î¸.i++] }
# Î³.seq = Î¹=>{
# 	r â† new_(seq)
# 	if( Tarr(Î¹) ){ ;r.Î¹ = ğ…¯ğ…©ğ…ªğ…¨ğ…ƒ(r) ;r.i = 0 ;r.l = Î¹ }
# 	else if( !Î¹.next ) r.Î¹ = Î¹.@@iterator()
# 	else r.Î¹ = Î¹
# 	â†© r }
# seq.prototype = {
# 	,Î¹:âˆ… ,i:âˆ… ,l:âˆ…
# 	,map:Î»*(f){ for(tâ† of @.Î¹) yield f(t) }
# 	# ,'mapâ€¦':Î»(){} ,fold(){} ,Ã—(){} ,filter(){} ,pin(){} ,find_(){} ,slice(){} ,'â€–':Î»(){} ,some(){} ,every(){}
# 	,get next_Î¹(){â†© @.Î¹.next().value }
# 	,get next_Î¹Î¹(){ t â† @.Î¹.next() ;if( t.done )â†© ;t = t.value ;t===âˆ… && â€½ ;â†© t }
# 	,get clone(){ tâ† seq(@.l) ;t.i= @.i ;â†© t }
# 	}
# seq.cartesian = (â€¦Î¹)=> ğ…®ğ…‹ğ…®ğ…¯(Î¹) ;ğ…®ğ…‹ğ…®ğ…¯ â† Î»*(Î¹,i=0){ if( Î¹.length-i===0 ) yield [] ;else for(bâ† of Î¹[i]) for(câ† of ğ…®ğ…‹ğ…®ğ…¯(Î¹,i+1)) yield [b,â€¦c] }
# Î³.cartesian = (â€¦Î¹)=> [â€¦seq.cartesian(â€¦Î¹)]
# # (Î»*(){ yield 5 })().next()
# # Object.getOwnPropertyDescriptors([â€¦protos(Î»*(){}())][2])
# # [â€¦protos(Set())].map(Object.getOwnPropertyDescriptors)
# # [â€¦protos(Set().@@iterator())].map(Object.getOwnPropertyDescriptors)
# # ok,,,, the cloneability property desired here is fundamentally impossible .yay

# Î³.â‹¯ = Î¹=> _l.range(Î¹)
# Î³.â‰ˆ = (a,b)=> _l.isEqualWith(a,b,(a,b)=> T.Buffer(a) && T.Buffer(b)? a.equals(b) : âˆ… )
# Î³.â‰‰ = (a,b)=> ! â‰ˆ(a,b)
# Î³.zip_min = (a,b)=> _l.zip( a.â€–>b.â€–? a.slice(0,b.â€–) : a , a.â€–<b.â€–? b.slice(0,a.â€–) : b )

# Â§`{Array Set Map}.prototype._ :`{ get(){â†© _u(@)} }

# # link: it.Î¶
# Â§`{Array Buffer String Function}.prototype.â€– :`{ get(){â†© @.length } }
# Â§`{Set Map}.prototype.â€– :`{ get(){â†© @.size } }

# # goal: replace `map` with `â‰«` everywhere .implementation slowed in hope for clarity wrt lists in the future of See
# # 'Array.prototype.map'
# # ,'Buffer.prototype.map':Î»(f){ r â† Buffer.alloc(@.â€–) ;for(iâ†0;i<@.â€–;i++) r.push(f(@[i])) ;â†© r } does not even work
# Set.prototype.map = Î»(f){â†© [â€¦@].map(f) }
# Map.prototype.map = Î»(f){â†© [â€¦@.entries()].map(([i,Î¹])=> f(Î¹,i,@)) }
# Number.prototype.map = Î»(f){'use strict' ;Î¹â†+@ ;r â† Array(Î¹) ;for(iâ†0;i<Î¹;i++) r[i] = f(i,i,Î¹) ;â†© r }

# Array.prototype.map_ = Array.prototype.map
# Set.prototype.map_ = Î»(f){â†© new Set([â€¦@].map(f)) }
# Map.prototype.map_ = Î»(f){â†© new Map([â€¦@.entries()].map(f)) }

# Â§`{Set Map}.prototype.some :`Î»(f){â†© [â€¦@].some(f) }
# Â§`{Set Map}.prototype.every :`Î»(f){â†© [â€¦@].every(f) }

# Array.prototype.mapâ€¦ = Î»(f){ r â† [] ;for(iâ†0;i<@.â€–;i++) r.push(â€¦f(@[i],i,@)) ;â†© r }
# Â§`{Set Map Number}.prototype.mapâ€¦ :`Î»(f){â†© @.map(f).â€¦ }

# Set.prototype.filter = Î»(f){â†© Set(â€¦[â€¦@].filter(f)) }

# Array.prototype.edge_comple = Î»(f){ ğ…ƒğ…â†{}; r â† [] ;for(Î¹â† of @){ t â† f(Î¹) ;t===ğ…ƒğ… ||( ğ…ƒğ…= t ,r.push([]) ) ;r[-1].push(Î¹) } ;â†© r }
# Set.prototype.partition = Î»(f){â†© _u([â€¦@]).partition(f).map(Î¹=> Set(â€¦Î¹)) }

# Array.prototypeâ€˜['â€¦'] .host= { get(){â†© @.mapâ€¦(Î¹=>Î¹) } }

# Array.prototype.fold = Array.prototype.reduce
# Array.prototype.foldr = Array.prototype.reduceRight

# Array.prototype.repeat = Î»(x){â†© x<=0? [] : x.mapâ€¦(=> @) }
# Buffer.prototype.repeat = Î»(x){â†© Buffer.concat(x<=0? [] : x.map(=> @)) }

# # ,'String.prototype.trim':Î»(Î¹=/\s+/)){â†© @.replace(re`^${Î¹}|${Î¹}$`.g,'') }
# Array.prototype.trim = Î»(Î¹){ a â† @[0]===Î¹ ;b â† @[-1]===Î¹ ;â†© !(a||b)? @ : @.slice( a?1:0 ,b?-1:@.â€– )}

# String.prototype.Ã— = String.prototype.repeat
# Array.prototype.Ã— = Î»(x){â†© 0?0
# 	: Tnum(x)? x<=0? [] : x.mapâ€¦(=> @)
# 	: Tarr(x)? @.mapâ€¦(a=> x.map(b=> [a,b] ))
# 	: â€½ }
# Buffer.prototype.Ã— = Î»(x){â†© Buffer.concat(x<=0? [] : x.map(=> @)) }

# Set.prototype.join = Î»(Î¹){â†© [â€¦@].join(Î¹) }

# Â§`{Array Buffer String Set}.prototype.count :`Î»(){ r â† new Map() ;for (tâ† of @) r.set(t ,(r.has(t)? r.get(t) : 0)+1 ) ;â†© r }
# Â§`{Array Buffer String Set}.prototype.group :`Î»(f){ f||(f = Î¹=>Î¹) ;r â† new Map() ;for (tâ† of @){ ;t2 â† f(t) ;t3 â† r.get(t2) ||( r.set(t2,t3=Set()) ,t3 ) ;t3.add(t) } ;â†© r }
# Â§`{Array Buffer String Set}.prototype.group_uniq :`Î»(f){ f||(f = Î¹=>Î¹) ;r â† new Map() ;for (Î¹â† of @){ t â† f(Î¹) ;r.has(t) && â€½ ;r.set(t,Î¹) } ;â†© r }
# Â§`{Array Buffer String Set}.prototype.group_uniq_reduce :`Î»(f){ f||(f = Î¹=>Î¹) ;r â† new Map() ;for (tâ† of @) r.set(f(t),t) ;â†© r }

# Map.prototype.zip = Î»(â€¦a){ a.unshift(@) ;r â† new Map() ;a.forEach((Î¹,i)=> Î¹.forEach((Î¹,k)=>{ t â† r.get(k) || [âˆ…].Ã—(a.â€–) ;t[i] = Î¹ ;r.set(k,t) })) ;â†© r }
# # ! what is this? what does it do?

# Â§`{Array Buffer String}.prototype.chunk :`Î»(L){â†© _l.range(0,@.â€–,L).map(i=> @.slice(i,i+L)) }
# Â§`{Array Buffer String}.prototype.windows :`Î»(L){â†© (@.â€–-L+1).map(i=> @.slice(i,i+L)) }
# Â§`{Array Buffer String}.prototype.'-1' :`{get(){â†© @.â€–<1? âˆ… : @[@.â€–-1] },set(Î¹){ @.â€–<1 || (@[@.â€–-1] = Î¹) }}
# Â§`{Array Buffer String}.prototype.'-2' :`{get(){â†© @.â€–<2? âˆ… : @[@.â€–-2] },set(Î¹){ @.â€–<2 || (@[@.â€–-2] = Î¹) }}
# Â§`{Array Buffer String}.prototype.'-3' :`{get(){â†© @.â€–<3? âˆ… : @[@.â€–-3] },set(Î¹){ @.â€–<3 || (@[@.â€–-3] = Î¹) }}
# Â§`{Array Buffer String}.prototype.'-4' :`{get(){â†© @.â€–<4? âˆ… : @[@.â€–-4] },set(Î¹){ @.â€–<4 || (@[@.â€–-4] = Î¹) }}

# Â§`{Array Set}.prototype.'âˆª' :`Î»(â€¦a){â†© new Set([@,â€¦a].â€¦) }
# Â§`{Array Set}.prototype.'âˆ©' :`Î»(â€¦a){ r â† new Set(@) ;for(xâ† of a){ x = T.Set(x)? x : new Set(x) ;for(Î¹â† of r) x.has(Î¹) || r.delete(Î¹) } ;â†© r }
# Â§`{Array Set}.prototype.'-' :`Î»(â€¦a){â†© new Set(@).-!(â€¦a) }
# Â§`{Array Set}.prototype.'âŠ•' :`Î»(b){aâ†@ ;â†© a.-(b).âˆª(b.-(a)) }
# Â§`{Array Set}.prototype.'âˆª!' :`Î»(â€¦a){ for(bâ† of a) for(Î¹â† of b) @.add(Î¹) ;â†© @ }
# # Â§`{Array Set}.prototype.'âˆ©!' :`Î»(â€¦a){
# Â§`{Array Set}.prototype.'-!' :`Î»(â€¦a){ for(tâ† of a) for(Î¹â† of t) @.delete(Î¹) ;â†© @ }
# # Â§`{Array Set}.prototype.'âŠ•!' :`Î»(â€¦a){

# Map.prototype.hasâ€¦ = Î»(â€¦as){Î¹â†@ ;as.â€–>=1||â€½ ;_1 â† as.pop() ;for(aâ† of as){ if(!Î¹.has(a))â†© ;Î¹ = Î¹.get(a) } ;â†© Î¹.has(_1) }
# Map.prototype.getâ€¦ = Î»(â€¦as){Î¹â†@ ;for(aâ† of as){ if(!Î¹.has(a))â†© ;Î¹ = Î¹.get(a) } ;â†© Î¹ }
# Map.prototype.setâ€¦ = Î»(â€¦as){tâ†;Î¹â†@ ;as.â€–>=2||â€½ ;v â† as.pop() ;_1 â† as.pop() ;for(aâ† of as) Î¹ = Î¹.has(a)? Î¹.get(a) : (Î¹.set(a,t=new Map()),t) ;Î¹.set(_1,v) ;â†© v }
# # Map.prototype.| = Î»(f){â†© ((â€¦Î¹)=> @.hasâ€¦(â€¦Î¹)? @.getâ€¦(â€¦Î¹) : f(â€¦Î¹)) â€¦â†([@,f]) â€¦â†({setâ€¦:(â€¦Î¹)=>@.setâ€¦(â€¦Î¹)}) }

# Â§`{Set Map}.prototype.filter! :`Î»(f){ @.forEach((Î¹,i)=> f(Î¹,i,@) || @.delete(i)) }
# Set.prototype.pop = Î»(){ t â† @[0] ;@.delete(t) ;â†© t }
# Set.prototypeâ€˜[0] .host= {get(){â†© seq(@).next_Î¹ }}
# Â§`{Array Set}.prototype.'-eq' :`Î»(â€¦a){ t â† _u([â€¦@]).groupBy(simple_flesh) ;a.forEach(.forEach(Î¹=> delete t[simple_flesh(Î¹)])) ;â†© _l.values(t).â€¦ }

# Î³.Î”set = (a,b)=> new Map([ ,â€¦ a.-(b).map(Î¹=>[Î¹,-1]) ,â€¦ b.-(a).map(Î¹=>[Î¹,1]) ]) # assume uniq
# Î³.objectâ‰«0 = (o,i_s,f)=> Object.create(o) â€¦â†(i_s.map(i=>[ i ,(â€¦a)=> f(o[i](â€¦a),i,o) ])._.object())
# Set.prototype.Î” = Î»(f){â†© objectâ‰«0(@,alt_ws`add clear delete`,Î¹=>{ f(@) ;â†© Î¹ }) }

# Map.prototypeâ€˜['â»Â¹uniq'] .host= {get(){â†© new Map([â€¦@.entries()].map(([a,b])=>[b,a])) }}
# Map.prototypeâ€˜['â»Â¹'] .host= {get(){â†© [â€¦@.keys()].group(Î¹=> @.get(Î¹)) }}

# Array.prototype.find_ = Î»(f){ râ†; if( @.some(Î»(Î¹,i,o){tâ†; if( (t= f(Î¹,i,o))!==âˆ… ){ r = [i,Î¹,t] ;â†© âœ“ } })) â†© r }
# Array.prototype.find_index_deep = Î»(f){
# 	for(iâ†0;i<@.â€–;i++){ Î¹ â† @[i]
# 		if( Tarr(Î¹)){ t â† Î¹.find_index_deep(f) ;if( t) â†© [i,â€¦t] }
# 		else{ if( f(Î¹) )â†© [i] }
# 		} }
# Array.prototype.find_last_index = Î»(f){ for(iâ†@.â€–-1;i>=0;i--) if( f(@[i],i,@) ) â†© i }
# Array.prototype.join_ = Î»(â€¦s){ râ† [] ;_0â† âœ“ ;for(tâ† of @) _0?( _0= âœ— ,r.push(t) ): r.push(â€¦s,t) ;â†© r }

# ################################################################################
# Î³ â€¦â†(_u(Math).pick('abs','ceil','exp','floor','log10','log2','max','min','round','sqrt','cos','sin','tan'),{ ,ln:Math.log ,Ï€:Math.PI ,Ï„:Math.PI*2 ,e:Math.E ,'âŸ':Math.log })
# Î³.ğŸ² = Î»(Î¹){â†© arguments.length===0? Math.random() : Tnum(Î¹)? ğŸ²()*Î¹ |0 : _l.sample(Î¹) }
# Î³â€˜.ğŸ²id .thunk==>{
# 	t â† Î±Î²=> (L=> L.map(=> ğŸ²(Î±Î²)).join('')) â€¦â† ({Î±Î²})
# 	ğŸ²id â† t([â€¦/[0-9a-z]/])
# 	ğŸ²id.braille = t([â€¦re`[â -â£¿]`])
# 	ğŸ²id.greek = t([â€¦'ğ…‚ğ…ƒğ…‹ğ…œğ…ğ…ğ…¦ğ…¨ğ…©ğ…ªğ…«ğ…¬ğ…­ğ…®ğ…¯ğ…°'])
# 	â†© ğŸ²id }
# Î³â€˜.anon .get==> ğŸ²id.greek(4)

# Î³.ord = (Î¹,i)=> Tnum(Î¹)? Î¹ : Î¹.codePointAt(i)
# Î³.chr = Î¹=> Tstr(Î¹)? Î¹ : String.fromCodePoint(Î¹)

