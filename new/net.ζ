##################################### glue #####################################
# # deprecated
# Î³.GET_L = (Î¹,within)=> ğ…­ğ…‚ğ…­ğ…ª(['GET -L' ,Î¹+''] ,within ,=> sháµ¥`curl -sL ${Î¹}`)
# 	ğ…­ğ…‚ğ…­ğ…ª â† (names,within,f)=>{
# 		dir â† Ï†`~/file/.cache/memo_frp/${names}`
# 		if( within ){
# 			try{ t â† node.fs.readdirSync(dir+'') }catch(e){ e.code==='ENOENT' || â€½(e) ;t â† [] }
# 			now â† Time().i ;t = t.sort().filter(Î¹=> Time(Î¹.re`^\S+`[0]).i >= now - within )[-1]
# 			if( t ) â†© dir.Ï†(t).json2.Î¹ }
# 		a â† Time().ymdhmss ;Î¹ â† f() ;b â† Time().ymdhmss
# 		dir.Ï†`${a} ${ğŸ²id(10)}`.json2 = { ,names ,date:[a,b] ,Î¹ } ;â†© Î¹ }

################################################################################
â§«. lock ==>{
	fs â† node.fs ;util â† node.util
	;fs_close â† util.promisify(fs.close) ;fs_unlink â† util.promisify(fs.unlink) ;fs_open â† util.promisify(fs.open)
	locks â† {}
	ğ…¨ğ…¯ â† id=> Ï†`/tmp/lock_${id}`+''
	â™“_on_exits(=> _u.keys(locks).map(id=>{ try{ fs.unlinkSync(ğ…¨ğ…¯(id)) }catch(e){} }) )
	lock â† (id,opt)=> fs_open(ğ…¨ğ…¯(id),'wx').then(
		,fd=>( locks[id] = âœ“ ,fs_close(fd).then(=> =>lock.un(id) ) )
		,e=>{ T.Error(e) || â€½ ;opt||(opt={}) ;'wait' in opt ||(opt.wait = 0)
			if(!( e.code==='EEXIST' && opt.wait > 0 )) â†© Î (e)
			else{ w â† min(opt.wait,0.1) ;opt.wait -= w ;â†© (=> lock(id,opt)).in_Î (w) }
			} )
	lock.un = id=>( delete locks[id] ,fs_unlink(ğ…¨ğ…¯(id)) )
	lock.âˆƒ = id=> fs_open(ğ…¨ğ…¯(id),'r').then(
		,fd=>( fs.close(fd) ,âœ“ )
		,e=> e.code==='ENOENT'? âœ— : Î (e) )
	â†© lock }

â§«. stream4 ==>{ E â† {}
	E.send_json = memoize_weak(s=>{ ;t â† npm`through2@2.0.3`.obj((Î¹,Ë£,cb)=>cb(âˆ…,JSON.stringify(Î¹)+'\n')) ;t.pipe(s) ;â†© tâ€˜.write .f })
	E.as_json = memoize_weak(s=>{ ;t â† npm`split2@2.2.0`(Î¹=>{ try{â†© JSON.parse(Î¹) }catch(e){ @.emit('error',e) } }) ;s.pipe(t) ;â†© t.P`data` })
	â†© E }

â§«. net1 ==>{ E â† {}
	E.open_send = at=> Î ((yes,no)=>{ if(! at )â†© no() ;r â† new node.net.Socket() ;r.unref().on('error',no).connect(at).on('connect',=>yes(r)) })
	E.device_listen = (port=0)=>{ r â† new node.net.Server().listen(port,'localhost') ;â†© r.Î `listening`.then(=> r) }
	node.net.Server.prototype.just_first_json = Î»(){â†© @.Î `connection`.then(s=> stream4.as_json(s).Î .then(Î¹=>{ ;s.end() ;@.close() ;â†© Î¹ })) }
	node.net.Server.prototypeâ€˜.at .get= Î»(){tâ† ;â†© @.ğ…­ğ…ğ…¯ğ…¨ğ…‹||(@.ğ…­ğ…ğ…¯ğ…¨ğ…‹= [(t=@.address()).address,t.port]) }
	E._0_Ï†_seenbydevice0 = Î¹=>{ t â† @device0buf('ğ…¦ğ…¯ğ…­ğ…ª_'+Î¹) ;â†© t.o.âˆƒ? Î (t) : Î (yes=> npm`simple-get@2.7.0`.concat(Î¹,(e,r,Î¹)=>{ t.Î¹ = Î¹ ;yes(t) }) ) }
	E._0_Ï†_seenbydevice0â»Â¹ = => node.fs.readdirSync(device0_n1_dir).filter(.re`^ğ…¦ğ…¯ğ…­ğ…ª_`).map(Î¹=> device0_n1_dir+'/'+Î¹)
	â†© E }

â§«. Î  ==> Î¹â‡’
	: Tfun(Î¹) && /^(re|yes|\(yes,no\))=>/.test(Î¹+'')? new Promise(Î¹)
	: T.Error(Î¹)? Î x(Î¹)
	: Promise.resolve(Î¹)
â§«. Î x ==> Î¹=> Promise.reject(Î¹)
â§«. Î and ==> (â€¦Î¹)=> Promise.all( Î¹.â€–===1? Î¹[0] : Î¹ )
â§«. Î or ==> (â€¦Î¹)=> Promise.race( Î¹.â€–===1? Î¹[0] : Î¹ )

â§«. @deviceÎ  ==> Î¹=>{ start â† Tfun(Î¹)
	id â† !start? Î¹ : ğŸ²id.greek(9)
	ğ… â† @device0('Î '+id)
	re â† (Î¹=>{ ğ….Î¹ = Î¹ }) â€¦â†({ ,id ,toString:=>r+'.re' })
	r â† { ,id ,re ,toString:=>Î¶js`@deviceÎ (${id})` } !>(â€˜.Î  .get==> poll1_simple(=> ğ….Î¹))
	start && Î¹(re)
	â†© r }
