P ← npm`parsimmon@0.9.2`
P_ ← (ι,…a)=> Tfun(ι)? P.lazy(ι,…a) : Tstr(ι)? P.string(ι) : P.regex(ι,…a)

S_eval ← ι=>
	Tprim(ι) || T.RegExp(ι)? ι :
	ι.T==='set'?
		T.RegExp(ι.ι)? ι.ι.genex_0() :
			‽ :
		‽

S_inspect ← ι=> JSON.stringify(ι)

S_compile ← λ(src){
	wso ← P_(/\s*/)
	wsd ← p=> wso.then(p).skip(wso)
	expr ← P_(()=> wsd(P.alt(
		P_('{').then(expr).skip(P_('}')).map(ι⇒ {T:'set',ι}),
		P_(/\d+/).map(ι=> ι|0),
		P_(/\/((\[[^\]]*\]|\\.|[^/\n])*)\//,1).map(ι=> RegExp(ι)),
		P.fail('‽') )) )
	root ← P.seqMap(P_('°').or(P.of('')), expr, λ(is_macro,ι){ ↩ {is_macro,ι} })
	ι ← root.parse(src)
	ι.status || ‽('§ tried to parse '+util.inspect(src)+' and got '+util.inspect(ι))
	ι = ι.value
	ι = ι.is_macro? S_inspect(S_eval(ι.ι)) : ‽
	↩ ι }

module.exports = S_compile
if (!module.parent) cn.log(ζS_compile(φ`/Users/home/file/code/scratch/§/index.ζ§`.text))
