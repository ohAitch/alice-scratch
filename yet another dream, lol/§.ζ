#!/usr/bin/env ζ
# @2017-09-11 gutted boring parts

// ---------------------------------- parse --------------------------------- //
P ← require_new(φ`~/code/scratch/ζ/parsimmon2.ζ`)

WS ← P(/\s*/)
P.proto.type = λ(T){↩ @.map(ι=> AST(T,{ι}) ) }
P_spaced ← p=> P.seq_map(WS,p,WS,(a,ι,b)=> a||b? AST(' ',{a,ι,b}) : ι)
// P_spaced ← p=> P.seq_map(ws,p,ws,(a,ι,b)=> a||b? AST(' ',[a,O`ι`,b],{ι}) : ι); ws ← P(/\s*/)

// {ws syn ws NODE syn ws NODE ws} ws ws {NODE syn NODE {syn syn} ws}


op_ps ← {
	'1 left':λ(ops_p,next_p){ r ← P(()=> P.seq_map(ops_p, r, (op,ι)=> AST('op',{A:'1 left', op, ι})).or(next_p) ); ↩ r },
	'1 right':(ops_p,next_p)=> P.seq_map( next_p, ops_p.many(), (x,r)=> r.reduce((ι,op)=> AST('op',{A:'1 right', op, ι}), x) ),
	// binary left: 1-2-3 = (1-2)-3 ; binary right: 1^2^3 = 1^(2^3)
	'2 left':(ops_p,next_p)=> P.seq_map( next_p, P.seq(ops_p,next_p).many(), (x,r)=> r.reduce((a,[op,b])=> AST('op',{A:'2 left', op, a, b}), x) ),
	'2 right':λ(ops_p,next_p){ r ← P(()=> next_p.chain(a=> P.seq_map(ops_p, r, (op,b)=> AST('op',{A:'2 right', op, a, b}) ).or(P.of(a)) ) ); ↩ r },
	'2 center':(ops_p,next_p)=> P.seq_map( next_p, P.seq(ops_p,next_p).many().flat(), (a,op_bs)=> !op_bs.length? a : AST('op',{A:'2 center', ι:[a, …op_bs]}) ),
	}
P_build_operators ← (unit,ops)=> ops.reduce((x,ι)=> op_ps[ι[0]]( P.alt(…ι.slice(1).map(P.X)), x ), unit)

parse ← (λ(){
	expr_unit ← P(()=> P.alt(
		P('⧫').type('MISSING'),
		P(/\d+(?:\.\d+)?/).type('number'),
		P(/\/((\[[^\]]*\]|\\.|[^/\n])*)\//).type('regex'),
		P.seq( P('{'), WS, expr, WS, P('}') ).map(ι=> AST('set',{ι})),
		P.seq( P('['), WS, …P.seq( expr,WS,P(/,?/),WS ).many().flat(), P(']') ).map(ι=> AST('array',{ι})),
		P.fail('‽') ) )
	expr ← P_build_operators(expr_unit,[
		// precedence
		['2 right','^'],
		['1 left','×','÷'],
		['2 left','×','÷'],
		['1 left','*'],
		['2 left','*'],
		// ['2 left','+','-'],
		// ['1 left','-'],
		['2 center','=','≠','<','>','≤','≥'],
		['1 right','!'],
		])
	// root ← P.seq_map(P('°').or(P.of('')), expr, λ(is_macro,ι){ ↩ is_macro? {is_macro__bad:true, ι} : ι })
	root ← P.seq(P('°').or(P.of('')), WS, expr, WS).map(ι=> AST('macro?',{ι}))
	↩ λ(src){ ι ← root.parse(src); ι.status || ‽('§ tried to parse',[src],'and got',ι); ↩ ι.value } })()

// -------------------------------------------------------------------------- //
// module.exports = ι=> ast_to_js(parse(ι))
if (!module.parent){
srcs ← [
	'° {/[0-9a-z]/} ',
	// ' * ÷16 ',
	' ⧫ * ⧫÷16 ',
	'[0! 1, 2.5, ]',
	'5 < 7 = 7 ≤ 9^2^3 > 2',
	]
srcs.map(ι=> cn.log`parse(${ι}) = ${parse(ι)}`)
cn.log('testing recursion')
srcs.map(λ(ι){
	ι = [ι]; q ← ()=> ι.push(Tstr(ι[-1])? parse(ι[-1]) : ast_to_S(ι[-1])); q(); q(); q()
	_.isEqual(ι[0],ι[2]) ||( cn.log`${ι[0]} ≠ ${ι[2]}`, ‽('fail02') )
	_.isEqual(ι[1],ι[3]) ||( cn.log`${ι[1]} ≠ ${ι[3]}`, ‽('fail13') )
	})
cn.log('pass')
}

// -------------------------------------------------------------------------- //
‡ to get this to self-optimize, the ∄ fn needs to be told in advance how many times it''s going to get run? i think? so that it can know it has that much optimization budget?
‡ the concept here is, autoindexing
diff(a,b ∈ φ)=>
	using ansi_color
	if a,b are file:
		full ← shᵥ`wdiff -n -w ${black.bg_red} -x ${reset} -y ${black.bg_green} -z ${reset} ${a} ${b} ;:` as lines * {ι,i}
		full replace (x+ : ∄ ∈full : .ι≈color & abs(.i - x.i) ≤ 3) with '-'
			* (='-'? dark_grey('-'×30) : dark_grey(.i+1)+' '+.ι)
	else:
		A,B ← a,b flat
		same(x)=> a,b +x .data =
		[ B-A,green`+` , A-B,red`-` , A∩B∩same,grey`=` , A∩B-same,cyan`x` ] *… [l,t]=> l*{ι,t} sort by .ι * .t+' '+.ι as lines
‡ minus the file branch, expands to ‡

‡ i have to start over with imagining the program i''d rather have written; like, that up there is still way Literal ‡

sep_by_or_end(ι,s)=> ι (s ι)* s?
#function ident '(' structure ')' '=>' expr
#function expr # looks for holes in the expr & those become arguments
#ident
#structure ident (',' structure)? | '[' structure ']'
#expr (\n expr : INDENT > parent.INDENT)+
#expr 'if' ' ' test:expr ':' a:expr 'else:' b:expr
#expr 'using' ' ' ident
#expr expr ' are ' expr
#expr expr ' as ' expr
#expr expr ' * ' function
#expr expr <template string>
#expr expr '.' ident
#expr structure '←' expr
#expr '{' sep_by_or_end(( ident (: expr)? ) ',') '}'
#expr expr ' replace ' expr ' with ' expr
# lots more, very complicated
# the thing is i have a fairly complicated way of saying things!
# it's a mishmash of *all languages*

‡ i wonder if i could mention the primary elements of it ‡

various atoms like 5.7, atoms, 'atoms'
binary ∪ operator    !prefix    postfix[:-1]    using name    things replace pattern with things
whitespace-clued precedence
data structure atoms & structure atoms used for destructuring
code sequence (stackless, stack-based); flow control; errors

# ‡ i've tried that before. it never went anywhere. ‡

# ‡ 

# // -------------------------------------------------------------------------- //
# you were halfway into creating ORM(filesystem, js)
# you didn''t realize what you were really doing
# do the right thing

the right thing is an ORM built out of patterns? doesnt free you from working with the underlying layer; you have to implement patterns and understand pattern implementations; but does free you from having to remember it

storage
* persistent vs not
* simple & complex data structures
* migration strategy
* local vs remote
* isomorphism over dissimilar logical substrate
* many specific data structures
* pseudostorage
* exotic foul apis
