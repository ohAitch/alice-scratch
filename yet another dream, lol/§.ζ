#!/usr/bin/env ζ
########################### <probably uninteresting> ###########################

;{Rᵢ:R} ← require(φ`~/file/code/scratch/fast-parse/record.ζ`+'')
P ← require_new(φ`~/code/scratch/ζ/parsimmon2.ζ`)

WS ← /\s*/

op_ps ← {
	'1 left':λ(ops_p,next_p){ r ← P(()=> P.seq_map(ops_p, r, (op,ι)=> R('op'+op,{ι})).or(next_p) ); ↩ r },
	'1 right':(ops_p,next_p)=> P.seq_map( next_p, ops_p.many(), (x,r)=> r.fold((ι,op)=> R('op'+op,{ι}), x) ),
	# binary left: 1-2-3 = (1-2)-3 ; binary right: 1^2^3 = 1^(2^3)
	'2 left':(ops_p,next_p)=> P.seq_map( next_p, P.seq(ops_p,next_p).many(), (x,r)=> r.fold((a,[op,b])=> R('op'+op,{a, b}), x) ),
	'2 right':λ(ops_p,next_p){ r ← P(()=> next_p.chain(a=> P.seq_map(ops_p, r, (op,b)=> R('op'+op,{a, b}) ).or(P.of(a)) ) ); ↩ r },
	'2 center':(ops_p,next_p)=> P.seq_map( next_p, P.seq(ops_p,next_p).many().map(ι=> _(ι).flatten(true)), (a,op_bs)=> !op_bs.length? a : R('op',{A:'2 center', ι:[a, …op_bs]}) ),
	}
P_build_operators ← (unit,ops)=> ops.fold((x,ι)=> op_ps[ι[0]]( P.alt(…ι.slice(1).map(P.X)), x ), unit)

parse ← (λ(){
	expr_unit ← P(()=> P.alt(
		P('⧫').map(ι=> R('MISSING',{ι})),
		P(/\d+(?:\.\d+)?/).map(ι=> R('number',{ι})),
		P(/\/((\[[^\]]*\]|\\.|[^/\n])*)\//).map(ι=> R('regex',{ι})),
		P.seq( P('{'), WS, expr, WS, P('}') ).map(ι=> R('set',{ι})),
		P.seq( P('['), WS, P.seq( expr,WS,P(/,?/),WS ).many().map(ι=> _(ι).flatten(true)), P(']') ).map(ι=> R('array',{ι})),
		P.fail('‽') ) )
	expr ← P_build_operators(expr_unit,[
		# precedence
		['2 right','^'],
		['1 left','×','÷'],
		['2 left','×','÷'],
		['1 left','*'],
		['2 left','*'],
		# ['2 left','+','-'],
		# ['1 left','-'],
		['2 center','=','≠','<','>','≤','≥'],
		['1 right','!'],
		])
	↩ λ(src){ ↩ expr.parse(src) } })()

################################################################################
if (!module.parent){
srcs ← [
	'{/[0-9a-z]/}*5',
	# ' * ÷16 ',
	# ' ⧫ * ⧫÷16 ',
	# '[0! 1, 2.5, ]',
	# '5 < 7 = 7 ≤ 9^2^3 > 2',
	]
srcs.map(ι=> cn.log`parse(${ι}) = ${parse(ι)}`)
# cn.log('testing recursion')
# srcs.map(λ(ι){
# 	ι = [ι]; q ← ()=> ι.push(Tstr(ι[-1])? parse(ι[-1]) : ast_to_S(ι[-1])); q(); q(); q()
# 	_.isEqual(ι[0],ι[2]) ||( cn.log`${ι[0]} ≠ ${ι[2]}`, ‽('fail02') )
# 	_.isEqual(ι[1],ι[3]) ||( cn.log`${ι[1]} ≠ ${ι[3]}`, ‽('fail13') )
# 	})
# cn.log('pass')
}

########################### </probably uninteresting> ##########################

# // -------------------------------------------------------------------------- //
# ‡ to get this to self-optimize, the ∄ fn needs to be told in advance how many times it''s going to get run? i think? so that it can know it has that much optimization budget?
# ‡ the concept here is, autoindexing
# diff(a,b ∈ φ)=>
# 	using ansi_color
# 	if a,b are file:
# 		full ← shᵥ`wdiff -n -w ${black.bg_red} -x ${reset} -y ${black.bg_green} -z ${reset} ${a} ${b} ;:` as lines * {ι,i}
# 		full replace (x+ : ∄ ∈full : .ι≈color & abs(.i - x.i) ≤ 3) with '-'
# 			* (='-'? dark_grey('-'×30) : dark_grey(.i+1)+' '+.ι)
# 	else:
# 		A,B ← a,b map
# ι=> _(ι).flatten(true#) 		same(x)=> a,b +x .data =
# 		[ B-A,green`+` , A-B,red`-` , A∩B∩same,grey`=` , A∩B-same,cyan`x` ] *… [l,t]=> l*{ι,t} sort by .ι * .t+' '+.ι as lines
# ‡ minus the file branch, expands to ‡
# ‡ i have to start over with imagining the program i''d rather have written; like, that up there is still way Literal ‡

# # sep_by_or_end(ι,s)=> ι (s ι)* s?
# # #function ident '(' structure ')' '=>' expr
# # #function expr # looks for holes in the expr & those become arguments
# # #ident
# # #structure ident (',' structure)? | '[' structure ']'
# # #expr (\n expr : INDENT > parent.INDENT)+
# # #expr 'if' ' ' test:expr ':' a:expr 'else:' b:expr
# # #expr 'using' ' ' ident
# # #expr expr ' are ' expr
# # #expr expr ' as ' expr
# # #expr expr ' * ' function
# # #expr expr <template string>
# # #expr expr '.' ident
# # #expr structure '←' expr
# # #expr '{' sep_by_or_end(( ident (: expr)? ) ',') '}'
# # #expr expr ' replace ' expr ' with ' expr
# # # lots more, very complicated
# # # the thing is i have a fairly complicated way of saying things!
# # # it's a mishmash of *all languages*

# # ‡ i wonder if i could mention the primary elements of it ‡

# # various atoms like 5.7, atoms, 'atoms'
# # binary ∪ operator    !prefix    postfix[:-1]    using name    things replace pattern with things
# # whitespace-clued precedence
# # data structure atoms & structure atoms used for destructuring
# # code sequence (stackless, stack-based); flow control; errors

# # ‡ i've tried that before. it never went anywhere. ‡

# # ‡ 

# # // -------------------------------------------------------------------------- //
# # you were halfway into creating ORM(filesystem, js)
# # you didn''t realize what you were really doing
# # do the right thing

# the right thing is ~~an ORM~~ a mapping built out of patterns? doesnt free you from working with the underlying layer; you have to implement patterns and understand pattern implementations; but does free you from having to remember it

# storage
# * persistent vs not
# * simple & complex data structures
# * migration strategy
# 	‡ that is manipulability?
# * local vs remote
# * isomorphism over dissimilar logical substrate
# * many specific data structures
# * pseudostorage
# * exotic foul apis
