has ← (o,ι)=> Object.prototype.hasOwnProperty.call(o,ι)

P ← require_new(φ`~/code/scratch/ζ/parsimmon2.ζ`)
spaced ← p=> WS.then(p).skip(WS); WS ← P(/\s*/)
expr ← P(=> spaced(P.alt( P(/'([^']*)'/,1).type('string'), P(/[^\s()]+/).type('ident'), P('(').then(expr.many()).skip(P(')')).type('list') )) )
parse ← ι=> expr.parse(ι.replace(/\/\/.*/g,''))

Value ← ι⇒ {T:'value', ι}

eval_ ← (ctx,ι)=>{t←; ↩0,
	ι.T==='string'? Value(ι.ι) :
	ι.T==='ident'? ctx.resolve(ι.ι) :
	ι.T==='list'?( t = eval_(ctx,ι.ι[0]), (t&&t.ι)||‽('tried to call null fn',ι.ι[0],ctx), t = t.ι, t.macro? t.call(ctx,ι.ι.slice(1)) : t.call(ctx,ι.ι.slice(1).map(ι=> eval_(ctx,ι))) ):
		‽ }
ctx ← =>{
	ctx ← { stack:[{vars:{
		'λ':{ macro:✓, call:λ(ctx,a){
			if (a[0].T==='ident'){
				a.length===3 || ‽
				t0 ← parse(`(←)`); t0.ι.push(a[0]); t1 ← parse(`(λ)`); t1.ι.push(…a.slice(1)); t0.ι.push(t1); ↩ eval_(ctx,t0)
			}else{
				a.length===2 || ‽
				[params,code] ← a
				if (_(params.ι[0]).isEqual(parse(`∈`)) && params.ι[1].T==='list' && _(params.ι[1].ι[0]).isEqual(parse(`,`)))
					params.ι = params.ι[1].ι.slice(1).map(ι=>{ t ← parse(`(∈)`); t.ι.push(ι,params.ι[2]); ↩ t })
				↩ Value({call:λ(ctx,a){
					ctx.stack.push({ fn:@, vars:_.zip(params.ι,a).map(([p,ι])=>
						//! oh man, this doesn't combine them at all
						p.T==='ident'? {name:p.ι, ι} :( (p.T==='list' && _(p.ι[0]).isEqual(parse(`∈`))) || ‽, {T:'var', name:p.ι[1].ι, ι, type:p.ι[2]} )
						)._.indexBy('name') })
					//! that is a bit of a weird format, having name diverge from ident
					//! i guess there's a lot of weird
					r ← eval_(ctx,code)
					ctx.stack.pop()
					↩ r }})
			} }, },
		'←':{ macro:✓, call:λ(ctx,a){ name ← a[0].ι; t ← eval_(ctx,a[1]); _(_(t).omit('ι','type','T')).keys().length===0 || ‽; ↩ ctx.stack[-1].vars[name] = _(_(t).pick('ι','type')).assign({T:'var',name}) }, },
		';':{ call:λ(ctx,a){↩ a[-1] }, },
		'list':{ call:λ(ctx,a){↩ Value(a) }, },
		'flat':{ call:λ(ctx,a){ a.length===1||‽; ι ← a[0]
			ι.T==='var' && ι.ι.T==='value' && ι.type.T==='ident' && ι.type.ι==='φ' || ‽(ι)
			↩ Value(φ(ι.ι.ι).TMP_children().map(Value.X))
			}, },
		}._.map((ι,name)⇒ {name,ι})._.indexBy('name')}], }
	ctx.resolve = λ(name){
		for(scope← of @.stack._.clone().reverse()) if (has(scope.vars,name)) ↩ scope.vars[name]
		‽('no var',name,'in',@) }
	↩ ctx }

// 	(using ansi_color)	
// 	(← (, A B) (>> (, a b) flat))
// 	(λ same (x) (>> (, a b) (+ ⧫ x) (. ⧫ data) (= ⧫ ⧫)))
// 	(>> (list
// 		(, (- B A) (green '+'))
// 		(, (- A B) (red '-'))
// 		(, (∩ (∩ A B) same) (grey '='))
// 		(, (- (∩ A B) same) (cyan 'x'))
// 			)
// 		(*… ⧫ (λ (list l t) (* l (object ι t))))
// 		(sort ⧫ by (. ⧫ ι))
// 		(* ⧫ (+ (. ⧫ t) ' ' (. ⧫ l)))
// 		(as ⧫ lines)
// 		)
eval_(ctx(),parse(`(;
(λ diff_dirs (∈ (, a b) φ) (;
	// (← (, A B) (>> (, a b) flat))
	// (list b b a)
	(flat a)

	))
(diff_dirs '/Users/home/Downloads/a' '/Users/home/Downloads/b')
)`))
