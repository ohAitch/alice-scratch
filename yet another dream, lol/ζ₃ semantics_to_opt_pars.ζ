call ← axiom(S⇒{
	syntax(){↩ S`(${@.o} ${@.args})` },
	eval(){
		stack.push({ call:@, vars:new Map(_.zip(@.o.params,@.args).slice(0,@.o.params.‖)), })
		r ← @.o.code.eval()
		stack.pop()
		↩ r },
	})

call
closure
function
js_data
local_slot
member
name
number
object
seq
set_result
string

// ---------------------------------- util ---------------------------------- //
countBy ← ι=>{ r ← new Map(); for (var t of ι) r.set(t, (r.has(t)? r.get(t) : 0)+1 ); ↩ r }

// ast -> bool
interesting ← ι⇒
	: ι.type==='seq'? ι.ι.some(interesting)
	: ι.type==='js_data'? ι.ι !== ∅
	: ✓

// ------------------------- instrumented data types ------------------------ //

// so far just pretty printing
pt ← {
	,inspect(d,opt){t←; r←;
		if (!opt._cache){ t←[]; walk_both_obj(@,ι=> t.push(ι),ι=>0,ι=> t.push(ι)); opt._will_cache = new Set([…t.count()].filter(ι=>ι[1]>1).map(ι=>ι[0])); opt._cache = new Map() }
		if ((t=opt._cache.get(@))!==∅) ↩ opt.stylize('#'+t,'quote')
		if (opt._will_cache.has(@)) opt._cache.has(@) || opt._cache.set(@,opt._cache.‖)

		ty ← opt.stylize(@.type,'special')
		if(_.isEqual( _(@).keys(),['type','ι'] )) r = ty+' '+util.inspect(@.ι,opt)
		else{
			t ← _(_(@).pairs()._.object()).omit('type')
			if (@.found_by && @.ι) t.ι = {inspect(){↩ '...'}}
			t = util.inspect(t,opt); r = t[0]+ty+t.slice(1) }

		↩ ((t=opt._cache.get(@))!==∅? opt.stylize('#'+t,'quote')+'=' : '')+r }
	}
τ ← (type,ι)=> Object.create(pt) <- ({type},ι)
τι ← (type,ι)=> τ(type,{ι})

// -------------------------------------------------------------------------- //
‡ i wish it looked something like this maybe?
‡ you need to actually think about it, i haven't and so what i've written is sketchy and might be bogus
lisp ← (=>{
	P ← require_new(φ`~/code/scratch/ζ/parsimmon2.ζ`)
	ws ← P(/[ \t]*/)
	unit ← P(=> ws.then(P.alt(
		group,
		P(/[0-9][^\s()]*/).map(parseFloat.X).map(ι=> τι('number',ι)),
		P(/'([^]*?)'/,1).map(ι=> τι('string',ι)),
		P(/[^\s()]+/).map(ι=> τι('name',ι))
		)).skip(ws) )
	group ← P('(').then(unit.many()).skip(P(')')).map(ι=> τ('call',{ f:ι[0], a:ι.slice(1) }))
	↩ ι=> unit.parse(ι[0]) })()

make ← type=> a=> τ(type.ι,a)
builtins ← [
	last: lisp`(function a (member a (- (member a 'length') 1)))`,
	function: make`native`((f,a)=> ‽),
	member: make`native`((o,m)=> ‽),
	'-': make`native`((x,y)=> ‽),
	]

call closure function js_data local_private_slot member name number object seq set_result string

‡ ok, yeah; i finished the first part, and now i dont know how to do the next thing, so i gotta think about it
‡ this is hard. might be a job for Aster?

‡ oh! i wanted to have the data flow graph, and then from that be able to easily calculate the price of things, e.g. cpu time, memory
‡ if you calculate the price of everything you do, you can notice that adding a ram cache for an immutable value is cheaper than recomputing it *iff* the price of recomputing it is big enough
‡ prices are easy to calculate in instrumented code, not so easy in native code, but that's okay

‡ is this right? can you flesh out that architecture, like, write out the list of types and native things and prices and everything? make it a new tab.

‡ that sounds right, but it's weird and hard. some more story about how specifically our program is going to optimize parsimmon would be nice. i'm tired.

@2017-03-29 ‡ the correct word for prices and size and such is: quality

// -------------- convert babylon ast into intermediate format -------------- //
vmζ_parse ← code=>{
	// https://github.com/babel/babylon/blob/master/ast/spec.md
	r ← npm`babylon@6.14.1`.parse(ζ_compile(code),{allowReturnOutsideFunction:✓})
	r = walk_obj_edit(r,ι=>{
		// --------------- error on asts i dont know how to handle -------------- //
		ι.directives && ( !ι.directives.‖ || ‽(ι) )
		if (ι.type==='VariableDeclaration') ι.kind==='var' || ‽(ι)
		if (ι.type==='VariableDeclarator') ι.id.type==='name' || ‽(ι)
		if (ι.type==='MemberExpression') (!ι.computed || ι.property.type==='name') || ‽(ι)
		if (ι.type==='ArrowFunctionExpression'||ι.type==='FunctionExpression') ( ι.generator===✗ && ι.async===✗ && ι.params.every(ι=> ι.type==='name') ) || ‽(ι)
		if (ι.type==='BinaryExpression') _(['+','*']).contains(ι.operator) || ‽(ι)
		if (ι.type==='ObjectProperty') ι.method===✗ || ‽(ι)
		// ----------------------- simplify babylon's ast ----------------------- //
		ι = _(ι).omit('start end loc directives leadingComments trailingComments __clone'.split(' '))
		↩ 0?0
		: ι.type==='File'? ι.program
		: ι.type==='Program'? τι('seq',ι.body)
		: ι.type==='VariableDeclaration'? τι('seq',ι.declarations)
		: ι.type==='VariableDeclarator'? τ('local_private_slot',{ name:ι.id, ι:ι.init })
		: ι.type==='Identifier'? τι('name',ι.name)
		: ι.type==='ExpressionStatement'? ι.expression
		: ι.type==='MemberExpression'? τ('member',{ o:ι.object, m: ι.computed? ι.property : τι('js_data',ι.property.ι) })
		: ι.type==='CallExpression'? (=>{ o ← ι.callee; tname←; ↩ 0?0
			: o.type==='member'?
				τ('call',{ o:τ('member',{ o:
					τ('local_private_slot',{ name:tname=τι('name',random_id(5)), ι:o.o }),
					m:o.m }), self:tname, a:ι.arguments })
			: τ('call',{ o, self:τι('js_data',∅), a:ι.arguments })
			})()
		: ι.type==='NumericLiteral'? τι('js_data',ι.value)
		: ι.type==='StringLiteral'? τι('js_data',ι.value)
		: ι.type==='RegExpLiteral'? τι('js_data',RegExp(ι.pattern,ι.flags))
		: ι.type==='ObjectExpression'? τι('object',ι.properties.map(ι=>[ ι.computed? ι.key : τι('js_data',ι.key.ι), ι.value ]))
		: ι.type==='ArrowFunctionExpression'||ι.type==='FunctionExpression'?
			τ('function',{
				name:ι.id,
				params:[ ι.type==='ArrowFunctionExpression'? ∅ : 'this', …ι.params.map(ι=>ι.ι) ],
				ι:ι.expression? ι.body : τι('seq',[ι.body,τι('js_data',∅)]) })
		: ι.type==='BinaryExpression'? τ('builtin',{ f:ι.operator, a:[ι.left,ι.right] })
		: ι.type==='BlockStatement'? τι('seq',ι.body)
		: ι.type==='ReturnStatement'? τι('seq',[τι('set_result',ι.argument),τ('break_fn',{})])
		: ‽(ι) })
	// -------------------------------------------------------------------------- //
	opti_semantic ← ι=>{ // or simplify_or_enhance_semantics
		if (ι.type==='seq'){
			// seq[seq[]] -> seq[]
			ι.ι = ι.ι.map…(ι=> ι.type==='seq'? ι.ι : [ι])
			// break; foo() -> warning
			i ← ι.ι.findIndex(ι=> ι.type==='break_fn')
			dead ← i===-1? [] : ι.ι.splice(i+1,∞)
			if (dead.some(interesting)) cn.log('[warning]','you have interesting dead code',dead)
			// seq[ι] -> ι
			if (ι.ι.‖===1) ι = ι.ι[0]
			}
		if (ι.type==='function'){
			edit ← ✗
			if (ι.ι.type==='seq' && ι.ι.ι[-1].type==='break_fn'){ ι.ι.ι.pop(); edit = ✓ }
			if (ι.ι.type==='seq' && ι.ι.ι[-1].type==='set_result'){ ι.ι.ι[-1] = ι.ι.ι[-1].ι; edit = ✓ }
			if (edit) ι.ι = opti_semantic(ι.ι)
			}
		↩ ι}
	r = walk_obj_edit(r,opti_semantic)
	↩ r}

// -------------------- eval my ast into my abstract data ------------------- //
vmζ_runInContext ← (ast,global_)=>{
	stack ← []
	resolve ← ι=>{t←;
		sc ← stack[-1]; for(;;){    if (t= sc.ι[ι]) ↩ t; if (t= sc.f.scope_parent){ sc = t; continue }    break}
		↩ global_[ι] || τ('‽',{ found_by:ι }) }
	
	// convert my abstract data to native javascript data
	compile ← ι⇒
		: ι.type==='js_data'? ι.ι
		: ι.type==='closure'? λ ζwrap(…a){↩ compile(vmζ_runInContext(
			τ('call',{ o:ζwrap.ι, self:τι('js_data',@), a:a.map(ι=> τι('js_data',ι)) })
			,global_ )) } <- ({ι})
		:( ι = τι('<not_compiled>',ι), cn.log(ι), ι )

	eval_ ← ι⇒
		: ι.type==='seq'? ι.ι.map(eval_)[-1]
			// (=>{ t←; for(i←0;i<ι.ι.‖;i++){ t = eval_(ι.ι[i]); if (t.type==='‽') ↩ [t,eval_(ι.ι.slice(i+1))] }; ↩ t })()
		: ι.type==='local_private_slot'? stack[-1].ι[ι.name.ι] = eval_(ι.ι)
		: ι.type==='name'? resolve(ι.ι)
		: ι.type==='call'? call(eval_(ι.o),[ι.self,…ι.a].map(eval_))
		: ι.type==='member'?(=>{ o ← eval_(ι.o); m ← compile(eval_(ι.m)); Tstr(m) || ‽(ι); ↩ member(o,m) })()
		: ι.type==='function'? τ('closure',{ ι, scope_parent:stack[-1] })
		: ι.type==='object'? τι('js_data', ι.ι.map(ι=>{ ι = ι.map(eval_).map(compile); Tstr(ι[0]) || ‽; ↩ ι })._.object() )
		: ι.type==='js_data' || ι.type==='closure'? ι
		: τι('<not_evald>',ι)

	call ← (o,a)=>{r←; ↩ 0?0
		: o.type==='js_data'? τι('js_data', compile(o).call(…a.map(compile)) )
		: o.type==='closure'?(
			stack.push({ f:o, ι:[
				…(o.ι.name? [[o.ι.name.ι,o]] : []),
				…o.ι.params.map((k,i)=> [k,a[i]]).filter(ι=>ι[0]),
				]._.object() }),
			(r = eval_(o.ι.ι)),
			stack.pop(),
			r )
		: τι('<not_evald>',{o,a}) }

	member ← (o,m)=> τι('js_data', 0?0
		: o.type==='js_data'? o.ι[m]
		: o.type==='closure'? m==='name'? o.ι.name.ι : ∅
		: ∅ )

	ast = τ('call',{ o:τ('function',{ name:∅, params:[∅], ι:ast }), self:τι('js_data',∅), a:[] })
	↩ eval_(ast) }

// ---------------------------------- test ---------------------------------- //
// code ← φ`~/file/code/scratch/ζ/parsimmon2.ζ`.text
code ← `random_id_ ← L=> L.map(()=> random( _.range(0,0x100).map(ι=> chr(ι)).filter(ι=> ι.match(/[0-9a-z]/)) )).join(''); _.range(8).map(random_id_)`
ctx ← _({ _,random,String, }).map((ι,k)=> [k,τ('js_data',{ι,found_by:k})])._.object()
ast = vmζ_parse(code)
t←; dur ← bench1(=> t = vmζ_runInContext(ast,ctx) )
;({ ast, global:ctx, ι:t, dur })

// ‡ figure out how you want to handle native exceptions, applicable on ι.type call and maybe member

// ‡ i'd like to restructure this with the data types defined as more like classes, because this is a complicated thing where that would be appropriate, i think?
// ‡ figure out if this is right, or what *is* right
