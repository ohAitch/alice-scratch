i wish this could be a computer program

sport A
10 ranks, 10 * 2^i
tournament
even distribution between ranks
single round knockout, winner take all
sort by rank?
sort by random?
sort ranks evenly?
compare

you can do that in

players ← 128..map(ι=> 2**(ι*8/128 |0))
players ← 128..map(ι=> 2**(ι%8))
fight ← (a,b)=> random()*(a+b) > a? b : a
do_round ← pl=>{ r←[]; for(i←0;i<pl.length;i+=2) r.push(fight(pl[i],pl[i+1])); ↩ r}
fight_all ← pl=>{ while (pl.length > 1) pl = do_round(pl); ↩ pl[0] }
2e6.map(=> fight_all(players))._.countBy()
2e6.map(=> fight_all(_.shuffle(players)))._.countBy()

is that really so bad?

in “abstract format” it could be

(l random by f)=> m ← l*f; t ← random()×sum(m); l[m find_index (t -← ι ≤ 0)]
tournament ← ι=> until ι≈[r], ι >>← chunk(2) * random by ι
2e6 * tournament(128 * 2^(ι×8/128 |0)) count
2e6 * tournament(128 * 2^(ι mod 8)) count
2e6 * tournament(128 * 2^(ι mod 8) shuffle) count

which in js would be

random_by ← (l,f)=>{ ms ← l.map(f); t ← random() * ms.fold((a,b)=>a+b); ↩ l[ms.findIndex(ι=> (t-=ι) <= 0)] }
tournament ← ι=>{ while( ι.length>1 ) ι = ι.chunk(2).map(ι=> random_by(ι,ι=>ι)); ↩ ι[0] }
2e6.map(=> tournament(128..map(ι=> 2**(ι*8/128 |0))))._.countBy()
2e6.map(=> tournament(128..map(ι=> 2**(ι%8))))._.countBy()
2e6.map(=> tournament(128..map(ι=> 2**(ι%8))._.shuffle()))._.countBy()

not so bad! 50% bonus character shit plus 50% bonus dealing with shit libs, but that's not the worst thing possible
i note that there's an exciting “by” abstraction for a very simple mapping path. that could be generalized.

# ofc you could also do real math with something like this (i don't know enough probablistic programming architecture to get it exactly right)

# tournament ← ι=> until ι≈[r], ι >>← chunk(2) * rand_var by ι
# tournament(128 * 2^(ι×8/128 |0))
# tournament(128 * 2^(ι%8))
# tournament(128 * 2^(ι%8) shuffle_var)

so: what does this mean is important?

we've noticed that two of the main goals are distinctly
* factor out intent and optimization
* make syntax *not intended to have precise meaning*, bringing precise meaning in with (automatically or manually generated) precision annotations - *factor out* precision, to break apart the getting-locked-to-precison feature without making a shitty mess everywhere
‡ wait, i think those are the same goal

what does christopheralexander say about that?

◍ youuu should build pattern languages, yes, you should
◍ being legible to social group is real value
◍ there are important patterns about precise meaning and important patterns about structure, and they are performed separately in different ways, because they are different

suggestion: write a series of short programs, starting at somewhat simpler than diff_dirs, possibly starting with project euler, and refine them and refine the optimization factoring mechanic

* factor out {the stuff its easy to guess from context but hard to guess with perfect reliability and simplicity} from {the stuff its not easy to guess at all}
‡ that might be an effective research direction

```
read https://projecteuler.net/problem=22 names.txt
* lowercase; sort
assert ι[938-1] = 'colin'
* (1+i)×( ι * (1 + index of ι in /[a-z]/) sum )
assert ι[938-1] = 49714
sum
```

‡ no?

{factoring of these things} and {inference of the lower level of these things} can be separate steps
start with designing a programming language that allows you to fully factor these things

◍ consider that {client usage profiles} and {set of implementation strategies} and {function from former to latter} are separate things
◍ data movement cost >> instruction execution cost; therefore programmers should deal with locality/non-locality of data more
