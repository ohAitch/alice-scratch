goal: to create a new way of interacting with existing javascript and humans much more painlessly and effectively (in this domain of javascript) - and regardless of whether we realize that, to gain the experience which is gained by attempting it

-------------------- for the stated goal, the big things are -------------------

is a view of js
reduced visual and/or semantic noise - e.g.:
	[es6 arrows (only some?)] `λ(v){↩ ...}` versus `λ v:` or something else (end/fi/od/esac?)
	`foo(bar)` versus `foo bar`
	semicolons
	[es6 some] bulky apis (e.g. prototype, arguments, length, slicing, ===, apply, bind, typeof)
	[es6 some] destructuring (e.g. slicing, ranges)
		https://stackoverflow.com/questions/24330902/how-does-term-rewriting-based-evaluation-work/24776426#24776426
	separators: atomically-delimited -> separatorless. but: humans text redundant and fuzzy and trip over each other and so needs delimiting? or PEG magic?
	partial application
	pronoun syntax
	statements
	macros / whichever part it is of macros that is actually really useful (operators? hm. maybe _yes_)
	[es6 most] cps / yield / generators
	& more?

-------------------------------- what is a view? -------------------------------

degrees of "a view"
	✨ :: ✨ -> logically equivalent js
	✨⁻¹ :: js -> logically equivalent ✨
		optionally it's a sensible subset of js that many people already use (e.g. "strict mode everywhere" or "es5" or "no with")
	invertible ✨
	logic is kept on the same line
	outputs are readable in the target
	outputs are idiomatic in the target
	-> now ✨ is truely a view of js, and vice-versa

but we might want to do magical transformations
	to do magical transformations reversibly, we'd have to keep track of all steps and record this in the result

proposal: ⎋tag system wherein /⎋[^\s⎋]+/ forms a postfix annotation to record information that would have been lost in a transformation

js_rewrite: _x == (null|true|false) <-> _x ∈ \1 ⎋=
js_rewrite: _x == undefined <-> _x == null ⎋u
js_rewrite: _x === null || _x === undefined || _x === false <-> !_x
js_rewrite: _x === null || _x === undefined <-> _x ∈ null
js_rewrite: !_x <-> !_x ⎋f
js_rewrite: void 0 <-> undefined ⎋v
js_rewrite: void _x <-> (_x,undefined)⎋v

-> _x != null && _x !== false <-> !!_x ⎋=
-> _x !== null && _x !== undefined <-> _x ∉ null
-> _x != void 0 <-> _x ∉ null ⎋=uv
-> _x != void 5 <-> _x ∉ (5,null) ⎋=uv

------------------------ important implementation notes ------------------------

we look at control flow, and we see "!= null" and "!== false" as the two fundamental things (but with a blurred "!= null && !== false")
now that es6 is existing, we need to account for http://git.io/es6features
we could write a program by telling it to a human and having them execute it and/or tell me why it doesn't compile. or switch me and the human.
corpus stuff https://github.com/jashkenas/underscore/blob/master/underscore.js https://github.com/caolan/async/blob/master/lib/async.js

------------------------------------ <edge> ------------------------------------

since it's a view - can we *actually* define the language incrementally this time?
a set of rewrite rules might just do it

we could test this idea without thinking about it any further by writing a ✨ that just does one or a few simple rules and then applying it to some javascript corpuses

initial testing result: existing parsers are shitty. ✨ probably depends entirely on having a very good parser - should we start working on that?
