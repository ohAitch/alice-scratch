#!/usr/bin/env ζ₂

util ← require('util')
node_spotify ← require('node-spotify')
async ← require('async')

// todo: use the node audio handler for Fun Stuff
// todo: rename this file to index.ζ₂

// ----------------------------------- aux ---------------------------------- //

poll ← λ(f,cb){(λ λ(){if (f()) cb(); else setTimeout(λ,50)})()}
is_playlist ← λ(v){↩ v.type === undefined || v.type === 0} // spotify.constants.PLAYLIST_TYPE_PLAYLIST = 0
Native ← λ(v,body){@.native = v; _(@).extend(body)}
	Object.defineProperty(Native.prototype,'toJSON',{configurable:true, enumerable:false, value: λ(){↩ _(@).omit('native')} })
	magic_native ← {inspect:λ(x,opts){t ← '<native>'; ↩ true/*opts.colors*/? '\x1b[36m'+t+'\x1b[39m' : t}}
	Object.defineProperty(Native.prototype,'inspect',{configurable:true, enumerable:false, value:
		λ(){↩ util.inspect(_(_(@).clone()).extend({native: magic_native}), {colors:true})}
		})

// ----------------------------- getDatabaseoid ----------------------------- //

audio_handler←; //! aiee, such hack ... um, why did we find ourself wanting to do this?
audio_handler_resume←;

getDatabaseoid ← λ(cb){
	loginAndWaitForAllLoaded ← (λ(){
		login ← λ(cb){
			console.error('[spotiman] signing in ...')
			spotify ← node_spotify({appkeyFile: fs('~/.spotiman/spotify_appkey.key').resolve()})
			global.spotify = spotify
			spotify.on({ready:λ(e){cb(e,spotify)}})
			audio_handler_resume = spotify.useNodejsAudio(λ(){↩ audio_handler.apply(@,arguments)})
			auth ← JSON.parse(fs('~/.spotiman/auth.json').$); spotify.login(auth.username, auth.password)
			}
		waitForAllLoaded ← λ(spotify,cb){
			console.error('[spotiman] loading tracks ...')
			t ← spotify.playlistContainer.getPlaylists()
			poll(λ(){↩ t.filter(is_playlist).every(λ(v){↩ v.isLoaded})},λ(){
				t = _(t.filter(is_playlist).map(λ(v){↩ v.getTracks()})).flatten(true)
				poll(λ(){↩ t.every(λ(v){↩ v.isLoaded})},cb)
				}) }
		↩ λ(cb){login(λ(e,spotify){waitForAllLoaded(spotify,λ(){cb(e,spotify)})})}
		})()

	all_interned_tracks ← {}
	intern_track ← (λ(){memo ← all_interned_tracks; ↩ λ(v){↩ memo[v.link] || (memo[v.link] = new Native(v,{
		name: v.name,
		link: v.link,
		artists: v.artists.map(λ(v){↩ {name: v.name, link: v.link}}),
		album: (λ(v){↩ {name: v.name, link: v.link}})(v.album),
		tags: [],
		createTime: [],
		}) ) } })()
	tag_track ← λ(tag,v,native){
		!_(v.tags).contains(tag.name) && v.tags.push(tag.name)
		v.createTime.push([tag.name, moment(native.createTime)])
		↩ v }

	loginAndWaitForAllLoaded(λ(e,spotify){
		console.error('[spotiman] massaging data ...')
		t ← spotify.playlistContainer.getPlaylists().filter(is_playlist)
		d ← _(_(t).countBy('name')).pairs().filter(λ(v){↩ v[1] > 1}).map(λ(v){↩ v[0]})
		if (d.length) print('[spotiman] oh no! duplicate tags!',d)
		if (d.length) t = t.filter(λ(v){↩ d.indexOf(v.name) === -1})
		t = t.filter(λ(v){↩ v.owner.canonicalName === spotify.sessionUser.canonicalName}) // it's unclean and hacky to do this
		tags ← t.map(λ(v){ ↩ new Native(v, { name: v.name, tracks: v.getTracks().map(λ(t){↩ tag_track(v, intern_track(t), t)}) }) })
		tracks ← _(all_interned_tracks).values()
		cb(null,[tags,tracks]) }) }

// ---------------------------------- main ---------------------------------- //

global.search = λ(v){
	get_track ← λ(v){↩ v.numTracks === 0? v.query : v.getTrack(0)}
	Array.isArray(v)? async.map(v,λ(v,cb){new spotify.Search(v).execute(λ(e,r){r.query = v; cb(e,r)})},λ(e,vs){
		global.__ = vs.map(get_track); print('[spotiman::search]',vs.length,'results')
		}) :
		new spotify.Search(v).execute(λ(e,r){r.query = v; print(global.__ = get_track(r))}) }

switch (process.argv[2]) {
default: print('invalid args:',process.argv)
break; case undefined:
time ← ζ2_now()
getDatabaseoid(λ(e,t){tags ← t[0]; tracks ← t[1]
	print('[spotiman] loaded db in',round((ζ2_now() - time)*100)/100+'s')

	// global.bufs = []
	// audio_handler = λ(e,buf){if (e) throw e
	// 	bufs.push(buf)
	// 	↩ true }
	
	// wav ← require('wav')
	// new wav.FileWriter('t.wav').write(Buffer.concat(bufs))
	// https://www.npmjs.com/package/lame

	global.tags = tags; global.tracks = tracks; ζ2_repl_start()

	// spotify.logout(λ(){rimraf('cache'); rimraf('settings'); exit maybe}) // will log you out
})
break; case 'backup': // terrible name, really
getDatabaseoid(λ(e,t){tags ← t[0]; tracks ← t[1]
	print(JSON.stringify(tracks,null,'\t'))
	process.exit() //! augh
})
}
