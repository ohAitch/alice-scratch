#!/usr/bin/env ζ₂
node_spotify ← require('node-spotify','0.7.0')

// ----------------------------------- aux ---------------------------------- //

poll ← λ(f,cb){(λ λ(){if (f()) cb(); else setTimeout(λ,50)})()}
is_playlist ← λ(v){↩ v.type === undefined || v.type === 0} // spotify.constants.PLAYLIST_TYPE_PLAYLIST = 0
Native ← λ(v,body){@.native = v; _(@).extend(body)}
	Object.defineProperty(Native.prototype,'toJSON',{configurable:true, enumerable:false, value: λ(){↩ _(@).omit('native')} })
	magic_native ← {inspect:λ(x,opts){t ← '<native>'; ↩ true/*opts.colors*/? '\x1b[36m'+t+'\x1b[39m' : t}}
	Object.defineProperty(Native.prototype,'inspect',{configurable:true, enumerable:false, value:
		λ(){↩ util.inspect(_(_(@).clone()).extend({native: magic_native}), {colors:true})}
		})
now ← λ(){↩ Date.now() / 1000}

// ----------------------------- getDatabaseoid ----------------------------- //

getDatabaseoid ← λ(cb){
	loginAndWaitForAllLoaded ← (λ(){
		login ← λ(cb){
			console.error('[spotiman] logging on ...')
			spotify ← node_spotify({appkeyFile:fs('~/.auth/spotify_appkey.key').path})
			global.spotify = spotify
			spotify.on({ready:λ(e){cb(e,spotify)}})
			auth ← JSON.parse(fs('~/.auth/spotify').$); spotify.login(auth.username, auth.password)
			}
		waitForAllLoaded ← λ(spotify,cb){
			console.error('[spotiman] polling for loading ...')
			t ← spotify.playlistContainer.getPlaylists()
			poll(λ(){↩ t.filter(is_playlist).every(λ(v){↩ v.isLoaded})},λ(){
				t = _(t.filter(is_playlist).map(λ(v){↩ v.getTracks()})).flatten(true)
				poll(λ(){↩ t.every(λ(v){↩ v.isLoaded})},cb)
				}) }
		↩ λ(cb){login(λ(e,spotify){waitForAllLoaded(spotify,λ(){cb(e,spotify)})})}
		})()

	all_interned_tracks ← {}
	intern_track ← (λ(){memo ← all_interned_tracks; ↩ λ(v){↩ memo[v.link] || (memo[v.link] = new Native(v,{
		name: v.name,
		link: v.link,
		artists: v.artists.map(λ(v){↩ {name: v.name, link: v.link}}),
		album: (λ(v){↩ {name: v&&v.name, link: v&&v.link}})(v.album),
		tags: [],
		createTime: [],
		}) ) } })()
	tag_track ← λ(tag,v,native){
		!_(v.tags).contains(tag.name) && v.tags.push(tag.name)
		v.createTime.push([tag.name, moment(native.createTime)])
		↩ v }

	loginAndWaitForAllLoaded(λ(e,spotify){
		console.error('[spotiman] massaging data ...')
		t ← spotify.playlistContainer.getPlaylists().filter(is_playlist)
		d ← _(_(t).countBy('name')).pairs().filter(λ(v){↩ v[1] > 1}).map(λ(v){↩ v[0]})
		if (d.length) print('[spotiman] oh no! duplicate tags!',d)
		if (d.length) t = t.filter(λ(v){↩ d.indexOf(v.name) === -1})
		t = t.filter(λ(v){↩ v.owner.canonicalName === spotify.sessionUser.canonicalName}) // it's unclean and hacky to do this
		tags ← t.map(λ(v){ ↩ new Native(v, { name: v.name, tracks: v.getTracks().map(λ(t){↩ tag_track(v, intern_track(t), t)}) }) })
		tracks ← _(all_interned_tracks).values()
		cb(null,[tags,tracks]) }) }

// ---------------------------------- main ---------------------------------- //

switch (process.argv[2]) {
default: print('invalid args:',process.argv)
break; case undefined:
time ← now()
getDatabaseoid(λ(e,t){tags ← t[0]; tracks ← t[1]
	print('[spotiman] loaded db in',round((now() - time)*100)/100+'s')

	global.tags = tags; global.tracks = tracks; ζ2_repl_start()

	// spotify.logout(λ(){rimraf('cache'); rimraf('settings'); exit maybe}) // will log you out
})
break; case 'backup': // terrible name, really
getDatabaseoid(λ(e,t){tags ← t[0]; tracks ← t[1]
	print(JSON.stringify(tracks,null,'\t'))
	process.exit() //! augh
})
}
