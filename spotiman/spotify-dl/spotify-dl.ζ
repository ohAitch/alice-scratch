#!/usr/bin/env ζ

lame ← require('lame','1.2.3')
async ← require('async','1.5.0')

arg ← {
	cache_dir: fs('~/ali/misc/music_cache').path,
	}

rc ← λ(ι){↩ util.inspect(ι,{colors:true})}
poll ← λ(f,cb){(λ λ(){if (f()) cb(); else λ.in(0.05)})()}
is_playlist ← λ(ι){↩ ι.type === undefined || ι.type === 0} // spotify.constants.PLAYLIST_TYPE_PLAYLIST = 0
getTracks ← λ(ι){↩ _.range(ι.numTracks).map(λ(i){↩ ι.getTrack(i)})}
getPlaylists ← λ(ι){↩ _.range(ι.numPlaylists).map(λ(i){↩ ι.getPlaylist(i)})._.filter()}
mp3_info_to_basename ← λ(ι){
	Array.isArray(ι) || (ι = [ι.artist, ι.album, ι.i, ι.name])
	ι = ι.map(λ(ι){↩ basename_encode((ι+'').replace(/ +- +/g,'-'))})
	↩ ι[0]+' - '+ι[1]+' - '+ι[2].replace(/⟩.*/,'').replace(/^(.)$/,'0$1')+' '+ι[3] }
mp3_set_id3 ← λ(fl,ι){ s ← sh_encode
	Array.isArray(ι) || (ι = [ι.artist, ι.album, ι.i, ι.name])
	execᵥ('mid3v2 -a '+s(ι[0])+' -A '+s(ι[1])+' -t '+s(ι[2])+' -T '+s(ι[3])+' '+s(fl)) }
// E.mp3_clean = λ(fl){
// 	get id3 tags [artist, album, i, name] from file // execᵥ('mid3v2 '+sh_encode(fl)); ['TPE1','TALB','TRCK','TIT2'].map(λ(ι){↩ (RegExp('^'+ι+'=(.*)','m').λ(id3)||[])[1]})
// 	read filename to look for [artist, album, i, name] // (t=path.basename(ι,'.mp3')).match(/^(.*?)? - (?:(.*) - )?(?:(\d+) )?(.*)?/).slice(1).concat([t])
// 	if filename contained things id3 is missing: write those to id3 (and print)
// 	if id3 contained things filename is missing: move the file (and print)
// 	if mp3_info_to_basename(id3) !== filename: ↩ {conflict:true, file:, id3:}
// 	}

login ← λ(cb){
	print('[spotify dl] logging on ...')
	// spotify ← require('./build/Release/nodespotify')()
	spotify ← require('node-spotify')({appkeyFile:process.env.HOME+'/.auth/spotify_appkey.key', settingsFolder:process.env.HOME+'/.libspotify_cache', cacheFolder:process.env.HOME+'/.libspotify_cache'})
	spotify.on({ready:λ(e){cb(e,spotify)}})
	auth ← JSON.parse(fs('~/.auth/spotify').$); spotify.login(auth.username, auth.password)
	}

player_bufs←;
quiet_skipping ← true

ensure_playlist_cached ← λ(spotify,ι,cb){async.mapSeries(getTracks(ι)._.pairs(), λ(t,cb){i ← parseInt(t[0]); tr ← t[1]; ensure_track_cached(spotify,tr,ι.name,i,cb)}, cb)}
ensure_track_cached ← λ(spotify,ι,p_name,p_i,cb){
	prettyname ← '\x1b[32m'+p_name+'\x1b[33m'+(p_i+'').replace(/./g,λ('₀₁₂₃₄₅₆₇₈₉'))+'\x1b[39m'
	if (ι.availability !== 1) {
		!quiet_skipping && !/^spotify:local/.λ(ι.link) && print('[spotify dl] '+prettyname+' \x1b[31;1mskipped\x1b[0m')
		cb&&cb.in(); ↩} // spotify.constants.SP_TRACK_AVAILABILITY_AVAILABLE = 1
	ι.album.browse(λ(e,t){
		metadata ← {
			artist: ι.artists._.map('name').map(λ(ι){↩ ι.replace(/, +/g,',')}).join(', '),
			album: ι.album.name,
			// i: (parseInt(t.tracks._.invert()[ι.link])+1)+'/'+t.tracks.length,
			i: (parseInt(t.tracks._.map('link')._.invert()[ι.link])+1)+'/'+t.tracks.length,
			name: ι.name,
			}
		out ← arg.cache_dir+'/'+mp3_info_to_basename(metadata)+'.mp3'
		if (fs(out).exists()) {cb&&cb.in(); ↩}
		quiet_skipping = false
		player_bufs = []
		spotify.player.play(ι)
		q ← (λ(){
			process.stdout.write('\x0d[spotify dl] '+prettyname+' @'+' '+rc(spotify.player.currentSecond)+' / '+rc(ι.duration))
			spotify.player.resume()
			}).every(0.1)
		spotify.player.on({endOfTrack: λ(){(λ(){
			clearInterval(q); print('\x0d[spotify dl] '+prettyname+' \x1b[31;1m✓\x1b[0m            ')
			data ← Buffer.concat(player_bufs); player_bufs = null
			t ← new lame.Encoder({channels:2, bitDepth:16, sampleRate:44100, bitRate:256, outSampleRate:22050, mode:lame.STEREO})
			t.end(data)
			out_s ← fs.createWriteStream(out)
			t.pipe(out_s)
			out_s.on('finish',λ(){ mp3_set_id3(out, metadata); cb&&cb.in(); })
			}).in(1)}}) }) }

login(λ(e,spotify){
	spotify.useNodejsAudio(λ(e,ι){if (e) throw e; player_bufs.push(ι); ↩ true})
	print('[spotify dl] loading playlists ...')
	ι ← getPlaylists(spotify.playlistContainer)
	poll(λ(){↩ ι.filter(is_playlist).every(λ(ι){↩ ι.isLoaded})},λ(){
		playlists ← ι.filter(is_playlist)
		playlists._.indexBy('name')['[from mage]'] || (λ(){throw '‽'})() // testing
		playlists = playlists.filter(λ(ι){↩ ι.owner.canonicalName === spotify.sessionUser.canonicalName})
		playlists = playlists._.sortBy('numTracks')
		async.mapSeries(playlists,
			λ(ι,cb){ poll(λ(){↩ getTracks(ι).every(λ(ι){↩ ι.isLoaded})},λ(){ensure_playlist_cached(spotify,ι,cb)}) },
			λ(e,ι){print('[spotify dl] done.') ;(λ(){process.exit()}).in(1.5)
			})
		})
	})

// the only thing we know about that might have made it work instead of not working is `xcode-select --install`

// these are all outdated for node v5, of course
// ffi ← require('ffi','2.0.0')
// ref ← require('ref','1.3.1')
// ref_struct ← require('ref-struct','1.0.2')

// // https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial
// // https://www.npmjs.com/package/ref
// // https://www.npmjs.com/package/ref-struct
// // https://developer.spotify.com/docs/libspotify/12.1.45/structsp__session__config.html

// p_fix ← λ Λ(ι){Object.defineProperty(ι,'ᵖ',{get:λ(){↩ @.ᵖ = Λ(ref.refType(ι))}, set:λ(ι){Object.defineProperty(@,'ᵖ',{value:ι, writable:true, enumerable:true, configurable:true})}, configurable:true}); ↩ ι}
// _(ref.types).values().map(p_fix); //(λ(){o ← ref_struct; ref_struct = λ(){↩ p_fix(o.apply(@,arguments))}})()

// t ← ref.types; int ← t.int; char ← t.char; size_t ← t.size_t; bool ← t.bool; void_ ← t.void

// // sp_error ← void_
// // sp_session ← void_
// // sp_session_config ← ref_struct({
// // 	api_version: int,
// // 	cache_location: char.ᵖ,
// // 	settings_location: char.ᵖ,
// // 	application_key: void_.ᵖ,
// // 	application_key_size: size_t,
// // 	user_agent: char.ᵖ,
// // 	callbacks: void_.ᵖ/*sp_session_callbacks.ᵖ*/,
// // 	userdata: void_.ᵖ,
// // 	compress_playlists: bool,
// // 	dont_save_metadata_for_playlists: bool,
// // 	initially_unload_playlists: bool,
// // 	device_id: char.ᵖ,
// // 	proxy: char.ᵖ,
// // 	proxy_username: char.ᵖ,
// // 	proxy_password: char.ᵖ,
// // 	ca_certs_filename: char.ᵖ,
// // 	tracefile: char.ᵖ,
// // 	})

// // libspotify ← ffi.Library('libspotify',{
// // 	sp_session_create: [sp_error, [sp_session_config.ᵖ, sp_session.ᵖ.ᵖ]],
// // 	})

// // a ← ref.alloc(sp_session_config.ᵖ)
// // b ← ref.alloc(sp_session.ᵖ.ᵖ)
// // t ← libspotify.sp_session_create(a,b)
// // print(t)

// TimeVal ← ref_struct({
//   'tv_sec': 'long',
//   'tv_usec': 'long'
// });
// TimeValPtr ← ref.refType(TimeVal);

// lib ← new ffi.Library(null, { 'gettimeofday': [ 'int', [ TimeValPtr, "pointer" ] ]});
// tv ← new TimeVal();
// lib.gettimeofday(tv.ref(), null);
// console.log("Seconds since epoch: " + tv.tv_sec);
