// && || % are probably temporary
// add ++ -- with .₋\[
// add ␣+₋. with ␣-₋.
// add ./\ᵛ+/ with ./₋?\ᵥ/
// add -= *= /= &= |= with +=
// add back .in. .¬in. with isa
// ? bah, throw
// have a place for bitwise ops?
// what about `₋. ? dunno how i feel about that being like it is

"is there anything i want to push out despite spacing? check from bottom up (top down)"

a, b + 7, 9

maybe ,
if shouldn''t. if is a statement. if _always_ pushes out, except against ,
v+2 * 7

[] _eats_ tokens without giving them any opportunity to bind to anything

//===--------------------------===// current //===-------------------------===//
// okay, we've let our thoughts on this percolate for a while. let's see if we can write out the operators in a sensible way.

oh!
eating another left-eating op (probably?) doesn''t change the number of things we''re eating, but another non-left-eating op *does*
so the question is: what gets ops interpreted as functions and what gets ops interpreted as macros?

[is a last item] [last item is full] [next item is left-wall]: recurse back up to whatever is eating many thing in sequence?
[is a last item] [last item is full] [next item is maybe left-wall]: ??? not sure ???
[is a last item] [last item is full] [next item is left-eaty]:
    if its left-priority > our right-priority: recurse to next item
    elif its left-priority < our right-priority: recurse upwards
    else: this is that =≠<>≤≥ thingy! or something like it!
[is a last item] [last item is full] [next item is void]: why marvelous, just let the above level handle this end
[is a last item] [last item is want] [next item is not-an-op]: eat it
[is a last item] [last item is want] [next item can be left-wall and have lower priority than us]: recurse to next item!
[is a last item] [last item is want] [next item is any other op]: error!
[is a last item] [last item is want] [next item is void]: oh no, you don''t get your satisfaction! but this is still not a problem.
[void last item] [next item is left-wall]: marvelous, no problem, just do whatever the thing that is eating things says
[void last item] [next item is maybe left-wall]: next item is definitely left-wall
[void last item] [next item is left-eaty]: oh my well you don''t get to eat anything then! this is not actually a problem. we can just pass you void/undefined.
so it might be somewhat hard to figure out just what the priority of the next item is. or possibly even the last item.
yeah. we didn''t solve the "which operator am i even?" problem.

regime breakers:
	\[…*\] (…*) {…*}
	λ
	new
	; && ||
	\[ ( {

400 401 .␣\.₋. .₋\.₋. .₋\ᵥ .₋\[ .₋(
390 391 ¬₋. -₋.
380 381 .₋*₋. .₋/₋. .₋%₋.
370 371 .₋+₋. .₋-₋.
350 350 .₋=₋. .₋≠₋. .₋<₋. .₋>₋. .₋≤₋. .₋≥₋.
340 341 .₋&₋. .₋|₋.
331 330 .₋\?₋.₋:₋.
321 322 .₋+=₋.
323 320 .₋←₋. .₋←!₋.
300 301 `₋. ~₋. ~@₋.
290 291 ¬␣.
280 281 .␣*␣. .␣/␣. .␣%␣.
270 271 .␣+␣. .␣-␣.
260 260 .␣isa␣.
250 250 .␣=␣. .␣≠␣. .␣<␣. .␣>␣. .␣≤␣. .␣≥␣.
240 241 .␣&␣. .␣|␣.
231 230 .₋\?␣.␣:␣.
221 222 .␣+=␣.
223 220 .␣←␣. .␣←!␣.
210 211 λ.. if.:?.,?[else.]? while.:?. return.? try.,?[catch.,?]?[finally.]?
200 201 `␣. ~␣. ~@␣.
100 100 , :

// add more than minimum? alpha precedence (so, 190 195 instead of 190 191? or just allow floats.)

// it might be worth considering the case of independent libraries.
// "fail-fast" could be adequate

// http://compilers.iecc.com/comparch/article/01-07-068

parse_expression ()
    return parse_expression_1 (parse_primary (), 0)
parse_expression_1 (lhs, min_precedence)
    while the next token is a binary operator whose precedence is >= min_precedence
        op := next token
        rhs := parse_primary ()
        while the next token is a binary operator whose precedence is greater
                 than op''s, or a right-associative operator
                 whose precedence is equal to op''s
            lookahead := next token
            rhs := parse_expression_1 (rhs, lookahead''s precedence)
        lhs := the result of applying op with operands lhs and rhs
    return lhs
Example execution of the algorithm[edit]
An example execution on the expression 2 + 3 * 4 + 5 == 19 is as follows. We give precedence 0 to equality expressions, 1 to additive expressions, 2 to multiplicative expressions.

parse_expression_1 (lhs = 2, min_precedence = 0)

the next token is +, with precedence 1. the while loop is entered.
op is + (precedence 1)
rhs is 3
the next token is *, with precedence 2. recursive invocation.
parse_expression_1 (rhs = 3, min_precedence = 2)
the next token is *, with precedence 2. the while loop is entered.
op is * (precedence 2)
rhs is 4
the next token is +, with precedence 1. no recursive invocation.
lhs is assigned 3*4 = 12
the next token is +, with precedence 1. the while loop is left.
12 is returned.
the next token is +, with precedence 1. no recursive invocation.
lhs is assigned 2+12 = 14
the next token is +, with precedence 1. the while loop is not left.
op is + (precedence 1)
rhs is 5
the next token is ==, with precedence 0. no recursive invocation.
lhs is assigned 14+5 = 19
the next token is ==, with precedence 0. the while loop is not left.
op is == (precedence 0)
rhs is 19
the next token is end-of-line, which is not an operator. no recursive invocation.
lhs is assigned the result of evaluating 19 == 19, for example 1 (as in the C standard).
the next token is end-of-line, which is not an operator. the while loop is left.
1 is returned.