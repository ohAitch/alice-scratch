#!/usr/bin/env ζ₂

builder ← require('xmlbuilder')
arg ← {
	lackey: process.argv[2],
	out: process.argv[3],
	}

//! right command is maybe problematic

hex ← λ(v,l){r ← v.toString(16); while (r.length < l) r = '0'+r; ↩ r}
as_char_as_hex ← λ(v){↩ ('000'+v.charCodeAt(0).toString(16)).slice(-4)}

parse_lackey ← λ(src){
	chords ← []
	t ← (src+'\n').replace(/(^|\n)#.*/g,'').replace(/\n+/g,'\n')
		.replace(/(?:^|\n)(\S+) : (\S+)(?=\n)/g,λ(m,a,b){chords.push([b,a]); ↩ ''})
		.match(/(---+.*---+).*\n((?:\|.+\|\n)+)(---+.*)\n/g).ζ2_mapcat(λ(v){
			// 2d regexes would be wonderful here
			transpose_str ← λ(v){↩ _.zip.apply(_,v.map(λ(v){↩ v.split('')})).map(λ(v){↩ v.join('')})}
			v = v.split('\n').slice(0,-1)
			t ← transpose_str(v)
			↩ v[-1].match(/---+/g).map(λ(v){↩ v.length}).map(λ(len){r ← t.splice(0,len); t.splice(0,2); ↩ r}).map(transpose_str) })
		.map(λ(board_str){↩ {
			hots: (board_str[0].match(/^-+ (\S+) -+$/)||[,''])[1],
			keys: board_str.slice(1,-1).map(λ(v){↩ v.match(/^\|(.+)\|$/)[1].match(/\S\S?/g)}),
			} })
	t = _(_(_(t).indexBy('hots')).omit('','⇧')).values()
	h ← _(t).indexBy('hots')['homoiconic']
	h_keys ← _.clone(h.keys)
	t.map(λ(v){if (v.keys.length < h_keys.length) v.keys = [].concat([h_keys[0].map(λ(){↩ '_'})],v.keys,[h_keys[-1].map(λ(){↩ '_'})]); v.keys = _(v.keys).flatten(true)})
	t = _(t).without(h)
	t.map(λ(v){v.keys = _.zip(h.keys,v.keys).filter(λ(v){↩ v[1] !== '_'})})
	kc ← _(t).indexBy('hots')['keycode']
	t = _(t).without(kc).ζ2_mapcat(λ(v){↩ v.keys.map(λ(k){↩ [v.hots+k[0],k[1]]})})
	↩ {keycodes: kc.keys._.object(), chords: chords.concat(t)} }

make_xml ← λ(t){keycodes ← t.keycodes; chords ← t.chords
	KeyCode ← λ(v){↩ 'KeyCode::'+(v.length > 2? v : /^\d$/.test(v)? 'KEY_'+v : /^[a-z]$/.test(v)? v.toUpperCase() : 'RawValue::0x'+keycodes[v])}
	Mod ← λ(){↩ ζ2_A(arguments).map(λ(v){↩ {"⇧":"VK_SHIFT", "^":"ModifierFlag::CONTROL_L", "⌥":"VK_OPTION", "⌘":"VK_COMMAND", "L⇧":"ModifierFlag::SHIFT_L", "L^":"ModifierFlag::CONTROL_L", "L⌥":"ModifierFlag::OPTION_L", "L⌘":"ModifierFlag::COMMAND_L", "R⇧":"ModifierFlag::SHIFT_R", "R⌥":"ModifierFlag::OPTION_R", "R⌘":"ModifierFlag::COMMAND_R", "Fn":"ModifierFlag::FN", "null":"ModifierFlag::NONE"}[v]}).join('|')}
	kc_hex ← λ(v){↩ v.split('').map(λ(v){t ← v.charCodeAt(0); ↩ hex(t,4).split('').ζ2_mapcat(λ(v){↩ [KeyCode(v),Mod('L⌥')]}).join(',')}).join(',')}
	kc_hex ← λ(v){↩ v.split('').map(λ(v){↩ as_char_as_hex(v).split('').ζ2_mapcat(λ(v){↩ [KeyCode(v),Mod('L⌥')]}).join(',')}).join(',')}
	shells ← [[KeyCode('VK_OPEN_URL_dummy'),'echo dummy']]
	shell ← λ(v){id ← KeyCode('VK_OPEN_URL_'+(Math.random()*pow(2,50)).toString(36)); shells.push([id,v]); ↩ id}
	chords.reverse() //! hack - karabiner applies the first matched <autogen>, and we currently get a sane order by reversing the chords
	autogens ← [
		'__KeyToKey__ '+KeyCode('⇪')+","+Mod('^')+","+KeyCode('⇥')+","+Mod('^','L⇧'),
		'__KeyToKey__ '+KeyCode('⇪')+","+Mod(null)+","+shell('osascript -e '+ζ2_bash_encode('tell application "chrome" to open location "chrome:newtab"')),
		'__KeyToKey__ '+KeyCode('LAUNCHPAD')+","+KeyCode('DASHBOARD'),
	].concat(chords.map(λ(v){hots ← v[0].split(''); out ← v[1]
		command_string ← typeof(out)==='string'? kc_hex(out) : shell(out[0])
		if (hots.length===3 && hots[0] === '⇧'){
			if (hots[1] === '⌥') {
				if (/^[←↑↓→]$/.test(out))
					↩ '__KeyToKey__ '+KeyCode(hots[2])+","+Mod('R⌥','R⇧',null)+","+command_string
				else
					↩ '__KeyToKey__ '+KeyCode(hots[2])+","+Mod('⌥','⇧',null)+","+command_string
			} else {
				↩ '__SimultaneousKeyPresses__ '+KeyCode(hots[1])+","+KeyCode(hots[2])+","+Mod('⇧',null)+","+command_string
			}
		}
		if (hots.length === 3) ↩ null
		↩ (
			hots[0]==='⌥'?
				'__KeyToKey__ '+KeyCode(hots[1])+","+Mod('⌥',null)+"," :
				'__SimultaneousKeyPresses__ '+KeyCode(hots[0])+","+KeyCode(hots[1])+","
			)+command_string
		})).filter(λ(v){↩ v})
	↩ builder.create({root: {
		'#list': shells.map(λ(v){↩ {vkopenurldef: {name:v[0], url:{'@type':'shell', '#cdata':v[1]}}}}),
		item: {name:'lackey', identifier:'lackey', '#list':autogens.map(λ(v){↩ {autogen:v}}) }
		}}).end({pretty:true}) }

// --------- main --------- //
fs(arg.out).$ = make_xml(parse_lackey(fs(arg.lackey).$))

// mild todo:
// if desired, more than just KeyToKey and SimultaneousKeyPresses: https://github.com/tekezo/Karabiner/tree/master/src/core/kext/RemapFunc
// handle chars outside of BMP
