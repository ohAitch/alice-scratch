#!/usr/bin/env ζ₂

builder ← require('xmlbuilder')
arg ← {
	lackey: process.argv[2],
	out: process.argv[3],
	}

//! right command is maybe problematic

as_char_as_hex ← λ(ι){↩ ('000'+ι.charCodeAt(0).toString(16)).slice(-4)}

parse_lackey ← λ(src){
	chords ← []
	t ← (src+'\n').replace(/(^|\n)#.*/g,'').replace(/\n+/g,'\n')
		.replace(/(?:^|\n)(\S+) : (\S+)(?=\n)/g,λ(m,a,b){chords.push([b,a]); ↩ ''})
		.match(/(---+.*---+).*\n((?:\|.+\|\n)+)(---+.*)\n/g).mapcat(λ(ι){
			// 2d regexes would be wonderful here
			transpose_str ← λ(ι){↩ _.zip.apply(_,ι.map(λ(ι){↩ ι.split('')})).map(λ(ι){↩ ι.join('')})}
			ι = ι.split('\n').slice(0,-1)
			t ← transpose_str(ι)
			↩ ι[-1].match(/---+/g).map('length'.λ).map(λ(len){r ← t.splice(0,len); t.splice(0,2); ↩ r}).map(transpose_str) })
		.map(λ(board_str){↩ {
			hots: (board_str[0].match(/^-+ (\S+) -+$/)||[,''])[1],
			keys: board_str.slice(1,-1).map(/^\|(.+)\|$/.λ).map(1..λ).map(/\S\S?/g.λ),
			} })
	t = _(_(_(t).indexBy('hots')).omit('','⇧')).values()
	h ← _(t).indexBy('hots')['homoiconic']
	h_keys ← _.clone(h.keys)
	t.map(λ(ι){if (ι.keys.length < h_keys.length) ι.keys = [].concat([h_keys[0].map(λ(){↩ '_'})],ι.keys,[h_keys[-1].map(λ(){↩ '_'})]); ι.keys = _(ι.keys).flatten(true)})
	t = _(t).without(h)
	t.map(λ(ι){ι.keys = _.zip(h.keys,ι.keys).filter(λ(ι){↩ ι[1] !== '_'})})
	kc ← _(t).indexBy('hots')['keycode']
	t = _(t).without(kc).mapcat(λ(ι){↩ ι.keys.map(λ(k){↩ [ι.hots+k[0],k[1]]})})
	↩ {keycodes: kc.keys._.object(), chords: chords.concat(t)} }

make_xml ← λ(t){keycodes ← t.keycodes; chords ← t.chords
	split_keys ← /F.|.[LR]|./g.λ
	Key ← λ(ι){↩ 'KeyCode::'+(ι.length > 2? ι : /^\d$/.test(ι)? 'KEY_'+ι : /^[a-z]$/.test(ι)? ι.toUpperCase() : 'RawValue::0x'+keycodes[ι])}
	Mod ← λ({"⇧":"VK_SHIFT", "^":"ModifierFlag::CONTROL_L", "⌥":"VK_OPTION", "⌘":"VK_COMMAND", "⇧L":"ModifierFlag::SHIFT_L", "^L":"ModifierFlag::CONTROL_L", "⌥L":"ModifierFlag::OPTION_L", "⌘L":"ModifierFlag::COMMAND_L", "⇧R":"ModifierFlag::SHIFT_R", "⌥R":"ModifierFlag::OPTION_R", "⌘R":"ModifierFlag::COMMAND_R", "Fn":"ModifierFlag::FN", " ":"ModifierFlag::NONE"})
	Mod_1 ← λ(_(Mod.ι).invert())
	kc_hex ← λ(ι){↩ ι.split('').map(λ(ι){↩ as_char_as_hex(ι).split('').map(λ(ι){↩ [Key(ι),Mod('⌥L')]})})}
	shells ← []
	shell ← λ(ι){id ← Key('VK_OPEN_URL_'+(Math.random()*pow(2,50)).toString(36)); shells.push([id,ι]); ↩ id}
	autogen_to_xml ← λ(ι){↩ {autogen: ι._.flatten().map(λ(ι,i,a){↩ ι+(Mod_1[ι]&&Mod_1[a[i+1]]?'|':/^__.*__$/.test(ι)?' ':',')}).join('')}}
	autogens ← [
		['__KeyToKey__',Key('⇪'),Mod('^'),Key('⇥'),Mod('^'),Mod('⇧L')],
		['__KeyToKey__',Key('⇪'),Mod(' '),shell('osascript -e '+bash_encode('tell application "chrome" to open location "chrome:newtab"'))],
		['__KeyToKey__',Key('LAUNCHPAD'),Key('DASHBOARD')],
		['__KeyToKey__',Key('MISSION_CONTROL'),Key('w'),Mod('⌘')],
		['__KeyToKey__',Key('3'),'⌘⇧' .split('').map(Mod),shell('screencapture     ~/Downloads/$(date -u +"%Y-%m-%dT%H:%M:%SZ").png')],
		['__KeyToKey__',Key('4'),'⌘⇧' .split('').map(Mod),shell('screencapture -io ~/Downloads/$(date -u +"%Y-%m-%dT%H:%M:%SZ").png')],
		['__KeyToKey__',Key('3'),'⌘⇧^'.split('').map(Mod),shell('screencapture     -cr')],
		['__KeyToKey__',Key('4'),'⌘⇧^'.split('').map(Mod),shell('screencapture -io -cr')],
	].concat(chords.map(λ(t){hots ← t[0]; out ← t[1]
		hots = hots.replace(/^⇧⌥([←↑↓→])$/,'⇧R⌥R$1')
		mds ← split_keys(hots).filter(Mod)
		chs ← split_keys(hots).filter(λ(ι){↩ !Mod(ι)})
		if (!((chs.length === 1 || chs.length === 2) && (chs.length+mds.length >= 2))) throw Error('[lackey] invalid hotstring: '+hots)
		↩ [
			{1:'__KeyToKey__', 2:'__SimultaneousKeyPresses__'}[chs.length],
			chs.map(Key),
			mds.map(Mod), mds.length? Mod(' ') : [],
			kc_hex(out),
			]
		}))
	autogens_terminal ← [
		['__KeyToKey__',Key('⌘R'),Key('^L')],
		]
	↩ builder.create({root: {
		'#list': shells.map(λ(ι){↩ {vkopenurldef: {name:ι[0], url:{'@type':'shell', '#cdata':ι[1]}}}}).concat([
			{item: {name:'lackey1', identifier:'lackey1',                  '#list':autogens         .reverse().map(autogen_to_xml)}},
			{item: {name:'lackey2', identifier:'lackey2', only:'TERMINAL', '#list':autogens_terminal.reverse().map(autogen_to_xml)}},
			]),
		}}).end({pretty:true}) }

// --------- main --------- //
fs(arg.out).$ = make_xml(parse_lackey(fs(arg.lackey).$))

// mild todo:
// if desired, more than just KeyToKey and SimultaneousKeyPresses: https://github.com/tekezo/Karabiner/tree/master/src/core/kext/RemapFunc
// handle chars outside of BMP
