#!/usr/bin/env ζ₂

/*
idea: so -
we've got this "logic as data" thing
and this "data in compact string englishdsl form" thing
- why don't we combine them?

while we're writing things from the beginning again, we should do it in a much saner and modularized and more compact way because really, v1 was driving us mad

the goal here is not to solve ai. the goal here is to create an "apprentice interface" that we can program enough that we don't have to fucking repeat everything all the time.

...

hmm
if we had a core architecture that was good enough for representing all of the stuff we want to represent, then we could build off that and not be super confused
*/

child_process ← require('child_process')
// path ← require('path')
util ← require('util')

natural ← require('natural') // https://www.npmjs.com/package/natural

// ---------------------------------- util ---------------------------------- //

EDGE ← λ(){throw Error('¬'+(arguments.length? '\n'+ζ2_A(arguments).map(λ(v){↩ util.inspect(v)}).join('\n') : ''))}
ANY ← {}
is_obj ← λ(v,template){t←;
	↩ template === ANY || (
	typeof(template)!=='object'? v === template :
		_.isEqual(_.keys(t=_(v).omit()).sort(), _.keys(template).sort()) &&
		_.pairs(t).every(λ(t){k←t[0];v←t[1]; ↩ is_obj(v,template[k])}) ) }
assert_obj ← λ(v,template){if (!is_obj(v,template)) EDGE(v)}
partition ← λ(n,v){t←[]; for (i←0;i<v.length;i+=n) t.push(_.range(n).map(λ(t){↩ v[i+t]})); ↩ t}

sublime_open ← λ(v){child_process.exec('"'+'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'+'" "'+v+'"')}

// -------------------------------------------------------------------------- //

/*
if we`re seriously thinking about determining the requirements for such an apprentice interface, we should gather all previous things we`ve tried to use it for and also generate lots more.

/hi!?|don't worry, i'm gonna make you better :\)|wow, this is a mess|thanks <3|yay/ [small talk]
	reply in a similarly fluffy way and otherwise ignore
/⟨hm[,.] ⟩?can you talk to sublime⟨ text⟩?\?/
	wonder if there might be contextual meaning
	tell user about our sublimetext-talking-to -related abilities
/⟨can you ⟩?help me ⟨do|with⟩ ⟨a morning update|my morning thing⟩\??/
	look for this ability
	if found, either reply "yes" or use it
/i ⟨want to|wanna⟩ refactor (.+?)/
	[wants to refactor $thing]
	try to guess what $thing means
	if we have a guess, ask user about it
	else, ask user for more information
	if nothing else to say, acknowledge user`s desire
// ----------- resolve contextual meaning and do contextual thing ----------- //
/yep|yeah|yes/ [yes]
/nah|nope|no/ [no]
/⟨⟨oh|uh⟩[,.] ⟩?it's in (.+?)⟨ :\)|\.⟩?/ [it in $place]
/⟨like[,.] ⟩?(\S+?) over in (\S+?)\.?/ [noun: $thing in $place]
/⟨like[,.] ⟩?(\S+?) \(?in (\S+?)\)?\.?/ [noun: $thing in $place]
/⟨nah|nope|no⟩[,.] ⟨like[,.] ⟩?(\S+?) over in (\S+?)\.?/ [no] [noun: $thing in $place]
/⟨nah|nope|no⟩[,.] ⟨like[,.] ⟩?(\S+?) \(?in (\S+?)\)?\.?/ [no] [noun: $thing in $place]
/that's a project of mine/
/belay that/
	// no context found: "what? i'm sorry, belay what?"
*/

// parse_table ← partition(2,[
// 	/(hi!?|don't worry, i'm gonna make you better :\)|wow, this is a mess|thanks <3|yay)/, λ(all){
// 		↩ ... },
// 	/i ⟨want to|wanna⟩ refactor (.+?)/, λ(thing){
// 		↩ ... },
// 	]).map(λ(v){v[0]=RegExp('^'+('⟨'+v[0].source+'⟩').replace(/⟨/g,'(?:').replace(/⟩/g,')')+'$');↩v})
// parse_sentences ← λ(v){↩ _.find(parse_table, λ(p){t←; ↩ (t=v.match(p[0])) && p[1].apply(null,t.slice(1))}) || {type:'unknown', by:'alice', source:v}}

// q=["hi","hi!","don't worry, i'm gonna make you better :\)","wow, this is a mess","thanks <3","yay","can you talk to sublime","can you talk to sublime?","can you talk to sublime text?","hm, can you talk to sublime text?","hm. can you talk to sublime text?","help me with a morning update","i wanna refactor acorn.js","yeah","yep","nah","oh, uh, it's over in ✨","nah, like, that thing.","that's a project of mine","belay that"]
// q.map(λ(v){↩ new natural.TreebankWordTokenizer().tokenize(v)})
