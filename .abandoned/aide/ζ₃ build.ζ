#!/usr/bin/env ζ
interleave ← npm('loose-interleave@1.0.0')

;[process.stdout, process.stderr].forEach((s) => {s && s.isTTY && s._handle && s._handle.setBlocking && s._handle.setBlocking(true)}) // sad fix

test_n ← 100
// test_n ← 1e9

js_to_babylon_ast ← npm('babylon@6.8.0').parse
F ← λ(code,fl){ try{ t ← js_to_babylon_ast(code); t = babylon_ast_to_ζ_ast(t,code); ↩ ζ_ast_to_js(t) }catch(e){cn.log('error @',fl); throw e} }
test ← λ(){ 
	h ← hrtime(); φ`~/Downloads/corpus/*`.φs.slice(0,test_n).some(λ(ι,i){t←;
		i%10===0 && cn.log('checking file #',i)
		s ← ι.text; if (s!==(t=F(s,ι))){ cn.log('failed on:',[ι.name]); φ`/tmp/a`.ι = s; φ`/tmp/b`.ι = t; cn.log(shᵥ`bash -ci 'diff /tmp/{a,b}'`+''); process.exitCode=1; ↩1 }
		}); h = hrtime(h)
	h > 0.2 && cn.log('took:',round(h*1e3)/1e3) }
// ast ← js_to_babylon_ast(φ`~/Downloads/corpus/1 1sublimebuild.js`.text)

passes ← 1
check ← λ(ι,…any){ t ← ι._.omit('type','loc',…any); t._.isEqual({}) || (passes--===0 && ‽('extra fields',ι.type,util.inspect(t,{depth:null}))) }
loc_eq ← _.isEqual
_code←; src ← ι=> _code.slice(ι.loc.start.i, ι.loc.end.i)

mk_js ← ι=>0?0: {type:'js', loc:ι.loc, src:src(ι)}
// mk_js ← ι=>0?0: {type:'js', loc:ι.loc}
mk_leaf ← ι=>0?0: {type:'leaf', loc:ι.loc}
mk_ornament ← (ι,child)=> !child? {type:'ornament', loc:ι.loc} : loc_eq(ι.loc,child.loc)? child : {type:'ornament', loc:ι.loc, ι:child}
mk_childs ← (ι,childs)=>0?0: {type:'childs', loc:ι.loc, a:childs}

t←;
table ← {
	'*':ι=>( mk_js(ι) ),
	Program:ι=>( check(ι,'body','directives','sourceType'), ι.sourceType==='script'||‽, mk_childs(ι,[…ι.directives,…ι.body]) ),
	StringLiteral:t= ι=>( check(ι,'value'), mk_leaf(ι) ),
	DirectiveLiteral:t,
	Directive:ι=>( check(ι,'value'), mk_ornament(ι,ι.value) ),
	Identifier:ι=>( check(ι,'name'), mk_leaf(ι) ),
	ExpressionStatement:ι=>( check(ι,'expression'), mk_ornament(ι,ι.expression) ),
	BlockStatement:ι=>( check(ι,'body','directives'), mk_childs(ι,[…ι.directives,…ι.body]) ),
	SequenceExpression:ι=>( check(ι,'expressions'), mk_childs(ι,ι.expressions) ),
	EmptyStatement:ι=>( check(ι), mk_ornament(ι) ),
	ReturnStatement:ι=>( check(ι,'argument'), mk_ornament(ι,ι.argument) ),
	BreakStatement:ι=>( check(ι,'label'), ι.label? mk_js(ι) : mk_ornament(ι) ),
	ContinueStatement:ι=>( check(ι,'label'), ι.label? mk_js(ι) : mk_ornament(ι) ),
	Super:ι=>( check(ι), mk_leaf(ι) ),
	ThisExpression:ι=>( check(ι), mk_leaf(ι) ),
	SwitchStatement:ι=>( check(ι,'discriminant','cases'), mk_childs(ι,[ι.discriminant,…ι.cases]) ),
	SwitchCase:ι=>( check(ι,'test','consequent'), mk_childs(ι,[ι.test,ι.consequent]) ),
	ThrowStatement:ι=>( check(ι,'argument'), mk_ornament(ι,ι.argument) ),
	TryStatement:ι=>( check(ι,'block','handler','finalizer'), mk_childs(ι,[ι.block,ι.handler,ι.finalizer].filter(ι=>ι)) ),
	CatchClause:ι=>( check(ι,'param','body'), mk_childs(ι,[ι.param,ι.body]) ),
	WhileStatement:ι=>( check(ι,'test','body'), mk_childs(ι,[ι.test,ι.body]) ),
	DoWhileStatement:ι=>( check(ι,'body','test'), mk_childs(ι,[ι.body,ι.test]) ),
	ForStatement:ι=>( check(ι,'init','test','update','body'), mk_childs(ι,[ι.init,ι.test,ι.update,ι.body]) ),
	ForInStatement:ι=>( check(ι,'left','right','body'), mk_childs(ι,[ι.left,ι.right,ι.body]) ),
	ForOfStatement:ι=>( check(ι,'left','right','body'), mk_childs(ι,[ι.left,ι.right,ι.body]) ),
	VariableDeclaration:ι=>( check(ι,'declarations','kind'), mk_childs(ι,ι.declarations) ),
	VariableDeclarator:ι=>( check(ι,'id','init'), mk_childs(ι,[ι.id,ι.init]) ),
	ObjectMethod:ι=>( check(ι,'kind','key','computed','value','id','params','body','generator','async'), ‽ ),
	FunctionDeclaration:ι=>( check(ι,'id','params','body','generator','async'), mk_childs(ι,[ι.id,…ι.params,ι.body]) ),
	ArrowFunctionExpression:ι=>( check(ι,'body','expression','id','params','body','generator','async'), mk_childs(ι,[ι.id,…ι.params,ι.body]) ),
	FunctionExpression:ι=>( check(ι,'id','params','body','expression','generator','async'), mk_childs(ι,[ι.id,…ι.params,ι.body]) ),
	YieldExpression:ι=>( check(ι,'argument','delegate'), mk_ornament(ι,ι.argument) ),
	ArrayExpression:ι=>( check(ι,'elements'), mk_childs(ι,ι.elements) ),
	ObjectExpression:ι=>( check(ι,'properties'), mk_childs(ι,ι.properties) ),
	ObjectProperty:ι=>( check(ι,'shorthand','value','key','computed','value'), mk_childs(ι,[ι.key,ι.value]) ),
	RestProperty:ι=>( check(ι,'argument'), mk_ornament(ι,ι.argument) ),
	UnaryExpression:ι=>( check(ι,'operator','prefix','argument'), mk_ornament(ι,ι.argument) ),
	UpdateExpression:ι=>( check(ι,'operator','argument','prefix'), mk_ornament(ι,ι.argument) ),
	BinaryExpression:ι=>( check(ι,'operator','left','right'), mk_childs(ι,[ι.left,ι.right]) ),
	AssignmentExpression:ι=>( check(ι,'operator','left','right'), mk_childs(ι,[ι.left,ι.right]) ),
	LogicalExpression:ι=>( check(ι,'operator','left','right'), mk_childs(ι,[ι.left,ι.right]) ),
	SpreadElement:ι=>( check(ι,'argument'), mk_ornament(ι,ι.argument) ),
	MemberExpression:ι=>( check(ι,'object','property','computed'), mk_childs(ι,[ι.object,ι.property]) ),
	IfStatement:ι=>( check(ι,'test','consequent','alternate'), mk_childs(ι,[ι.test,ι.consequent,ι.alternate].filter(ι=>ι)) ),
	ConditionalExpression:ι=>( check(ι,'test','consequent','alternate'), mk_childs(ι,[ι.test,ι.consequent,ι.alternate]) ),
	CallExpression:ι=>( check(ι,'callee','arguments'), mk_childs(ι,[ι.callee,…ι.arguments]) ),
	NewExpression:ι=>( check(ι,'callee','arguments'), mk_childs(ι,[ι.callee,…ι.arguments]) ),
	TemplateLiteral:ι=>( check(ι,'quasis','expressions'), mk_childs(ι,[…ι.quasis,…ι.expressions]) ),
	TaggedTemplateExpression:ι=>( check(ι,'tag','quasi'), mk_childs(ι,[ι.tag,ι.quasi]) ),
	TemplateElement:ι=>( check(ι,'tail','value','cooked','raw'), mk_leaf(ι) ),
	RegExpLiteral:ι=>( check(ι,'pattern','flags'), mk_leaf(ι) ),
	NumericLiteral:ι=>( check(ι,'value'), mk_leaf(ι) ),
	ObjectPattern:ι=>( check(ι,'properties'), mk_childs(ι,ι.properties) ),
	ArrayPattern:ι=>( check(ι,'elements'), mk_childs(ι,ι.elements) ),
	RestElement:ι=>( check(ι,'argument'), mk_ornament(ι,ι.argument) ),
	AssignmentPattern:ι=>( check(ι,'left','right'), mk_childs(ι,[ι.left,ι.right]) ),
	}
babylon_ast_to_ζ_ast ← λ({program:ast,comments},code){ _code = code
	ast = walk_obj_map(ast,ι=>( delete ι.extra, ι.leadingComments===null && delete ι.leadingComments, ι.trailingComments===null && delete ι.trailingComments, ι.guardedHandlers && ι.guardedHandlers.length===0 && delete ι.guardedHandlers, ι))
	q ← (ι,m)=>0?0:{i:ι[m], r:ι.loc[m].line-1, c:ι.loc[m].column}; ast = walk_obj_map(ast,ι=>( ι.loc && (ι.loc = {start:q(ι,'start'), end:q(ι,'end')}, delete ι.start, delete ι.end), ι))
	↩ walk_obj_map(ast, ι=> ι.type? table[table[ι.type]? ι.type : '*'](ι) : ι)
	}
ζ_ast_to_js ← λ(ι){
	switch(ι.type){default: ‽
		case 'js': ↩ src(ι)
		case 'seq':
			betweens ← _.zip([ι.loc.start.i,…ι.a.map(ι=> ι.loc.end.i)],[…ι.a.map(ι=> ι.loc.start.i),ι.loc.end.i]).map(([a,b])=> _code.slice(a,b))
			↩ interleave(betweens, ι.a.map(ι=> src(ι))).join('')
		}
	}
// ζ_ast_to_ζ ← λ(ι){
// 	switch(ι.type){default: ‽
// 		case 'js': ↩ src(ι)
// 		'js```'++'```'
		
// 		case 'seq':
// 			betweens ← _.zip([ι.loc.start.i,…ι.a.map(ι=> ι.loc.end.i)],[…ι.a.map(ι=> ι.loc.start.i),ι.loc.end.i]).map(([a,b])=> _code.slice(a,b))
// 			↩ interleave(betweens, ι.a.map(ι=> src(ι))).join('')
// 		}
// 	}

test()

// Directive = `'use strict';` or even `'use strict'  ;` or even `'use strict'\n  ;` but not `'use strict'\n `

// needs a tighter bind and .P and .X

proposal: ⁺tag system wherein /⁺[^\s⁺]+/ forms a postfix annotation to record information that would have been lost in a transformation

