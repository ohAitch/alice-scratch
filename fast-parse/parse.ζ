#!/usr/bin/env Î¶
exportsâ†; exports || ( exports = global )
P â† require('./parsimmon')

;(=>{
	{Râ‚:R} â† require('./record')
	P.prototype.R = Î»(ss,â€¦Î¹s){ Î¹s = [â€¦Î¹s,âˆ…]; ss = [â€¦ss,''] <- ({raw:[â€¦ss.raw,'']}); â†© @.map(Î¹=>{ Î¹s[-1] = Î¹; â†© R(ss,â€¦Î¹s) }) }
	walk_regex â† (Î¹,f)=> Î¹ |> (Î» Î›(Î¹){ if (Î¹ && Î¹.tag){
		clone â† _.once(=>{ Î¹ = R`` <- (Î¹) })
		change â† (a,f=Object.is)=>{ for(var k in a) f(Î¹[k],a[k]) ||( clone(), Î¹[k] = a[k] ); â†© Î¹ }
		if (Î¹.Î¹) Î¹ = change({ Î¹: Tarr(Î¹.Î¹)? Î¹.Î¹.map(Î›) : Î›(Î¹.Î¹) })
		Î¹ = f(Î¹,{change})
		}; â†© Î¹ })

	skip_ğ…°ğ…¦ğ…ğ…¦ğ…°â†; ğ…ğ…ğ…¯ğ…¦ğ…‚â†;

	Regex â† (=>{
		Regex â† =>Regex
		hex â† /[0-9a-fA-F]/u
		Escape â† P([ '\\', P.alt([
			P.alt([ re`x(${hex}{2})`, re`u\{(${hex}+)\}`, re`u(${hex}{4})` ]).map(Î¹=> chr(parseInt(Î¹[1],16))),
			P(/c([A-Z])/).map(Î¹=> chr( ord(Î¹[1]) - ord('A') + 1 )),
			P(/[trnvf0]/).map(Î¹â‡’ {t:'\t',r:'\r',n:'\n',v:'\v',f:'\f',0:'\0'}[Î¹]),
			P(/[dDwWsSbB]/).map(Î¹=> $({
				d:/[0-9]/u,
				w:/[A-Za-z0-9_]/u,
				s:/[ \f\n\r\t\v\xa0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/u,
				b:String.raw`(?<=\w)(?!\w)|(?<!\w)(?=\w)`,
				D:/[^\d]/u, W:/[^\w]/u, S:/[^\s]/u, B:/(?!\b)/u,
				}[Î¹])),
			P(/[1-9][0-9]*/).map(Î¹=> R`#backref ${Î¹|0}`),
			/[^]/,
			]), ]).map(Î¹=>Î¹[1])
		Set_Escape â† P.alt([ P('\\b').map(=>'\b'), Escape ])
		Unit â† P.alt([
			Escape,
			P('.').map(=> $(/[^\n\r\u2028\u2029]/u)),
			P(['(?:',Regex,')']).map(Î¹=>Î¹[1]),
			P(['(?!',Regex,')']).map(Î¹=>Î¹[1]).R`#not`,
			P(['(?=',Regex,')']).map(Î¹=>Î¹[1]).R`#not`.R`#not`,
			P(['(?<=',Regex,')']).map(Î¹=>Î¹[1]).R`#behind`,
			P(['(?<!',Regex,')']).map(Î¹=>Î¹[1]).R`#behind`.R`#not`,
			P(['(',Regex,')']).map(Î¹=>Î¹[1]).R`#capture`,
			P(['[', /\^?/, (=>{ t â† P.alt([ Set_Escape,/[^\]]/ ]); â†© P.alt([ P([t,'-',t]).map(Î¹=>[Î¹[0],Î¹[2]]), t ]).* })(), ']'])
				.map(([Ë£,not,Î¹,Ê¸])=>{ r â† R`#alt ${Î¹.map(Î¹=> Tarr(Î¹)? R`#alt_range ${Î¹}` : Î¹ )}`; if (not) r = R`#seq ${[ R`#complement ${r}`, R`#any` ]}`; â†© r }),
			P(/[$^]/).R`#^$`,
			/[^)]/,
			])
		Postfix â† P([ Unit, P([ P.alt([ '*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/ ]), P('?').?, ]).? ]).map(([Î¹,rep])=>{
			if (!rep) â†© Î¹
			for_ â† Î¹=> Î¹==='*'? [0,âˆ] : Î¹==='+'? [1,âˆ] : Î¹==='?'? [0,1] : (=>{ [Ë£,a,two,b] â† Î¹; â†© [a|0,b? b|0 : two? âˆ : a|0] })()
			â†© R({ Î¹, for:for_(rep[0]), greedy:!rep[1], }).+=`#repeat` })
		Infix â† Postfix.*?.R`#seq`.sep_by('|').?.map(Î¹=> Î¹.â€–===1? Î¹[0] : R`#alt ${Î¹}` )
		Regex â† Infix
		â†© Regex })()
	parse_regex â† Î¹=>{ flags â† Î¹.flags||'u'; Î¹ = Î¹.source||Î¹
		if (!flags.re`u`) â€½('can only parse unicode regex')
		if (flags.re`y`) â€½('no /y support yet') // should it be handled separately? // r = R`#seq ${[R`#sticky`,r]}`
		if (flags.re`i`) â€½('no /i support yet') // r = R`#ignore_case ${r}`
		if (flags.re`g`) â€½('/g should be handled separately')
		// g should be part of the call, not the regex (split no care, search no care, replace care simple, match care simple, exec care weird)

		Î¹ = Regex.exec(Î¹)
		walk_regex(Î¹,Î¹=>{
			if( Î¹.â‰ˆ`#^$` ) if( flags.re`m` ) Î¹.Î¹ += 'm'
			})
		# Î¹ |> (Î» Î›(Î¹){ if (Î¹ && Î¹.tag){
		# 	if (Î¹.Î¹) Tarr(Î¹.Î¹)? Î¹.Î¹.map(Î›) : Î›(Î¹.Î¹)
		# 	if( Î¹.â‰ˆ`#^$` ) if( flags.re`m` ) Î¹.Î¹ += 'm'
		# 	}; â†© Î¹ })
		â†© Î¹ }
	normalize_to_axioms_regex â† Î¹=>{
		Î¹ = walk_regex(Î¹,(Î¹,{change})=>{
			is_null â† Î¹=> Tstr(Î¹)? âœ— : ( (Î¹.â‰ˆ`#alt` || Î¹.â‰ˆ`#seq`) && Î¹.Î¹.every(is_null) ) || ( Î¹.â‰ˆ`#not` && is_bottom(Î¹.Î¹) )
			is_bottom â† Î¹=> Tstr(Î¹)? âœ— : ( Î¹.â‰ˆ`#alt` && Î¹.Î¹.every(is_bottom) ) || ( Î¹.â‰ˆ`#seq` && Î¹.Î¹.some(is_bottom) ) || ( Î¹.â‰ˆ`#not` && is_null(Î¹.Î¹) )
			if( Î¹.â‰ˆ`#seq` ){
				Î¹ = change({ Î¹: Î¹.Î¹.mapâ€¦(Î¹=> Î¹.tag && Î¹.â‰ˆ`#seq`? Î¹.Î¹ : [Î¹] ) }, _.isEqual)
				if (Î¹.Î¹.â€–===1) â†© Î¹.Î¹[0]
				}
			if( !skip_ğ…°ğ…¦ğ…ğ…¦ğ…° ) [[is_null,/(?:)/u],[is_bottom,/(?!)/u]].forEach(([f,r])=>{ if (f(Î¹)){ skip_ğ…°ğ…¦ğ…ğ…¦ğ…° = âœ“; r = $(r); skip_ğ…°ğ…¦ğ…ğ…¦ğ…° = âœ—; â†© r } })
			// if( Î¹.â‰ˆ`#complement` && Î¹.Î¹.â‰ˆ`#set` && !Î¹.Î¹.Î¹.â€– ) â†© $(/(?:)/u)
			if( Î¹.â‰ˆ`#^$` ) â†© $({ '^':'(?<![^])', '$':'(?![^])', '^m':'(?<![^\n\r])', '$m':'(?![^\n\r])' }[Î¹.Î¹])
			â†© Î¹ })
		â†© Î¹ }
	parse_normalize_regex_memoized â† Î¹=>{ t â† Î¹ |> (ğ…ğ…ğ…¯ğ…¦ğ…‚||(ğ…ğ…ğ…¯ğ…¦ğ…‚= memoize_proc(Î¹=> normalize_to_axioms_regex(parse_regex(Î¹)) ) )); â†© copy_deep(t) <- ({tag:t.tag}) }
	$ â†Â parse_normalize_regex_memoized

	t â† { Regex,parse_regex,normalize_to_axioms_regex }
	exports <- (t)

	if_main_do(=>{ [
		/(?:(|))/u,
		/(|)/u,

		/(#!.*\n)?$/u,
		/foo[a-x]/u,
		/^(foo)?(?:b(b.)){2,7}\baz[^]??[^\n](?:\\b.ar|\b[\ba-c-e()}][^\s]|b*?|baz(gremlin\u2424$)?(?!groblem)|)*\3/u,
		/\{([0-9]+)(?:(,)([0-9]*))?\}/u,
		/[^imu]/u,
		/(['"])((\\.|(?!\1|\\)[^])*?\1)/u,
		/(?:\\[^]|(?!`|\$\{)[^])+/u,

		// fix:
		/[\d]/u,
		/[^\d]/u,
		/[\D]/u,
		/[^\D]/u,
		].forEach(Î¹=> cn.log('test:parse_regex',Î¹,'=',normalize_to_axioms_regex(parse_regex(Î¹))))
		})

	})()
