P â† require_new(Ï†`~/code/scratch/fast-parse/parser`)
##################################### note #####################################
# conceptual: word s refer to the procedure-local database of words we know about

# modules: âœ“ âœ— null âˆ… â€–

# words create a tree structure
# words are considered in a particular order
# it is almost as if words are parsed first via a lexer, but it is not quite

# parenless function calls? mb figure those out after you get this working. this is haard.

################################ grammar 0 flesh ###############################
prefix â† (Î¹,f=Î¹=>Î¹)=> P([Î¹,á›Ÿ1,f(_)]).map(..2).Tag(Î¹)
# free â† 'â—Š'
_s â† =>[
	# ,[/(['"])(((?!\1)[^\\]|\\.)*?\1)/]
	,[_,á›Ÿ2,'.',á›Ÿ1,_]
	,[_,á›Ÿ2,'â€˜.',á›Ÿ1,_]
 	,[_,á›Ÿ1,'(',top,')']
	,[_,'[',_,']'].join2(á›Ÿ1)
	,[_,'â€˜[',_,']'].join2(á›Ÿ1)
	,['^'].map(Î¹=> infix(Î¹) â€¦â† ({ right:âœ“ }) )
	,['!','-'].map(prefix)
	,_2`Ã— /`
	,[ ,infix('+') ,[ P.|([ free,_ ]),á›Ÿ1,'-',á›Ÿ2,_ ] ]
	,_2`âˆª âˆ©`
	,_2`â€¦â†`
	,_2`= â‰  <= >= < > âˆˆ âˆ‹`
	,_2`& |`
	,_2`!> |>`
	,[_,'?',_,':',_].join2(á›Ÿ2)
	,P([ 'if',_,P(':').?,_,P(/:|else/).?,_ ].join2(á›Ÿ2)).map(Î¹=>[ Î¹[2],Î¹[6],Î¹[10] ]).Tag`if`
	# ,[word('if'),_,P(':').?,_,P.|([ ':',word('else') ]).?,_].join2(á›Ÿ2)
	,['â†','â†!'].map(Î¹=> infix(Î¹) â€¦â† ({ right:âœ“ }) )
	,['â€¦'].map(prefix)
	,['â†©',á›Ÿ1,_.?]
	,[_,á›Ÿ1,'â‡’',á›Ÿ2,_]
	,_2`:`
	# ,['()','[]','{}'].map(([a,b])=> [a,top,b])
	# ,[P.unicode_category(/[LNPMS]./).+]
	].map(Î¹=> Î¹.every(Tarr)? Î¹ : [Î¹] )

################################ grammar 1 flesh ###############################
leaf_prefixd â† P.|([
	,P.err_if_partial( /['"]/,P(/(['"])(((?!\1)[^\\]|\\.)*?)\1/).map(([Ë£,Ê¸,Î¹])=> Î¹) )
	])
_ â† P.|([
	,leaf_prefixd
	,P([ P.not(leaf_prefixd),P.unicode_category(/[LNPMS]./) ]).map(..1).+ .map(.join('')).Tag`id`
	]).catch(P.err_if_partial)

############################### grammar -1 flesh ###############################
# a simple infix parser
P.build_op = (unit,op)=>{
	# binary left: 1-2-3 = (1-2)-3  ;binary right: 1^2^3 = 1^(2^3)
	# ,'2 center':p=> P([ p, P.seq(op,p).*.map(Î¹=> _(Î¹).flatten(âœ“)) ]).map(([a,op_bs])=> !op_bs.length? a : R('op',{A:'2 center', Î¹:[a, â€¦op_bs]}) )
	_1L â† p=>{ r â† P(=> P.|([ P([ op,r ]).map(([op,Î¹])=> [op,âˆ…,Î¹]) ,p ])) ;â†© r }
	_1R â† p=> P([ p, op.* ]).map(([x,r])=> r.fold((Î¹,op)=> [op,Î¹,âˆ…], x) )
	_2L â† p=> P([ p, P([ op,p ]).* ]).map(([x,r])=> r.fold((a,[op,b])=>[op,a,b], x) )
	_2R â† p=>{ r â† P(=> p.chain(a=> P.|([ P([ op, r ]).map(([op,b])=>[op,a,b]) ,P.of(a) ])) ) ;â†© r }
	â†© unit |>(_2L) |>(_1L) |>(_1R) }

# [ '.','Ã—','+','->' ].fold(P.build_op,/[A-Za-zğŸ”’Î¹]+/)
# Â§`obj Ã— id -> place`
# Â§`-> ğŸ”’ Ã— hide`
# Â§`-> host`

################################### grammar 3 ##################################
# ok this is cute but lets just hardcode a lexer and get on with it
# hardcoded lexer + word prioritization (read time) (the way clojure does macros should be good enough)

â§«. parse_lang ==>{

Î³.words = P(Set(
	,sharp= P(Set(
		,P(/(['"])(((?!\1)[^\\]|\\.)*?)\1/).map(..2).Tag`string`
		,P(/[ \t\n,]+/).map(Î¹=> Î¹.includes(',')? 3 : Î¹.includes('\n')? 2 : 1 ).Tag`space`
		,RegExp(re(alt_ws`( ) [ ] { } . â€˜ + - Ã— / ^ * âˆª âˆ© â€¦â† = â‰  <= >= < > âˆˆ âˆ‹ & | !> |> ? : â† â†! â†© â‡’`))
		))
	,RegExp(re(alt_ws`! â€¦`))
	,P([ P.not(sharp),P.unicode_category(/[LNPMS]./) ]).map(..1).+ .map(.join(''))
	)).* ;sharpâ†;

id â† Î¹=> P.any1.filter(t=> t===Î¹)
Î³.trees = P(=>trees) ;trees = P(Set(
	,â€¦ ['()round','[]square','{}curly'].map(Î¹=> P([ ,id(Î¹[0]),trees,id(Î¹[1]) ]).map(..1).Tag(Î¹.slice(2)))
	,P.any1.filter(Î¹=> ! [â€¦'()[]{}'].includes(Î¹) )
	)).*

_2 â† Î¹=> (Î¹+'').split(' ').map(Î¹=> P([ _,Î¹,_ ]).map(Î¹=> [Î¹[0],Î¹[1]]).Tag(Î¹).join(á›Ÿ2) )
á›Ÿ1 â† P.any1.filter(Î¹=> Î¹.tag==='space' && Î¹.Î¹<=1 ).?
á›Ÿ2 â† P.any1.filter(Î¹=> Î¹.tag==='space' && Î¹.Î¹<=2 ).?
á›Ÿ3 â† P.any1.filter(Î¹=> Î¹.tag==='space' && Î¹.Î¹<=3 ).?
# Î³.ops = P(=>ops) ;ops =

â†© Î¹=> [words,trees].fold((Î¹,p)=> p.parse(Î¹) ,Î¹) }

;[
	,"if 'handle' 5 : 6 7"
	,"if 'handle' 5 : 6? 7:8"
	,"yield'saddlepoint'"
	,"â†© ['saddlepoint' [bogan]()]"
	,"â€¦ ! â†©â† 5"
	,"â€¦! â†©â†"
	]
	.map(parse_lang.X)
