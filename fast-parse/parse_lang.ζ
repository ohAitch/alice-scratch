Ps ← require_new(φ`~/code/scratch/fast-parse/parser`)

##################################### note #####################################
# conceptual: word s refer to the procedure-local database of words we know about

# modules: ✓ ✗ null ∅ ‖

# words create a tree structure
# words are considered in a particular order
# it is almost as if words are parsed first via a lexer, but it is not quite

# parenless function calls? mb figure those out after you get this working. this is haard.

################################ grammar 1 flesh ###############################
# P.err_if_partial = (a,b)⇒
# 	: b? P([ P.if(P(a)) ,P(b).? ]).map(([ˣ,ι])=> ι===∅? ‽(𐅮𐅦𐅨𐅝𐅃) : ι)
# 	: a===𐅮𐅦𐅨𐅝𐅃 || ‽(a)
# 	𐅮𐅦𐅨𐅝𐅃 ← Error()

# leaf_prefixd ← P(Set(
# 	,P.err_if_partial( /['"]/,P(/(['"])(((?!\1)[^\\]|\\.)*?)\1/).map(([ˣ,ʸ,ι])=> ι) )
# 	))
# _ ← P(Set(
# 	,leaf_prefixd
# 	,P([ P.not(leaf_prefixd),P.unicode_category(/[LNPMS]./) ]).map(..1).+ .map(.join('')).Tag`id`
# 	)).catch(P.err_if_partial)

################################### grammar 3 ##################################
# ok this is cute but lets just hardcode a lexer and get on with it
# hardcoded lexer + word prioritization (read time) (the way clojure does macros should be good enough)

⧫. parse_lang ==> ι=> [word.*,tree.*,top].fold((ι,p)=> p.parse(ι) ,ι)

##############################
P ← Ps.string
word ← P(Set(
	,sharp= P(Set(
		,P(/(['"])(((?!\1)[^\\]|\\.)*?)\1/).map(..2).Tag`string`
		,P(/[ \t\n,]+/).map(ι=> ι.includes(',')? 3 : ι.includes('\n')? 2 : 1 ).Tag`space`
		,re(alt_ws`( ) [ ] { } . ‘ + - × / ^ * ∪ ∩ …← = ≠ <= >= < > ∈ ∋ & | !> |> ? : ← ←! ↩ ⇒`)
		))
	,re(alt_ws`! …`)
	,P([ P.not(sharp),P.unicode_category(/[LNPMS]./) ]).map(..1).+ .map(.join(''))
	)) ;sharp←;

##############################
P ← Ps.list
tree ← P(=>tree) ;tree ← P(Set(
	,… ['()','[]','{}'].map(ι=> P([ ,ι[0],tree.*,ι[1] ]).map(..1).Tag(ι) )
	,P.filter(ι=> ! […'()[]{}'].includes(ι) )
	))

##############################
build_ops1 ← (op_ord)=>{
	op_ord=op_ord .map(ι=> T.Set(ι)? ι : Set(ι) )
	ops ← Set(…op_ord.…)
	𐅪 ← ι=> op_ord.findIndex(t=> […t].some(t=> t.id===ι.id))
	cmp ← new Map()
	ops.map(a=> ops.map(b=> cmp.set…(a,b, 𐅪(b) - 𐅪(a) ) ))
	↩ {ops,cmp} }

# _2 ← ι=> (ι+'').split(' ').map(ι=> P([ _,ι,_ ]).map(ι=> [ι[0],ι[1]]).Tag(ι).join(ᛟ2) )
ᛟ ← ordid=> ι=> ι.tag==='space' && ι.ι<=ordid
ᛟ1 ← P.filter(ᛟ(1)).?
ᛟ2 ← P.filter(ᛟ(2)).?
ᛟ3 ← P.filter(ᛟ(3)).?

_2            ← ι=> alt_ws(ι).map_(ι⇒{ ,id:ι ,P:P([ᛟ2,ι,ᛟ2]).map(..1).map(ι=>[ ι,𐅃o(ι) ]) ,post:✓ })
_2_norm_tight ← ι=> alt_ws(ι).map_(ι⇒{ ,id:ι ,P:P([ᛟ2,ι,ᛟ1]).map(..1).map(ι=>[ ι,𐅃o(ι) ]) ,post:✓ })
_2_tight_norm ← ι=> alt_ws(ι).map_(ι⇒{ ,id:ι ,P:P([ᛟ1,ι,ᛟ2]).map(..1).map(ι=>[ ι,𐅃o(ι) ]) ,post:✓ })
{ops,cmp} ← build_ops1([
	,_2_norm_tight`.`
	# ,_2_norm_tight`. ‘.`
	,{ ,id:'_(_)'  ,P:P([ᛟ1,    P.filter(.tag==='()')]).map(..1).map(ι=>[ ι,𐅃o('_(_)' ) ]) ,map([ι,a]){↩[ @.id,a,…top.parse(ι.ι) ]} }
	,{ ,id:'_[_]'  ,P:P([ᛟ1,    P.filter(.tag==='[]')]).map(..1).map(ι=>[ ι,𐅃o('_[_]' ) ]) ,map([ι,a]){↩[ @.id,a,…top.parse(ι.ι) ]} }
	,{ ,id:'‘_[_]' ,P:P([ᛟ1,'‘',P.filter(.tag==='[]')]).map(..2).map(ι=>[ ι,𐅃o('‘_[_]') ]) ,map([ι,a]){↩[ @.id,a,…top.parse(ι.ι) ]} }
	,_2`^`
	# ,['!','-'].map(prefix)
	,_2`× /`
	# ,[,[ P(Set( free,_ )),ᛟ1,'-',ᛟ2,_ ] ]
	,_2`+ -`
	,_2`∪ ∩`
	,_2`…←`
	,_2`= ≠ <= >= < > ∈ ∋`
	,_2`& |`
	,_2`!> |>`
	# ,[_,'?',_,':',_].join2(ᛟ2)
	# ,[ 'if',_,P(':').?,_,P(/:|else/).?,_ ].join2(ᛟ2)
	,_2`←`
	# ,['…'].map(prefix)
	# ,['↩',ᛟ1,_.?]
	,_2_tight_norm`⇒`
	,_2`:`
	])
ops_lt_ ← a=> ops.filter(b=> cmp.get…(𐅃o_if(a),b)<0 )
𐅃o ← ops.index(.id) ‘.get .f ;𐅃o_if ← a=> Tstr(a)? 𐅃o(a) : a
ops.map(ι=> cmp.set…(ι,ι,1) )
;['^','←'].map(𐅃o).map(ι=> cmp.set…(ι,ι,-1) )
ops_lt_('←').filter(.post).filter(.id!=='.') .map(a=> cmp.set…(a,𐅃o('←'),-1) )
ops_lt ← new Map(ops.map(a=>[a, ops_lt_(a) ]))

𐅯𐅮word ← P.not(ops).then(P.any1).?
𐅋𐅬op ← (ops,p)=> p.chain(a=> Set(
	,𐅋𐅬op(ops, P(ops).chain(([ι,o])=>{ m ← o.map? o‘.map .f : ι=>ι ;↩ !o.post? P.of(m([ ι,a ])) : 𐅋𐅬op(ops_lt.get(o),𐅯𐅮word).map(b=> m([ ι,a,b ])) }) )
	,P.of(a) ) )
top ← 𐅋𐅬op(ops,𐅯𐅮word).join2?(ᛟ3)

# if 'handle' 5 : 6 7
# if 'handle' 5 : 6? 7:8
# yield'saddlepoint'
# … ! ↩← 5
# …! ↩←
;(ι=>ι)`
an.i.mal + so.und + cloud.grey('space') x y
space ^ azo ^ now
.+. + c + .d2^d3 × e← b + b
a b c d e
↩ ['saddlepoint' [bogan]()]
` |>(ι=>[ ,lines(ι).map(parse_lang).… ,parse_lang(ι+'') ])

