#!/usr/bin/env Î¶
# parse_lang(Ï†`~/code/scratch/fast-parse/parse_lang.Î¶`.text)

############## app prelude #############
Ps â† require_new(Ï†`~/code/scratch/fast-parse/parser`)
ğ…¬Tag â† (â€¦Î¹)â‡’{ ,tag:Î¹[0] ,inspect:=>Tag(â€¦Î¹) }

################# entry ################
â§«. parse_lang ==> Î¹=> [words,tree.*,ğ…ªğ…¨s_s].fold((Î¹,f)=>{ f===ğ…ªğ…¨s_s &&( Î³.ğ…¬ğ…œğ…ğ…ƒğ…‹ = âœ“ ) ;râ† ;log('bench',bench1(=> r = Î¹ && f.parse(Î¹) )) ;â†© r },Î¹)

################# word #################
P â† Ps.string
P.err_if_partial = (a,b)â‡’
	: b? P([ P.if(P(a)) ,P(b).? ]).map(([Ë£,Î¹])=> Î¹===âˆ…? â€½(ğ…®ğ…¦ğ…¨ğ…ğ…ƒ) : Î¹)
	: a===ğ…®ğ…¦ğ…¨ğ…ğ…ƒ || â€½(a)
	ğ…®ğ…¦ğ…¨ğ…ğ…ƒ â† Error()

words â† P(Set(
	,sharp= P(Set(
		,P.err_if_partial( /['"]/,P(/(['"])(((?!\1)[^\\]|\\.)*?)\1/).map(..2) ).Tag`string`
		,P(Set(
			,P(/[ \t\n,]+/).map(Î¹=> Î¹.includes(',')? 3 : Î¹.includes('\n')? 2 : 1 )
			,P(/#[\s#].*/).map(=>2) )
			).+.map(.fold((a,b)=> max(a,b))).Tag`space`
		,re(alt_ws`( ) [ ] { } . â€˜ + - Ã— / ^ * âˆª âˆ© â€¦â† = â‰  <= >= < > âˆˆ âˆ‹ & | !> |> ? : â† â†! â†© â‡’ =>`)
		))
	,re(alt_ws`! â€¦`)
	,P([ P.not(sharp),P.unicode_category(/[LNPMS]./) ]).map(..1).+ .map(.join(''))
	)).*.catch(P.err_if_partial) ;sharpâ†;

################# tree #################
P â† Ps.list
tree â† P(=>tree) ;tree â† P(Set(
	,â€¦ ['()','[]','{}'].map(Î¹=> P([ ,Î¹[0],tree.*,Î¹[1] ]).map(..1).Tag(Î¹) )
	,P.filter(Î¹=> ! [â€¦'()[]{}'].includes(Î¹) )
	))

############## ops: tools ##############
is0_ â† .p[0]===ğ…­
ğ…­ â† P(=>â€½('_')) â€¦â†(ğ…¬Tag('_'))
[á›Ÿ1,á›Ÿ2,á›Ÿ3] â† [1,2,3].map(ordid=> P.filter(Î¹=> Î¹.tag==='space' && Î¹.Î¹<=ordid).? â€¦â†(ğ…¬Tag('á›Ÿ'+ordid)) )
ğ…®ğ…¦ğ…­ğ…œğ…¬ â† =>{
	Î³.ğ…ƒğ…ƒğ…ƒğ…‹ğ…œ = ğ…œğ…©ğ…¬ğ…®ğ…©.map(Î¹=> T.Set(Î¹)? Î¹ : Set(Î¹) )
	Î³.ops = Set(â€¦ğ…ƒğ…ƒğ…ƒğ…‹ğ…œ.â€¦)
	ops.map( .inspect= Î»(){â†© Tag('op',@.id) } )
	Î³.as_op = Î¹=> Tstr(Î¹)? ğ…«ğ…«ğ…‚ğ…°ğ…©(Î¹) : Î¹ ;ğ…«ğ…«ğ…‚ğ…°ğ…© â† ops.group_uniq(.id) â€˜.get .f
	}

############## ops: define #############
Ptree â† memoize_proc(tag=> P.filter(.tag===tag) â€¦â†(ğ…¬Tag('filter',tag)) )
# op: {,id,p,map}
ğ…‚ğ…¬ â† f=> Î»(Î¹){â†© Tag( @.id ,f(Î¹) ) }
ğ…¯R â† (id,â€¦p)â‡’{ ,id ,p ,map:ğ…‚ğ…¬(Î¹=>{ [a,t] â† Î¹.â€–===1? [âˆ…,Î¹[0]] : Î¹ ;t = Tarr(t)? t[-1] : t ;â†©[ a,â€¦ğ…ªğ…¨s_s.parse(t.Î¹) ] }) }
ğ…¯n â† (id,p)=>{ t â† is0_({p})? ..0 : ..1 ;â†©{ ,id ,p ,map:ğ…‚ğ…¬(.chunk(2).map(t)) } }
ğ…¯2 â† (id,â€¦Î¹)=> ğ…¯n(id,[ğ…­,â€¦Î¹,ğ…­])
R_ â† Î¹=> alt_ws(Î¹).map_(Î¹â‡’{ ,id:Î¹ ,p:[Î¹,á›Ÿ1,ğ…­] ,map:ğ…‚ğ…¬(.-1) })
_2 â† Î¹=> alt_ws(Î¹).map_(Î¹=> ğ…¯2(Î¹,á›Ÿ2,Î¹,á›Ÿ2) )

ğ…œğ…©ğ…¬ğ…®ğ…© â† [
,'.'|>(Î¹=> ğ…¯2(Î¹,á›Ÿ2,Î¹,á›Ÿ1))
,ğ…¯2('â€˜.',á›Ÿ2,'â€˜','.',á›Ÿ1)
,ğ…¯R('()',ğ…­,á›Ÿ1,Ptree('()'))
,ğ…¯R('[]',ğ…­,á›Ÿ1,Ptree('[]'))
,ğ…¯R('{}',Ptree('{}'))
,ğ…¯R('â€˜[]',ğ…­,á›Ÿ1,'â€˜',Ptree('[]'))
,_2`^`
,R_`!`
,_2`Ã— /`
,Set( ,â€¦_2`+` ,'-'|>(Î¹=> ğ…¯2(Î¹,á›Ÿ1,Î¹,á›Ÿ2)) )
,_2`âˆª âˆ©`
,_2`â€¦â†`
,_2`= â‰  <= >= < > âˆˆ âˆ‹`
,_2`& |`
,_2`!> |>`
,ğ…¯n('if?',[ğ…­,'?',ğ…­,':',ğ…­].join2(á›Ÿ2))
,ğ…¯n('if_',['if',ğ…­,P(':').?,ğ…­,P(/:|else/u).?,ğ…­].join2(á›Ÿ2))
,alt_ws`â‡’ =>`.map_(Î¹=> ğ…¯2(Î¹,á›Ÿ1,Î¹,á›Ÿ2))
,_2`â†`
,R_`â†© â€¦`
,_2`:`
# ,{ ,id:'ğ…¬word' ,p:[P.filter(.tag!=='space')] ,map:..0..0 }
,{ ,id:'ğ…¬word' ,p:[P.not(=> ops.map_(ğ…ªPa.X)).then(P.filter(.tag!=='space'))] ,map:..0..0 }
]
ğ…®ğ…¦ğ…­ğ…œğ…¬()

ğ…ƒop< â† it=> ops.filter(sub=>
	cmp.getâ€¦(it,sub)
	|| it===sub? alt_ws`^ â† â‡’ => if?`.has(it.id)
	: ğ…°(it) > ğ…°(sub) )
	ğ…° â† Î¹=> ğ…ƒğ…ƒğ…ƒğ…‹ğ…œ.findIndex(.has(Î¹))
cmp â† new Map()
	b â† 'â†' ;ğ…ƒop<(b).filter(.id!=='.') .map(a=> cmp.setâ€¦(a,as_op(b),âœ“) )
	a â† '-' ;c â† '!' ;ğ…ƒop<(a).-(ğ…ƒop<(c)) .map(b=> cmp.setâ€¦(as_op(a),b,âœ—) )
ğ…ƒğ…­op_b_ops â† memoize_proc(op=>Set( ,â€¦ops.filter(is0_.!).filter(.id!=='ğ…¬word') ,â€¦ğ…ƒop<(op) ,as_op('ğ…¬word') ))

############## ops: parse ##############
ğ…­2 â† memoize_proc(op=> P(=> ğ…ªğ…¨_(ğ…ƒğ…­op_b_ops(op)).? ) â€¦â†(ğ…¬Tag('ğ…­')) )
ğ…ªP â† memoize_proc(op=> op.p.edge_comple(Î¹=>Î¹===ğ…­) .map(Î¹=> Î¹.â€–===1&&Î¹[0]===ğ…­? ğ…­2(op) : Î¹) )
ğ…ªPa â† (op,a)=> ğ…ªP(op) |>(Î¹=> is0_(op)? Î¹.slice(1) : Î¹) |>(P) .map(Î¹=> op.map(!is0_(op)? Î¹ : [a,â€¦Î¹]) )
ğ…®ğ…œğ…¯ğ…œğ…« â† memoize_proc(.filter(is0_))
ğ…¨ğ…ƒ_ â† memoize_proc( ops=>a=> P(ops.map_(op=> ğ…ªPa(op,a) )).chain(a=>Set( ,ğ…¨ğ…ƒ_(ğ…®ğ…œğ…¯ğ…œğ…«(ops))(a) ,P.of(a) )) )
ğ…ªğ…¨_ â† ops=> ğ…¨ğ…ƒ_(ops)(âˆ…) # .filter(Î¹=> Î¹.tag === )
ğ…ªğ…¨s_s â† ğ…ªğ…¨_(ops).join2?(á›Ÿ3)

# oh dear. putting ğ…¬word in that place ......... breaks
# we really need to only parse ğ…¬word if we cant parse any ops, even ones were not considering in the moment. um.

################# test #################
parse_lang(`a b`)

parse_lang(`
aâ†©b â€¦ ! â†©
bar â† cmp_is â† (a,b,Î¹)=> => cmp.setâ€¦(as_op(a),as_op(b),Î¹)
if( 'handle' ) 5 else 6? 7 : 8? 9 : 0
! x + 8.{7} Ã— bâ† c+++++,
{{ 'saddlepoint' [] () {} }} ;â†© {P([5])}
`)
