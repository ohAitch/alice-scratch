# a parser is a function. typically: from a string. to a mostly ordered tree. taking non-overlapping substrings to tree nodes. mostly monotonic.

module.exports‚Äò.string .thunk==> parser('string')
module.exports‚Äò.list .thunk==> parser('list')
parser ‚Üê type=>{

##################################### entry ####################################
P0 ‚Üê (tag,Œπ)=> new_(P) ‚Ä¶‚Üê ({tag},Œπ)
P ‚Üê Œπ‚áí
	: Œπ===‚àÖ||Œπ===null? ‚ÄΩ(js2`P(${Œπ})`)
	: P ‚àã (Œπ)? Œπ
	: Tfun(Œπ)? _graph_thunk(Œπ)
	: Tarr(Œπ)? _seq(Œπ.map(P.X))
	: T.Set(Œπ)? _alt(Œπ.map(P.X))
	: type==='list' && Tprim(Œπ)? P.filter(t=> t===Œπ)
	: type==='list' && T.RegExp(Œπ)? re`^${Œπ}$` |>(a=> P.filter(b=> Tstr(b) && a.test(b)) )
	: type==='string' && Tstr(Œπ)? Œπ.‚Äñ? _string(Œπ) : P.of('')
	: type==='string' && T.RegExp(Œπ)? _regex_native_string(Œπ)	
	: ‚ÄΩ('P',Œπ)
;`see`; P.prototype = Tag()
;`see`; P.prototype.Tag = Œª(tag){ tag+='' ;‚Ü© @ ‚â´(Œπ=> Tag(tag,Œπ) ) }
P.prototype.exec0 = Œª(in_){ t ‚Üê seq( @._(in_,0) ).next_Œπ ;‚Ü© t&&t.Œπ }
P.prototype.parse = Œª(in_){‚Ü© @.skip(P.not(P.any1)) .exec0(in_) }

################################## app prelude #################################
win ‚Üê (i,Œπ)‚áí { ,span_to:i ,Œπ }

################################### root ish ###################################
P.any1 = P0('any1',{ ,_:Œª*(in_,i){ if( i<in_.‚Äñ ) yield win(i+1,in_[i]) } })

_seq ‚Üê Œπ=> P0('seq',{ ,Œπ ,_:( !Œπ.‚Äñ? P.of([]) : Œπ[0].chain(a=> _seq(Œπ.slice(1)) ‚â´(r=>[a,‚Ä¶r])) )‚Äò._ .f })
_alt ‚Üê Œπ=> P0('¬¶',{ ,Œπ ,_:Œª*(in_,i){ for(p‚Üê of @.Œπ) yield* p._(in_,i) } })
P.prototype.| = Œª(b){‚Ü© P(Set(@,b)) }
P.if = Œπ=> P.not(P.not(Œπ))
P.not = Œπ=> P0('not',{ ,Œπ:P(Œπ) ,_:Œª*(in_,i){ for(t‚Üê of @.Œπ._(in_,i)) ‚Ü© ;yield win(i,‚àÖ) } })

P.of = Œπ=> P0('of',{ ,Œπ ,_:Œª*(in_,i){ yield win(i,@.Œπ) } })
P.‚àÖ = P0('‚àÖ',{ ,_:Œª*(in_,i){} })
P.prototype.chain = Œª(f){‚Ü© P0('chain',{
	,Œπ:@ ,f
	,_:Œª*(in_,i){ for(t‚Üê of @.Œπ._(in_,i)) yield* P(@.f(t.Œπ))._(in_,t.span_to) }
	}) }
P.prototype[‚â´] = (Œπ,f)=> Œπ.chain(f ‚â´ (P.of))
P.prototype.filter = Œª(f){‚Ü© @.chain( (Œπ=> f(Œπ)? P.of(Œπ) : P.‚àÖ) ‚Ä¶‚Üê ({f}) ) }
P.filter = f=> P.any1.filter(f)
P.prototype.catch = Œª(f){‚Ü© P0('catch',{
	,Œπ:@ ,f
	,_:Œª*(in_,i){ Œπ ‚Üê @.Œπ._(in_,i) ;for(;;){ try{ t ‚Üê seq(Œπ).next_ŒπŒπ ;if(! t )‚Ü© ;yield t }catch(e){ @.f(e) } } }
	}) }

################################### extra ish ##################################
_graph_thunk ‚Üê f=> P0('graph_thunk',{
	,Œπ:f
	,_(in_,i){ Tfun(@.Œπ) &&( @.Œπ = P(@.Œπ()) ) ;‚Ü© (0,@.Œπ)._(in_,i) }
	})
# P.prototype.memo = Œª(){ Œπ‚Üê@ ;‚Ü© P0('memo',{ ,Œπ ,_:memoize_proc(Œπ‚Äò._.f) }) }
P.prototype.√ó = Œª(for_,sort){sort||(sort='desc') ;‚Ü© P0('√ó',{
	,Œπ:@ ,for_ ,sort
	,_:Œª*(in_,i){
		if( !@.for_[1] ) ‚Ü© yield win(i,[])
		rest ‚Üê P([ ,@.Œπ ,@.Œπ.√ó(@.for_.map(Œπ=> max(0,Œπ-1)),@.sort) ]) ‚â´(([x,xs])=>[x,‚Ä¶xs])
		yield* ( @.for_[0]? rest : P(Set(‚Ä¶(@.sort==='desc'? [rest,P([])] : @.sort==='asc'? [P([]),rest] : ‚ÄΩ ))))._(in_,i) }
	}) }
P.prototype‚Äò['?'] .get= Œª(){‚Ü© @.√ó([0,1]) ‚â´(..0) }
P.prototype‚Äò['*'] .get= Œª(){‚Ü© @.√ó([0,‚àû]) }
P.prototype‚Äò['+'] .get= Œª(){‚Ü© @.√ó([1,‚àû]) }
P.prototype‚Äò['??'] .get= Œª(){‚Ü© @.√ó([0,1],'asc') ‚â´(..0) }
P.prototype‚Äò['*?'] .get= Œª(){‚Ü© @.√ó([0,‚àû],'asc') }
P.prototype‚Äò['+?'] .get= Œª(){‚Ü© @.√ó([1,‚àû],'asc') }
P.prototype.skip = Œª(p){‚Ü© P([@,p]) ‚â´(..0) }
P.prototype.then = Œª(p){‚Ü© P([@,p]) ‚â´(..1) }
P.prototype.join   = Œª(s){‚Ü© P([ ,@ ,P([s,@]) ‚â´(..1).*  ]) ‚â´(([Œπ,Œπs])=> [Œπ,‚Ä¶Œπs]) }
P.prototype.join?  = Œª(s){‚Ü© P([ ,@ ,P([s,@]) ‚â´(..1).*? ]) ‚â´(([Œπ,Œπs])=> [Œπ,‚Ä¶Œπs]) }
P.prototype.join2  = Œª(s){‚Ü© P([ ,s ,P([@,s]) ‚â´(..0).*  ]) ‚â´(..1) }
P.prototype.join2? = Œª(s){‚Ü© P([ ,s ,P([@,s]) ‚â´(..0).*? ]) ‚â´(..1) }

##################### in_ :: String   data root & fast path ####################
win1u ‚Üê (in_,i)=>{ t ‚Üê chr(ord(in_,i)) ;‚Ü© win(i+t.‚Äñ,t) }

_string ‚Üê Œπ=> P0('data',{
	,Œπ
	,_:Œª*(in_,i){ if( in_.startsWith(@.Œπ,i) ) yield win(i+@.Œπ.‚Äñ,@.Œπ) }
	})
P.‚ãØ = (a,b)=> P0('‚ãØ',{
	,a ,b
	,_:Œª*(in_,i){ Œπ ‚Üê ord(in_,i) ;if( i<in_.‚Äñ && ord(a)<=ord(Œπ)&&ord(Œπ)<ord(b) ) yield win(i+1,Œπ) }
	,inspect(À£,opt,tag){‚Ü© util.inspect(@.a,opt)+tag+util.inspect(@.b,opt) }
	})
_regex_native_string ‚Üê Œπ=> P0('regex',{
	,Œπ
	,_:Œª*(in_,i){t‚Üê; @.Œπ.flags.replace(/[muy]/g,'') && ‚ÄΩ ;if( t=@.Œπ.u.y.exec_at(in_,i) ) yield win( i+t[0].‚Äñ ,t.‚Äñ===1? t[0] : t.slice() ) }
	})
P.unicode_category = Œπ=> P0('category',{
	,Œπ
	,_:Œª*(in_,i){ if( i<in_.‚Äñ && êÖ™êÖùêÖ≠êÖ©êÖû(@.Œπ,ord(in_,i)) ) yield win1u(in_,i) }
	})
	êÖ™êÖùêÖ≠êÖ©êÖû ‚Üê memoize_persist((cat,Œπ)=> memoize_persist(cat=>
		_u(npm`unicode@10.0.0/category`)
		.filter((À£,type)=> type.re`^‚Ä¶${cat}$`)
		.map‚Ä¶(Œπ=> _.keys(Œπ).map(Œπ=> Œπ|0) )
		._.sortBy()
		)(cat.source).includes(ord(Œπ)) )
P.any1u = P0('any1u',{
	,_:Œª*(in_,i){ if( i<in_.‚Äñ ) yield win1u(in_,i) }
	})

################################################################################
‚Ü© P }
