#!/usr/bin/env ζ
# _Stream ← (str,i)=>{ t← Object.create(_Stream.prototype) ;t.str=str ;t.i=i ;↩ t }
# _Stream.prototype = {
# 	,‖:λ(){↩ @.str.‖-i }
# 	,slice(i){↩ _Stream(@.str,@.i+i) }
# 	,h_slice(a,b){ q ← ι=> ι===∅? 0 : ι<0? (@.str.‖-i)+ι : ι ;↩ @.str.slice(q(a),q(b)) }
# 	,match(ι){re←; ↩ Tstr(ι)? @.str.startsWith(ι,@.i) :( re = RegExp(ι.source,ι.flags.replace(/[^imu]/g,'')+'y') ,re.exec_at(@.str,@.i) ) }
# 	}
# [#Q _Stream.prototype.host #Q].def({ ,get(){↩ @.str.slice(i) }})
# wow, (in_,i) vs { i,ι } is fucky - could call it (constants,backpropagate) vs { edit,new }

# ! oh hey, this will break on unicode planes

#################################### Parser ####################################
Parser ← (tag,ι)=> Object.create(P.prototype) …← ({tag},ι)
P ← ι⇒
	: P.prototype.isPrototypeOf(ι)? ι
	: Tstr(ι)? ι.‖===1? P._unit(ι) : P([…ι]).map(.join(''))
	: Tfun(ι)? P._graph_thunk(ι)
	: Tarr(ι)? P._seq(ι)
	: T.RegExp(ι)? P._regex(ι)
	: ‽('cant make parser from',ι)
P.prototype = Tag()
P.prototype.exec = λ*(in_){ for(var t of @._(in_,0)) yield t.ι }
P.prototype.exec0 = λ(in_){↩ seq( @.exec(in_) ).next_ι() }
P.prototype.parse = λ(in_){↩ seq( @.skip(/$/).exec(in_) ).next_ι() }

module.exports = P

################################## root types ##################################
P.any1 = Parser('any1',{
	,_:λ*(in_,i){ if( i<in_.‖ ) yield { ,i:i+1 ,ι:in_[i] } }
	})
P._unit = ι=> Parser('unit',{
	,ι
	,_:λ*(in_,i){ if( in_[i]===@.ι ) yield { ,i:i+1 ,ι:in_[i] } }
	})
P.! = ι=> Parser('!',{
	,ι:P(ι)
	# !:!: -> t.status? make_win(i,∅) : t
	# !: -> t.status? lose(opt.stylize('!','special')+' '+util.inspect(self.ι,opt)) : make_win(i,∅)
	,_:λ*(in_,i){ for(var t of @.ι._(in_,i)) ↩ ;yield { ,i ,ι:∅ } }
	})
__seq2 ← λ* Λ(pₛ,in_,i){ {value:p,done} ← pₛ.next()
	if( done ) yield {,i,ι:[]} ;else
		for(var ι of p._(in_,i))
			for(var rest of Λ(pₛ.clone(),in_,ι.i) )
				yield { ,i:rest.i ,ι:ι.ι===∅? rest.ι : [ι.ι,…rest.ι] } }
# __seq ← λ* Λ(ps,ps_i,in_,i){
# 	if( ps.‖ - ps_i === 0 ) yield {i,ι:[]}
# 	else for(var ιs of ps[ps_i]._(in_,i)) for(var rest of Λ(ps,ps_i+1,in_,ιs.i) ) yield { ,i:rest.i ,ι:[ιs.ι,…rest.ι] }
# 	}
P._seq = ι=> Parser('seq',{
	,ι:ι.map(P.X)
	,_:λ*(in_,i){ yield* __seq2(@.ι.seq,in_,i) }
	# ,_:λ*(in_,i){ yield* __seq(@.ι,0,in_,i) }
	})
P.| = ι=> Parser('|',{
	,ι:ι.map(P.X)
	,_:λ*(in_,i){ for(var p of @.ι) yield* p._(in_,i) }
	})
P.return = ι=> Parser('return',{
	,ι
	,_:λ*(in_,i){ yield {,i,ι:@.ι} }
	})
P.prototype.chain = λ(f){↩ Parser('chain',{
	,ι:@ ,f
	,_:λ*(in_,i){ start ← i ;for(var {i,ι} of @.ι._(in_,i)) yield* @.f(ι,{ start,i,in_ })._(in_,i) }
	}) }
# P.custom = Parser

################################# further types ################################
P.⋯ = (a,b)=> Parser('|',{
	,a ,b
	# def(,'ι',{get(){ }})
	,_:λ*(in_,i){ ι ← in_[i] ;if( i<in_.‖ && ord(a)<=ord(ι)&&ord(ι)<ord(b) ) yield {,i:i+1,ι} }
	})
P.prototype.× = λ(for_,greedy=✓){↩ Parser('×',{
	,ι:@ ,for_ ,greedy
	,_:λ*(in_,i){
		if( !@.for_[1] ){ yield {i,ι:[]} ;↩ }
		rest ← P([ ,@.ι ,@.ι.×(@.for_.map(ι=> max(0,ι-1)),@.greedy) ]).map(([x,xs])=> xs? [x,…xs] : [x] )
		yield* ( @.for_[0]? rest : P.|(@.greedy? [rest,P.return([])] : [P.return([]),rest]) )._(in_,i)
		}
	}) }
P._regex = ι=> Parser('regex',{
	,ι
	,_:λ*(in_,i){t←; !@.ι.flags.replace(/[muy]/g,'')||‽ ;if( t=@.ι.u.y.exec_at(in_,i) ) yield { ,i:i+t[0].‖ ,ι:t.‖===1? t[0] : t.slice() } }
	})
P._graph_thunk = f=> Parser('graph_thunk',{
	,ι:f
	,_(in_,i){ Tfun(@.ι) &&( @.ι = @.ι() ) ;↩ (0,@.ι)._(in_,i) }
	})

################################ composite types ###############################
P.prototype.map = λ(f){↩ @.chain( λ self(ι,etc){↩ P.return(self.f(ι,etc)) } …← ({f}) ) }
def(P.prototype,'?',{get(){↩ @.×([0,1]).map(..0) }})
def(P.prototype,'*',{get(){↩ @.×([0,∞]) }})
def(P.prototype,'+',{get(){↩ @.×([1,∞]) }})
def(P.prototype,'??',{get(){↩ @.×([0,1],✗).map(..0) }})
def(P.prototype,'*?',{get(){↩ @.×([0,∞],✗) }})
def(P.prototype,'+?',{get(){↩ @.×([1,∞],✗) }})
P.prototype.skip = λ(p){↩ P([@,p]).map(..0) }
P.prototype.then = λ(p){↩ P([@,p]).map(..1) }
P.prototype.sep_by = λ(sep){↩ P([ ,@ ,P([sep,@]).map(..1).* ]).map(([ι,ιs])=> [ι,…ιs]) }

################################ todo eventually ###############################
# pattern: abstract branch prediction, e.g. with metadata gathering turned off for the first execution when metadata is only used in case of failure
# ?theory? pattern: left simplification/reduction
