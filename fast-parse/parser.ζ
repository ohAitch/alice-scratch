# a parser is a function. typically: from a string. to a mostly ordered tree. taking non-overlapping substrings to tree nodes. mostly monotonic.
# this parser works on strings and arrays

############ entry ###########
P0 â† (tag,Î¹)=> new_(P) â€¦â† ({tag},Î¹)
P â† module.exports = Î¹â‡’
	: P âˆ‹ (Î¹)? Î¹
	: Tfun(Î¹)? _graph_thunk(Î¹)
	: Tarr(Î¹)? _seq(Î¹.map(P.X))
	: T.Set(Î¹)? _alt(Î¹.map(P.X))
	: Tstr(Î¹)? Î¹.â€–? _data(Î¹) : P.of('')
	: T.RegExp(Î¹)? _regex_native(Î¹)
	: â€½(Î¹)
;`see`; P.prototype = Tag()
;`see`; P.prototype.Tag = Î»(tag){ tag+='' ;â†© @.map(Î¹=> Tag(tag,Î¹) ) }
P.prototype.exec0 = Î»(in_){â†© seq( seq( @._(in_,0) ).map(.Î¹) ).next_Î¹ }
P.prototype.parse = Î»(in_){â†© @.skip(_eof) .exec0(in_) }

######### app prelude ########
win â† (i,Î¹)â‡’ { ,span_to:i ,Î¹ }

############ root ############
_data â† Î¹=> P0('data',{
	,Î¹
	# in_:String
	,_:Î»*(in_,i){ if( in_.startsWith(@.Î¹,i) ) yield win(i+@.Î¹.â€–,@.Î¹) }
	})
_seq â† Î¹=> P0('seq',{
	,Î¹
	,_:Î»*(in_,i){
		if(! @.Î¹.â€– ) â†© yield win(i,[])
		p â† P(@.Î¹.slice(1)) ;for(Î¹â† of @.Î¹[0]._(in_,i)) yield* p.map(t=> [Î¹.Î¹,â€¦t])._(in_,Î¹.span_to) } })
_alt â† Î¹=> P0('Â¦',{
	,Î¹
	,_:Î»*(in_,i){ for(pâ† of @.Î¹) yield* p._(in_,i) }
	})
P.if = Î¹=> P.not(P.not(Î¹))
P.not = Î¹=> P0('not',{
	,Î¹:P(Î¹)
	,_:Î»*(in_,i){ for(tâ† of @.Î¹._(in_,i)) â†© ;yield win(i,âˆ…) }
	})

P.of = Î¹=> P0('of',{ ,Î¹ ,_:Î»*(in_,i){ yield win(i,@.Î¹) } })
P.âˆ… = P0('âˆ…',{ ,_:Î»*(in_,i){} })
P.prototype.chain = Î»(f){â†© P0('chain',{
	,Î¹:@ ,f
	,_:Î»*(in_,i){ for(tâ† of @.Î¹._(in_,i)) yield* @.f(t.Î¹)._(in_,t.span_to) }
	}) }
P.prototype.map = Î»(f){â†© @.chain( (Î¹=> P.of(f(Î¹))) â€¦â† ({f}) ) }
P.prototype.filter = Î»(f){â†© @.chain( (Î¹=> f(Î¹)? P.of(Î¹) : P.âˆ…) â€¦â† ({f}) ) }
# P.prototype.map = Î»(f){â†© P0('map',{
# 	,Î¹:@ ,f
# 	,_:Î»*(in_,i){ for(tâ† of @.Î¹._(in_,i)) yield win(t.span_to,@.f(t.Î¹)) }
# 	}) }
P.prototype.catch = Î»(f){â†© P0('catch',{
	,Î¹:@ ,f
	,_:Î»*(in_,i){ Î¹ â† @.Î¹._(in_,i) ;for(;;){ try{ t â† seq(Î¹).next_Î¹Î¹ ;if(! t )â†© ;yield t }catch(e){ @.f(e) } } }
	}) }

############ extra ###########
_graph_thunk â† f=> P0('graph_thunk',{
	,Î¹:f
	,_(in_,i){ Tfun(@.Î¹) &&( @.Î¹ = @.Î¹() ) ;â†© (0,@.Î¹)._(in_,i) }
	})
P.prototype.Ã— = Î»(for_,sort){sort||(sort='desc') ;â†© P0('Ã—',{
	,Î¹:@ ,for_ ,sort
	,_:Î»*(in_,i){
		if( !@.for_[1] ) â†© yield win(i,[])
		rest â† P([ ,@.Î¹ ,@.Î¹.Ã—(@.for_.map(Î¹=> max(0,Î¹-1)),@.sort) ]).map(([x,xs])=> xs? [x,â€¦xs] : [x] )
		yield* ( @.for_[0]? rest : P.|(@.sort==='desc'? [rest,P([])] : @.sort==='asc'? [P([]),rest] : â€½ ))._(in_,i) }
	}) }
P.prototypeâ€˜['?'] .get= Î»(){â†© @.Ã—([0,1]).map(..0) }
P.prototypeâ€˜['*'] .get= Î»(){â†© @.Ã—([0,âˆ]) }
P.prototypeâ€˜['+'] .get= Î»(){â†© @.Ã—([1,âˆ]) }
P.prototypeâ€˜['??'] .get= Î»(){â†© @.Ã—([0,1],âœ—).map(..0) }
P.prototypeâ€˜['*?'] .get= Î»(){â†© @.Ã—([0,âˆ],âœ—) }
P.prototypeâ€˜['+?'] .get= Î»(){â†© @.Ã—([1,âˆ],âœ—) }
P.prototype.skip = Î»(p){â†© P([@,p]).map(..0) }
P.prototype.then = Î»(p){â†© P([@,p]).map(..1) }
P.prototype.join = Î»(s){â†© P([ ,@ ,P([s,@]).map(..1).* ]).map(([Î¹,Î¹s])=> [Î¹,â€¦Î¹s]) }

########## fast path #########
win1u â† (in_,i)=>{ t â† chr(ord(in_,i)) ;â†© win(i+t.â€–,t) }

P.â‹¯ = (a,b)=> P0('â‹¯',{
	,a ,b
	# in_:String
	,_:Î»*(in_,i){ Î¹ â† ord(in_,i) ;if( i<in_.â€– && ord(a)<=ord(Î¹)&&ord(Î¹)<ord(b) ) yield win(i+1,Î¹) }
	,inspect(Ë£,opt,tag){â†© util.inspect(@.a,opt)+tag+util.inspect(@.b,opt) }
	})
_regex_native â† Î¹=> P0('regex',{
	,Î¹
	# in_:String
	,_:Î»*(in_,i){tâ†; @.Î¹.flags.replace(/[muy]/g,'') && â€½ ;if( t=@.Î¹.u.y.exec_at(in_,i) ) yield win( i+t[0].â€– ,t.â€–===1? t[0] : t.slice() ) }
	})
P.unicode_category = Î¹=> P0('category',{
	,Î¹
	# in_:String
	,_:Î»*(in_,i){ if( i<in_.â€– && ğ…ªğ…ğ…­ğ…©ğ…(@.Î¹,ord(in_,i)) ) yield win1u(in_,i) }
	})
	ğ…ªğ…ğ…­ğ…©ğ… â† memoize_persist((cat,Î¹)=> memoize_persist(cat=>
		_u(npm`unicode@10.0.0/category`)
		.filter((Ë£,type)=> type.re`^â€¦${cat}$`)
		.mapâ€¦(Î¹=> _.keys(Î¹).map(Î¹=> Î¹|0) )
		._.sortBy()
		)(cat.source).includes(ord(Î¹)) )
P.any1 = P0('any1',{
	,_:Î»*(in_,i){ if( i<in_.â€– ) yield win(i+1,in_[i]) }
	})
P.any1u = P0('any1u',{
	,_:Î»*(in_,i){ if( i<in_.â€– ) yield win1u(in_,i) }
	# in_:String
	})

########### discard ##########
_eof â† P0('eof',{
	,_:Î»*(in_,i){ if( i>=in_.â€– ) yield win(i,âˆ…) }
	})
P.err_if_partial = (a,b)â‡’
	: b? P([ P.if(P(a)) ,P(b).? ]).map(([Ë£,Î¹])=> Î¹===âˆ…? â€½(ğ…®ğ…¦ğ…¨ğ…ğ…ƒ) : Î¹)
	: a===ğ…®ğ…¦ğ…¨ğ…ğ…ƒ || â€½(a)
	ğ…®ğ…¦ğ…¨ğ…ğ…ƒ â† Error()
P.| = Î¹=> _alt(Î¹.map(P.X))

################################################################################
# todo eventually pattern: abstract branch prediction, e.g. with metadata gathering turned off for the first execution when metadata is only used in case of failure

# P0 ... |>(record)
# _record â† (Î¹,in_,i)=> cn.log( simple_hash(in_),'[',i,']',simple_hash(npm`circular-json@0.4.0`.stringify(Î¹)) )
# record â† Î¹=>{ t â† Î¹._ ;Î¹._ = Î»(â€¦a){ _record(@,â€¦a) ;â†© t.call(@,â€¦a) } ;â†© Î¹ }

# ;`
# P â†
# 	#data _ := .startsWith(it) ? ,â€–,Î¹
# 	[P]
# 	{P}
# 	#if P   := #not #not P
# 	#not P  := it ? âˆ… : ,0,âˆ…
# 	#of _
# 	P #chain f
# 	P * f
# 	P #catch f
# 	P f #thunk
# 	P Ã— (â‹¯ #span) sort:#desc

# 	P ? := P Ã— 0â‹¯1
# 	P * := P Ã— 0â‹¯âˆ
# 	P + := P Ã— 1â‹¯âˆ
# 	P ?? := P Ã— 0â‹¯1 #asc
# 	P *? := P Ã— 0â‹¯âˆ #asc
# 	P +? := P Ã— 1â‹¯âˆ #asc
# 	P join P := [ a ,â€¦ [b a]*.1 * ]
# `

# # why am i handwriting datafunctions?
# # these are all, like, function reifications

# # P.dataâ€˜(Î¹)

# {Î¹:T.string} ,âˆ… ,Î»*(in_,i){ if( in_.startsWith(@.Î¹,i) ) yield win(i+@.Î¹.â€–,@.Î¹) }
# {Î¹:Tarr} ,.map_(P.X) ,Î»*(in_,i){
# 	if(! @.Î¹.â€– ) â†© yield win(i,[])
# 	p â† P(@.Î¹.slice(1)) ;for(Î¹â† of @.Î¹[0]._(in_,i)) yield* p.map(t=> [Î¹.Î¹,â€¦t])._(in_,Î¹.span_to) }
# {Î¹:T.Set} ,.map_(P.X) ,Î»*(in_,i){ for(pâ† of @.Î¹) yield* p._(in_,i) }
# ['if',{Î¹:âˆ…}] ,P 


# param â† _.memoize(npm`get-parameter-names@0.3.0`)
# partial_P â† (Î¹,id)=> (â€¦a)=> new_(P) â€¦â† ({,tag:id,_:Î¹(â€¦a)}) â€¦â† (_.zip(param(Î¹),a)._.object())
# as_method â† f=> Î»(â€¦a){â†© f(@,â€¦a)}

# P â† module.exports = Î¹=> â€½
# ğ…°ğ…¯ğ…©ğ…ğ…¨ â† {
# ,_data:Î¹=> Î»*(in_,i){ if( in_.startsWith(@.Î¹,i) ) yield win(i+@.Î¹.â€–,@.Î¹) }
# ,_seq:Î¹=> Î»*(in_,i){
# 	if(! @.Î¹.â€– ) â†© yield win(i,[])
# 	p â† P(@.Î¹.slice(1)) ;for(Î¹â† of @.Î¹[0]._(in_,i)) yield* p.map(t=> [Î¹.Î¹,â€¦t])._(in_,Î¹.span_to) }
# ,_alt:Î¹=> Î»*(in_,i){ for(pâ† of @.Î¹) yield* p._(in_,i) }
# # ,if:Î¹=> P.not(P.not(Î¹))
# ,chain:(Î¹,f)=> Î»*(in_,i){ for(tâ† of @.Î¹._(in_,i)) yield* @.f(t.Î¹)._(in_,t.span_to) }
# } |>(_u).mapObject(partial_P)
# P â€¦â† (ğ…°ğ…¯ğ…©ğ…ğ…¨)
# P.prototype = Tag() â€¦â† (_u(ğ…°ğ…¯ğ…©ğ…ğ…¨).mapObject(as_method))

# P.chain('a','b')
