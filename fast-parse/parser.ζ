# a parser is a function. typically: from a string. to a mostly ordered tree. taking non-overlapping substrings to tree nodes. mostly monotonic.
# this is a string parser

############ entry ###########
P0 ‚Üê (tag,Œπ)=> Object.create(P.prototype) ‚Ä¶‚Üê ({tag},Œπ)
P ‚Üê module.exports = Œπ‚áí
	: P.prototype.isPrototypeOf(Œπ)? Œπ
	: Tfun(Œπ)? _graph_thunk(Œπ)
	: Tstr(Œπ)? Œπ.‚Äñ? _data(Œπ) : P([]).map(=>'')
	: Tarr(Œπ)? _seq(Œπ)
	: T.RegExp(Œπ)? _regex_native(Œπ)
	: ‚ÄΩ(Œπ)
P.prototype = Tag()
P.prototype.exec0 = Œª(in_){ t ‚Üê seq( seq( @._(in_,0) ).map(.Œπ) ).next_Œπ ;‚Ü© t===P‚àÖ? ‚àÖ : t }
P.prototype.parse = Œª(in_){‚Ü© @.skip(/$/) .exec0(in_) }

######### app prelude ########
win ‚Üê (i,Œπ)‚áí { ,span_to:i ,Œπ }
P‚àÖ ‚Üê Symbol('P‚àÖ_lose')
‚Ä° is this the right way to do backtrack prevention?

############ root ############
_data ‚Üê Œπ=> P0('data',{
	,Œπ
	,_:Œª*(in_,i){ if( in_.startsWith(@.Œπ,i) ) yield win(i+@.Œπ.‚Äñ,@.Œπ) }
	})
_seq ‚Üê Œπ=> P0('seq',{
	,Œπ:Œπ.map(P.X)
	,_:Œª(in_,i){‚Ü© êÖ®êÖÇêÖ´êÖ¶êÖÇ(in_,i,@.Œπ,0) }
	})
	êÖ®êÖÇêÖ´êÖ¶êÖÇ ‚Üê Œª*(in_,i,p‚Çõ,p·µ¢){
		if( p·µ¢===p‚Çõ.‚Äñ ) yield win(i,[]) ;else
			for(Œπ‚Üê of p‚Çõ[p·µ¢]._(in_,i)) {
				if( Œπ===P‚àÖ ) ‚Ü© yield Œπ
				for(b‚Üê of êÖ®êÖÇêÖ´êÖ¶êÖÇ(in_,Œπ.span_to,p‚Çõ,p·µ¢+1) ) { # rest
					if( b===P‚àÖ ) ‚Ü© yield b
					yield win(b.span_to,[Œπ.Œπ,‚Ä¶b.Œπ]) } } }
P.| = Œπ=> P0('¬¶',{
	,Œπ:Œπ.map(P.X)
	,_:Œª*(in_,i){ for(p‚Üê of @.Œπ) yield* p._(in_,i) }
	})
P.prototype‚Äò.not .get= Œª(){‚Ü© P0('not',{
	,Œπ:@
	,_:Œª*(in_,i){ for(t‚Üê of @.Œπ._(in_,i)) ‚Ü© t===P‚àÖ? yield win(i,‚àÖ) : ‚àÖ ;yield win(i,‚àÖ) }
	}) }
P.prototype.map = Œª(f){‚Ü© P0('map',{
	,Œπ:@ ,f
	,_:Œª*(in_,i){ for(t‚Üê of @.Œπ._(in_,i)) yield t===P‚àÖ? t : win(t.span_to,@.f(t.Œπ)) }
	}) }

############ extra ###########
_graph_thunk ‚Üê f=> P0('graph_thunk',{
	,Œπ:f
	,_(in_,i){ Tfun(@.Œπ) &&( @.Œπ = @.Œπ() ) ;‚Ü© (0,@.Œπ)._(in_,i) }
	})
P.prototype.√ó = Œª(for_,greedy=‚úì){‚Ü© P0('√ó',{
	,Œπ:@ ,for_ ,greedy
	,_:Œª*(in_,i){
		if( !@.for_[1] ) ‚Ü© yield win(i,[])
		rest ‚Üê P([ ,@.Œπ ,@.Œπ.√ó(@.for_.map(Œπ=> max(0,Œπ-1)),@.greedy) ]).map(([x,xs])=> xs? [x,‚Ä¶xs] : [x] )
		yield* ( @.for_[0]? rest : P.|(@.greedy? [rest,P([])] : [P([]),rest]) )._(in_,i)
		}
	}) }
P.prototype‚Äò['?'] .get= Œª(){‚Ü© @.√ó([0,1]).map(..0) }
P.prototype‚Äò['*'] .get= Œª(){‚Ü© @.√ó([0,‚àû]) }
P.prototype‚Äò['+'] .get= Œª(){‚Ü© @.√ó([1,‚àû]) }
P.prototype‚Äò['??'] .get= Œª(){‚Ü© @.√ó([0,1],‚úó).map(..0) }
P.prototype‚Äò['*?'] .get= Œª(){‚Ü© @.√ó([0,‚àû],‚úó) }
P.prototype‚Äò['+?'] .get= Œª(){‚Ü© @.√ó([1,‚àû],‚úó) }
P.prototype.skip = Œª(p){‚Ü© P([@,p]).map(..0) }
P.prototype.then = Œª(p){‚Ü© P([@,p]).map(..1) }
P.prototype.sep_by = Œª(sep){‚Ü© P([ ,@ ,P([sep,@]).map(..1).* ]).map(([Œπ,Œπs])=> [Œπ,‚Ä¶Œπs]) }

########## fast path #########
win1u ‚Üê (in_,i)=>{ t ‚Üê chr(ord(in_,i)) ;‚Ü© win(i+t.‚Äñ,t) }

P.‚ãØ = (a,b)=> P0('‚ãØ',{
	,a ,b
	,_:Œª*(in_,i){ Œπ ‚Üê ord(in_,i) ;if( i<in_.‚Äñ && ord(a)<=ord(Œπ)&&ord(Œπ)<ord(b) ) yield win(i+1,Œπ) }
	,inspect(À£,opt,tag){‚Ü© util.inspect(@.a,opt)+tag+util.inspect(@.b,opt) }
	})
_regex_native ‚Üê Œπ=> P0('regex',{
	,Œπ
	,_:Œª*(in_,i){t‚Üê; @.Œπ.flags.replace(/[muy]/g,'') && ‚ÄΩ ;if( t=@.Œπ.u.y.exec_at(in_,i) ) yield win( i+t[0].‚Äñ ,t.‚Äñ===1? t[0] : t.slice() ) }
	})
P.unicode_category = cat=> P0('cat',{
	,cat
	,_:Œª*(in_,i){ if( i<in_.‚Äñ && êÖ™êÖùêÖ≠êÖ©êÖû(@.cat,ord(in_,i)) ) yield win1u(in_,i) }
	})
	êÖ™êÖùêÖ≠êÖ©êÖû ‚Üê memoize_persist((cat,Œπ)=> memoize_persist(cat=>
		_u(npm`unicode@10.0.0/category`)
		.filter((À£,type)=> type.re`^‚Ä¶${cat}$`)
		.map‚Ä¶(Œπ=> _.keys(Œπ).map(Œπ=> Œπ|0) )
		._.sortBy()
		)(cat.source).includes(ord(Œπ)) )
P.any1 = P0('any1',{
	,_:Œª*(in_,i){ if( i<in_.‚Äñ ) yield win(i+1,in_[i]) }
	})
P.any1u = P0('any1u',{
	,_:Œª*(in_,i){ if( i<in_.‚Äñ ) yield win1u(in_,i) }
	})

################################################################################
# todo eventually pattern: abstract branch prediction, e.g. with metadata gathering turned off for the first execution when metadata is only used in case of failure
# todo eventually ?theory? pattern: left simplification/reduction

# P0 ... |>(record)
# _record ‚Üê (Œπ,in_,i)=> cn.log( simple_hash(in_),'[',i,']',simple_hash(npm`circular-json@0.4.0`.stringify(Œπ)) )
# record ‚Üê Œπ=>{ t ‚Üê Œπ._ ;Œπ._ = Œª(‚Ä¶a){ _record(@,‚Ä¶a) ;‚Ü© t.call(@,‚Ä¶a) } ;‚Ü© Œπ }
