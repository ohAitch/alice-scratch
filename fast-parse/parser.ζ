# _Stream ← (str,i)=>{ t← Object.create(_Stream.prototype) ;t.str=str ;t.i=i ;↩ t }
# _Stream.prototype = {
# 	,‖:λ(){↩ @.str.‖-i }
# 	,slice(i){↩ _Stream(@.str,@.i+i) }
# 	,h_slice(a,b){ q ← ι=> ι===∅? 0 : ι<0? (@.str.‖-i)+ι : ι ;↩ @.str.slice(q(a),q(b)) }
# 	,match(ι){re←; ↩ Tstr(ι)? @.str.startsWith(ι,@.i) :( re = RegExp(ι.source,ι.flags.replace(/[^imu]/g,'')+'y') ,re.exec_at(@.str,@.i) ) }
# 	}
# [#Q _Stream.prototype.host #Q].def({ ,get(){↩ @.str.slice(i) }})
# wow, (in_,i) vs { i,ι } is fucky - could call it (constants,backpropagate) vs { edit,new }

# ! oh hey, this will break on unicode planes during the phase of reading from in_ - i think it gets the rest right?

################################## start place #################################
P ← module.exports = ι⇒
	: P.prototype.isPrototypeOf(ι)? ι
	: Tstr(ι)? ι.‖===1? _unit(ι) : P([…ι]).map(.join(''))
	: Tfun(ι)? _graph_thunk(ι)
	: Tarr(ι)? _seq(ι)
	: T.RegExp(ι)? _regex(ι)
	: ‽('cant make parser from',ι)
P.prototype = Tag()
P.prototype.exec = λ*(in_){ for(t← of @._(in_,0)) yield t.ι }
P.prototype.exec0 = λ(in_){↩ seq( @.exec(in_) ).next_ι }
P.prototype.parse = λ(in_){↩ seq( @.skip(/$/).exec(in_) ).next_ι }
P0 ← (tag,ι)=> Object.create(P.prototype) …← ({tag},ι)

################################## root types ##################################
_unit ← ι=> P0('unit',{
	,ι
	,_:λ*(in_,i){ if( in_[i]===@.ι ) yield { ,i:i+1 ,ι:in_[i] } }
	})
P.! = ι=> P0('!',{
	,ι:P(ι)
	,_:λ*(in_,i){ for(t← of @.ι._(in_,i)) ↩ ;yield { ,i ,ι:∅ } }
	})
__seq ← λ*(pₛ,in_,i){ p ← pₛ.next_ιι
	if( !p ) yield {,i,ι:[]} ;else
		for(ι← of p._(in_,i))
			for(rest← of __seq(pₛ.clone,in_,ι.i) )
				yield { ,i:rest.i ,ι: ι.ι===∅? rest.ι : [ι.ι,…rest.ι] } }
_seq ← ι=> P0('seq',{
	,ι:ι.map(P.X)
	,_:λ*(in_,i){ yield* __seq(seq(@.ι),in_,i) }
	})
P.| = ι=> P0('|',{
	,ι:ι.map(P.X)
	,_:λ*(in_,i){ for(p← of @.ι) yield* p._(in_,i) }
	})
P.return = ι=> P0('return',{
	,ι
	,_:λ*(in_,i){ yield {,i,ι:@.ι} }
	})
P.prototype.chain = λ(f){↩ P0('chain',{
	,ι:@ ,f
	,_:λ*(in_,i){ start ← i ;for({i,ι}← of @.ι._(in_,i)) yield* @.f(ι,{ start,i,in_ })._(in_,i) }
	}) }
# P.custom = P0

################################# further types ################################
P.any1 = P0('any1',{
	,_:λ*(in_,i){ if( i<in_.‖ ) yield { ,i:i+1 ,ι:in_[i] } }
	})
P.⋯ = (a,b)=> P0('|',{
	,a ,b
	,_:λ*(in_,i){ ι ← in_[i] ;if( i<in_.‖ && ord(a)<=ord(ι)&&ord(ι)<ord(b) ) yield {,i:i+1,ι} }
	,inspect(ˣ,opt,tag){↩ util.inspect(@.a,opt)+tag+util.inspect(@.b,opt) }
	})
P.prototype.× = λ(for_,greedy=✓){↩ P0('×',{
	,ι:@ ,for_ ,greedy
	,_:λ*(in_,i){
		if( !@.for_[1] ){ yield {i,ι:[]} ;↩ }
		rest ← P([ ,@.ι ,@.ι.×(@.for_.map(ι=> max(0,ι-1)),@.greedy) ]).map(([x,xs])=> xs? [x,…xs] : [x] )
		yield* ( @.for_[0]? rest : P.|(@.greedy? [rest,P.return([])] : [P.return([]),rest]) )._(in_,i)
		}
	}) }
_regex ← ι=> P0('regex',{
	,ι
	,_:λ*(in_,i){t←; !@.ι.flags.replace(/[muy]/g,'')||‽ ;if( t=@.ι.u.y.exec_at(in_,i) ) yield { ,i:i+t[0].‖ ,ι:t.‖===1? t[0] : t.slice() } }
	})
_graph_thunk ← f=> P0('graph_thunk',{
	,ι:f
	,_(in_,i){ Tfun(@.ι) &&( @.ι = @.ι() ) ;↩ (0,@.ι)._(in_,i) }
	})

################################ composite types ###############################
P.prototype.map = λ(f){↩ @.chain( λ self(ι,etc){↩ P.return(self.f(ι,etc)) } …← ({f}) ) }
def(P.prototype,'?',{get(){↩ @.×([0,1]).map(..0) }})
def(P.prototype,'*',{get(){↩ @.×([0,∞]) }})
def(P.prototype,'+',{get(){↩ @.×([1,∞]) }})
def(P.prototype,'??',{get(){↩ @.×([0,1],✗).map(..0) }})
def(P.prototype,'*?',{get(){↩ @.×([0,∞],✗) }})
def(P.prototype,'+?',{get(){↩ @.×([1,∞],✗) }})
P.prototype.skip = λ(p){↩ P([@,p]).map(..0) }
P.prototype.then = λ(p){↩ P([@,p]).map(..1) }
P.prototype.sep_by = λ(sep){↩ P([ ,@ ,P([sep,@]).map(..1).* ]).map(([ι,ιs])=> [ι,…ιs]) }

################################ todo eventually ###############################
# pattern: abstract branch prediction, e.g. with metadata gathering turned off for the first execution when metadata is only used in case of failure
# ?theory? pattern: left simplification/reduction
