#!/usr/bin/env ζ
{Rᵢ:R} ← require_new(__dirname+'/record')
# ℝ_set ← require_new(__dirname+'/ℝ_set')

# _Stream ← (str,i)=>{ t← Object.create(_Stream.prototype); t.str=str; t.i=i; ↩ t }
# _Stream.prototype = {
# 	,‖:λ(){↩ @.str.‖-i }
# 	,slice(i){↩ _Stream(@.str,@.i+i) }
# 	,h_slice(a,b){ q ← ι=> ι===∅? 0 : ι<0? (@.str.‖-i)+ι : ι; ↩ @.str.slice(q(a),q(b)) }
# 	,match(ι){re←; ↩ Tstr(ι)? @.str.startsWith(ι,@.i) :( re = RegExp(ι.source,ι.flags.replace(/[^imu]/g,'')+'y') ,re.exec_at(@.str,@.i) ) }
# 	}
# [#Q _Stream.prototype.host #Q].def({ ,get(){↩ @.str.slice(i) }})
# wow, (in_,i) vs { i,ι } is fucky - could call it (constants,backpropagate) vs { edit,new }

#################################### Parser ####################################
Parser ← (tag,ι)=> Object.create(P.prototype) …← ({tag},ι)
P ← ι⇒
	: P.prototype.isPrototypeOf(ι)? ι
	: Tstr(ι)? ι.‖===1? P._unit(ι) : P([…ι]).map(.join(''))
	: Tfun(ι)? P._graph_thunk(ι)
	: Tarr(ι)? P._seq(ι)
	: T.RegExp(ι)? P._regex(ι)
	: ‽('cant make parser from',ι)
P.prototype = R(∅,{})
P.prototype.exec = λ*(in_){ for(var t of @._(in_,0)) yield t.ι }
P.prototype.parse = λ(in_){↩ seq( @.skip(/$/).exec(in_) ).next_ι() }

module.exports = P

################################## root types ##################################
P._unit = ι=> Parser('unit',{
	ι,
	_:λ*(in_,i){ if( in_[i]===@.ι ) yield { i:i+1, ι:in_[i] } },
	})
P.not = ι=> Parser('not',{
	ι:P(ι),
	// not:not: -> t.status? make_win(i,∅) : t
	// not: -> t.status? lose(opt.stylize('not','special')+' '+util.inspect(self.ι,opt)) : make_win(i,∅)
	_:λ*(in_,i){ for(var t of @.ι._(in_,i)) ↩; yield { i, ι:∅ } },
	})
__seq2 ← λ* Λ(pₛ,in_,i){ {value:p,done} ← pₛ.next(); if( done ) yield {i,ι:[]}; else for(var ι of p._(in_,i)) for(var rest of Λ(pₛ.clone(),in_,ι.i) ) yield { i:rest.i, ι:[ι.ι,…rest.ι] } }
// __seq ← λ* Λ(ps,ps_i,in_,i){
// 	if( ps.‖ - ps_i === 0 ) yield {i,ι:[]}
// 	else for(var ιs of ps[ps_i]._(in_,i)) for(var rest of Λ(ps,ps_i+1,in_,ιs.i) ) yield { i:rest.i, ι:[ιs.ι,…rest.ι] }
// 	}
P._seq = ι=> Parser('seq',{
	ι:ι.map(P.X),
	_:λ*(in_,i){ yield* __seq2(@.ι.seq,in_,i) },
	// _:λ*(in_,i){ yield* __seq(@.ι,0,in_,i) },
	})
P.alt = ι=> Parser('alt',{
	ι:ι.map(P.X),
	_:λ*(in_,i){ for(var p of @.ι) yield* p._(in_,i) },
	})
P.return = ι=> Parser('return',{
	ι,
	_:λ*(in_,i){ yield {i,ι:@.ι} },
	})
P.prototype.chain = λ(f){↩ Parser('chain',{
	ι:@, f,
	_:λ*(in_,i){ start ← i; for(var {i,ι} of @.ι._(in_,i)) yield* @.f(ι,{ start,i,in_ })._(in_,i) },
	}) }

############################# pseudocomposite types ############################
P.alt_range = (a,b)=> Parser('alt',{
	// def(,'ι',{get(){ }})
	a, b,
	_:λ*(in_,i){ ι ← in_[i]; if( a<=ι&&ι<b ) yield {i:i+1,ι} },
	})
P.prototype.repeat = function(for_,greedy=✓){↩ Parser('repeat',{
	ι:@, for_, greedy,
	_:λ*(in_,i){
		if (!@.for_[1]){ yield {i,ι:[]}; ↩ }
		rest ← P([ @.ι, @.ι.repeat(@.for_.map(ι=> max(0,ι-1)),@.greedy) ]).map(([x,xs])=> xs? [x,…xs] : [x] )
		yield* ( @.for_[0]? rest : P.alt(@.greedy? [rest,P.return([])] : [P.return([]),rest]) )._(in_,i)
		},
	}) }
P._regex = ι=> Parser('regex',{
	ι,
	_:λ*(in_,i){t←; !@.ι.flags.replace(/[muy]/g,'')||‽; if( t=@.ι.u.y.exec_at(in_,i) ) yield { i: i+t[0].‖, ι: t.‖===1? t[0] : t.slice() } },
	})
P._graph_thunk = f=> Parser('graph_thunk',{
	ι:f,
	_(in_,i){ Tfun(@.ι) &&( @.ι = @.ι() ); ↩ (0,@.ι)._(in_,i) },
	})

################################ composite types ###############################
P.prototype.map = λ(f){↩ @.chain( λ self(ι,etc){↩ P.return(self.f(ι,etc)) } …← ({f}) ) }
def(P.prototype,'?',{get(){↩ @.repeat([0,1]).map(ι=>ι[0]) }})
def(P.prototype,'*',{get(){↩ @.repeat([0,∞]) }})
def(P.prototype,'+',{get(){↩ @.repeat([1,∞]) }})
def(P.prototype,'??',{get(){↩ @.repeat([0,1],✗).map(ι=>ι[0]) }})
def(P.prototype,'*?',{get(){↩ @.repeat([0,∞],✗) }})
def(P.prototype,'+?',{get(){↩ @.repeat([1,∞],✗) }})
P.prototype.skip = λ(p){↩ P([@,p]).map(ι=>ι[0]) }
P.prototype.then = λ(p){↩ P([@,p]).map(ι=>ι[1]) }
P.prototype.sep_by = λ(sep){↩ P([ @, P([sep,@]).map(ι=>ι[1]).* ]).map(([ι,ιs])=> [ι,…ιs]) }

################################### build_op ###################################
P.build_op = (unit,op)=>{
	# binary left: 1-2-3 = (1-2)-3 ; binary right: 1^2^3 = 1^(2^3)
	# '2 center':p=> P([ p, P.seq(op,p).*.map(ι=> _(ι).flatten(✓)) ]).map(([a,op_bs])=> !op_bs.length? a : R('op',{A:'2 center', ι:[a, …op_bs]}) ),
	_1L ← p=>{ r ← P(=> P.alt([ P([ op,r ]).map(([op,ι])=> [op,∅,ι]) ,p ])); ↩ r }
	_1R ← p=> P([ p, op.* ]).map(([x,r])=> r.fold((ι,op)=> [op,ι,∅], x) )
	_2L ← p=> P([ p, P([ op,p ]).* ]).map(([x,r])=> r.fold((a,[op,b])=>[op,a,b], x) )
	_2R ← p=>{ r ← P(=> p.chain(a=> P.alt([ P([ op, r ]).map(([op,b])=>[op,a,b]) ,P.of(a) ])) ); ↩ r }
	↩ unit |> (_2L,_1L,_1R) }

################################ todo eventually ###############################
# pattern: abstract branch prediction, e.g. with metadata gathering turned off for the first execution when metadata is only used in case of failure
