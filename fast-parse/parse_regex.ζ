#!/usr/bin/env Œ∂
P ‚Üê require('./parser')

R ‚Üê (tag,Œπ)=>{ r ‚Üê Tag() ;r.tag = tag ;Œπ!==‚àÖ &&( r.Œπ = Œπ ) ;‚Ü© r }
P.prototype.R = Œª(tag){ tag+='' ;‚Ü© @.map(Œπ=> R(tag,Œπ) ) }

walk_regex ‚Üê (Œπ,f)=> Œπ |> (Œª Œõ(Œπ){ if( Œπ&&Œπ.tag ){
	clone ‚Üê _.once(=>{ Œπ = Tag() ‚Ä¶‚Üê (Œπ) })
	# ifŒî is weird. why?
	ifŒî! ‚Üê (a,f=Object.is)=>{ for(var k in a) f(Œπ[k],a[k]) ||( clone() ,Œπ[k] = a[k] ) ;‚Ü© Œπ }
	if( Œπ.Œπ ) Œπ = ifŒî!({ Œπ: Tarr(Œπ.Œπ)? Œπ.Œπ.map(Œõ) : Œõ(Œπ.Œπ) })
	Œπ = f(Œπ,{ifŒî!})
	} ;‚Ü© Œπ })

Regex ‚Üê (=>{
	Regex ‚Üê =>Regex
	hex ‚Üê /[0-9a-fA-F]/u
	Escape ‚Üê P([ ,'\\' ,P.|([
		,P.|([ re`x(${hex}{2})` ,re`u\{(${hex}+)\}` ,re`u(${hex}{4})` ]).map(Œπ=> chr(parseInt(Œπ[1],16)))
		,P(/c([A-Z])/).map(Œπ=> chr( ord(Œπ[1]) - ord('A') + 1 ))
		,P(/[trnvf0]/).map(Œπ‚áí {t:'\t',r:'\r',n:'\n',v:'\v',f:'\f',0:'\0'}[Œπ])
		,P(/[dDwWsSbB]/).map(Œπ=> $({
			,d:/[0-9]/u
			,w:/[A-Za-z0-9_]/u
			,s:/[ \f\n\r\t\v\xa0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/u
			,b:String.raw`(?<=\w)(?!\w)|(?<!\w)(?=\w)`
			,D:/[^\d]/u ,W:/[^\w]/u ,S:/[^\s]/u ,B:/(?!\b)/u
			}[Œπ]))
		,P(/[1-9][0-9]*/).map(Œπ=> R(`backref`,Œπ|0) )
		,/[^]/
		]) ]).map(..1)
	Set_Escape ‚Üê P.|([ P('\\b').map(=>'\b') ,Escape ])
	Unit ‚Üê P.|([
		,Escape
		,P('.').map(=> $(/[^\n\r\u2028\u2029]/u))
		,P(['(?:',Regex,')']).map(..1)
		,P(['(?!',Regex,')']).map(..1).R`!`
		,P(['(?=',Regex,')']).map(..1).R`!`.R`!`
		,P(['(?<=',Regex,')']).map(..1).R`behind`
		,P(['(?<!',Regex,')']).map(..1).R`behind`.R`!`
		,P(['(',Regex,')']).map(..1).R`capture`
		,P(['[' ,/\^?/ ,(=>{ t ‚Üê P.|([ Set_Escape,/[^\]]/ ]) ;‚Ü© P.|([ P([t,'-',t]).map(Œπ=>[Œπ[0],Œπ[2]]) ,t ]).* })() ,']'])
			.map(([À£,not,Œπ, ∏])=>{ r ‚Üê R(`|`,Œπ.map(Œπ=> Tarr(Œπ)? R(`‚ãØ`,Œπ) : Œπ )) ;if( not ) r = !Œπ.‚Äñ? R(`any`,‚àÖ) : R(`seq`,[ R(`!`,r) ,R(`any`,‚àÖ) ]) ;‚Ü© r })
		,P(/[$^]/).R`^$`
		,/[^)]/
		])
	Postfix ‚Üê P([ Unit ,P([ P.|([ '*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/ ]) ,P('?').? ,]).? ]).map(([Œπ,rep])=>{
		if(! rep ) ‚Ü© Œπ
		for_ ‚Üê Œπ=> Œπ==='*'? [0,‚àû] : Œπ==='+'? [1,‚àû] : Œπ==='?'? [0,1] : (=>{ [À£,a,two,b] ‚Üê Œπ ;‚Ü© [a|0,b? b|0 : two? ‚àû : a|0] })()
		‚Ü© R(`√ó` ,‚àÖ)‚Ä¶‚Üê ({ ,Œπ ,for:for_(rep[0]) ,greedy:!rep[1] }) })
	Infix ‚Üê Postfix.*?.R`seq`.sep_by('|').?.map(Œπ=> Œπ.‚Äñ===1? Œπ[0] : R(`|`,Œπ) )
	Regex ‚Üê Infix
	‚Ü© Regex })()

parse_regex ‚Üê Œπ=>{ flags ‚Üê Œπ.flags||'u' ;Œπ = Œπ.source||Œπ
	if( !flags.re`u` ) ‚ÄΩ('can only parse unicode regex')
	if( flags.re`y` ) ‚ÄΩ('no /y support yet') # should it be handled separately?
	if( flags.re`i` ) ‚ÄΩ('no /i support yet')
	if( flags.re`g` ) ‚ÄΩ('/g should be handled separately')
	# g should be part of the call, ! the regex (split no care, search no care, replace care simple, match care simple, exec care weird)

	Œπ = Regex.parse(Œπ)
	walk_regex(Œπ,Œπ=>{
		if( Œπ.‚âà`^$` ) if( flags.re`m` ) Œπ.Œπ += 'm'
		})
	‚Ü© Œπ }

normalize_to_axioms_regex ‚Üê Œπ=>{
	Œπ = walk_regex(Œπ,(Œπ,{ifŒî!})=>{
		# these seem redundant. why?
		is_null ‚Üê Œπ=> Tstr(Œπ)? ‚úó : ( (Œπ.‚âà`|` || Œπ.‚âà`seq`) && Œπ.Œπ.every(is_null) ) || ( Œπ.‚âà`!` && is_bottom(Œπ.Œπ) )
		is_bottom ‚Üê Œπ=> Tstr(Œπ)? ‚úó : ( Œπ.‚âà`|` && Œπ.Œπ.every(is_bottom) ) || ( Œπ.‚âà`seq` && Œπ.Œπ.some(is_bottom) ) || ( Œπ.‚âà`!` && is_null(Œπ.Œπ) )

		is_1not ‚Üê Œπ=> Tstr(Œπ)? ‚úó : Œπ.‚âà`seq` && Œπ.Œπ.‚Äñ===2 && Œπ.Œπ[0].‚âà && Œπ.Œπ[0].‚âà`!` && Œπ.Œπ[1].‚âà && Œπ.Œπ[1].‚âà`any`
		Œπ_1not ‚Üê .Œπ[0].Œπ

		if( is_1not(Œπ) && is_1not(Œπ_1not(Œπ)) ){
			Œπ = Œπ_1not(Œπ_1not(Œπ))
			# if( length(Œπ)===1 ) ‚Ü© Œπ ;else
			‚Ü© R(`seq`,[ R(`!`,R(`!`,Œπ)) ,R(`any`,‚àÖ) ])
			}

		if( Œπ.‚âà`seq` ) Œπ = ifŒî!( { Œπ: Œπ.Œπ.map‚Ä¶(Œπ=> Œπ.tag && Œπ.‚âà`seq`? Œπ.Œπ : [Œπ] ) } ,_.isEqual )

		if( (Œπ.‚âà`|`||Œπ.‚âà`seq`) && Œπ.Œπ.‚Äñ===1 ) ‚Ü© Œπ.Œπ[0]

		if( is_null(Œπ) ) ‚Ü© R(`seq`,[])
		# if( is_bottom(Œπ) ) ‚Ü© R(`!`,R(`seq`,[]))

		if( Œπ.‚âà`^$` ) ‚Ü© $({ ,'^':'(?<![^])' ,'$':'(?![^])' ,'^m':'(?<![^\n\r])' ,'$m':'(?![^\n\r])' }[Œπ.Œπ])
		‚Ü© Œπ })
	‚Ü© Œπ }

$0 ‚Üê Œπ=> normalize_to_axioms_regex(parse_regex(Œπ))
êÖãêÖùêÖÉêÖÉêÖÆ ‚Üê memoize_proc($0)
$ ‚Üê Œπ=>{ Œπ= Œπ |>(êÖãêÖùêÖÉêÖÉêÖÆ) ;‚Ü© _l.cloneDeep(Œπ) ‚Ä¶‚Üê ({tag:Œπ.tag}) } # aka parse_normalize_regex_memoized

# exports‚Üê; exports || ( exports = global )
# t ‚Üê { Regex,parse_regex,normalize_to_axioms_regex }
# exports ‚Ä¶‚Üê (t)

P_ify ‚Üê Œπ=> walk_regex(Œπ,Œπ‚áí
	: Œπ.‚âà`|`? P.|(Œπ.Œπ)
	: Œπ.‚âà`‚ãØ`? P.‚ãØ(‚Ä¶Œπ.Œπ)
	: Œπ.‚âà`any`? P.any1
	: Œπ.‚âà`!`? P.!(Œπ.Œπ)
	: Œπ.‚âà`√ó`? P(Œπ.Œπ).√ó(Œπ.for,Œπ.greedy) .map(.join(''))
	: Œπ.‚âà`seq`? P(Œπ.Œπ) .map(.join(''))
	# backref
	# behind
	# capture
	: ‚ÄΩ(Œπ.tag) )

################################################################################
module.if_main_do(=>{

;[
	,/(?:)/u
	,/(?!)/u
	,/(?:(|))/u
	,/(|)/u

	,/(#!.*\n)?$/u
	,/foo[a-x]/u
	,/^(foo)?(?:b(b.)){2,7}\baz[^]??[^\n](?:\\b.ar|\b[\ba-c-e()}][^\s]|b*?|baz(gremlin\u2424$)?(?!groblem)|)*\3/u
	,/\{([0-9]+)(?:(,)([0-9]*))?\}/u
	,/[^imu]/u
	,/(['"])((\\.|(?!\1|\\)[^])*?\1)/u
	,/(?:\\[^]|(?!`|\$\{)[^])+/u
	,/(?=a|b)[^a]/u

	,/[\d]/u
	,/[^\D]/u
	,/[^]/u
	,/[^]*#!/u
].forEach(Œπ=>cn.log( Œπ,/*'\n=',parse_regex(Œπ),*/'\n=',$0(Œπ),'\n' ))

;[
	,[ /[^]*?(?:#!.*)$/um ,'lambda bar lorem ipsum\nsalem peacemaker #!/usr/bin/env Œ∂\n{R·µ¢:R} ‚Üê it\n# 5\n\n' ]
	# ,[ /[^]*?#!.*\n/u ,'lambda bar lorem ipsum\nsalem peacemaker #!/usr/bin/env Œ∂\n{R·µ¢:R} ‚Üê it\n# 5\n\n' ]
	# ,[ /[^]*?#!/u ,' #!' ]
].forEach(([Œπ,test])=>{
	ast ‚Üê $0(Œπ)
	p ‚Üê P_ify(ast)
	# cn.log( Œπ,'\n=',ast,'\n=',p,'\nusing:',[test],'\n' )
	cn.log( Œπ,'\n=',ast,'\n=',p,'\nusing:',[test],'\n',[p.exec0(test)],'\n' )
	})

})
