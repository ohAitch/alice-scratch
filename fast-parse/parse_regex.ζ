#!/usr/bin/env Î¶
P â† require('./parser')

R â† (tag,Î¹)=>{ r â† Tag() ;r.tag = tag ;Î¹!==âˆ… &&( r.Î¹ = Î¹ ) ;â†© r }
P.prototype.R = Î»(tag){ tag+='' ;â†© @.map(Î¹=> R(tag,Î¹) ) }

â‹¯inspect â† { ,inspect(Ë£,opt,tag){â†© util.inspect(@.Î¹[0],opt)+opt.stylize(@.tag,'regexp')+util.inspect(@.Î¹[1],opt) } }

walk_regex â† (Î¹,f)=> Î¹ |> (Î» me(Î¹){ if( Î¹&&Î¹.tag ){
	clone â† _.once(=>{ Î¹ = Tag() â€¦â† (Î¹) })
	# ifÎ” is weird. why?
	ifÎ”! â† (a,f=Object.is)=>{ for(kâ† in a) f(Î¹[k],a[k]) ||( clone() ,Î¹[k] = a[k] ) ;â†© Î¹ }
	if( Î¹.Î¹ ) Î¹ = ifÎ”!({ Î¹: Tarr(Î¹.Î¹)? Î¹.Î¹.map(me) : me(Î¹.Î¹) })
	Î¹ = f(Î¹,{ifÎ”!})
	} ;â†© Î¹ })

Regex â† (=>{
	Regex â† =>Regex
	hex â† /[0-9a-fA-F]/u
	Escape â† P([ ,'\\' ,P.|([
		,P.|([ re`x(${hex}{2})` ,re`u\{(${hex}+)\}` ,re`u(${hex}{4})` ]).map(Î¹=> chr(parseInt(Î¹[1],16)))
		,P(/c([A-Z])/).map(Î¹=> chr( ord(Î¹[1]) - ord('A') + 1 ))
		,P(/[trnvf0]/).map(Î¹â‡’ {t:'\t',r:'\r',n:'\n',v:'\v',f:'\f',0:'\0'}[Î¹])
		,P(/[dDwWsSbB]/).map(Î¹=> $({
			,d:/[0-9]/
			# this will send unintended modes
			,w:/[A-Za-z0-9_]/
			,s:/[ \f\n\r\t\v\xa0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/
			,b:String.raw`(?<=\w)(?!\w)|(?<!\w)(?=\w)`
			,D:/[^\d]/ ,W:/[^\w]/ ,S:/[^\s]/ ,B:/(?!\b)/
			}[Î¹]))
		,P(/[1-9][0-9]*/).map(Î¹=> R(`backref`,Î¹|0) )
		,/[^]/
		]) ]).map(..1)
	Set_Escape â† P.|([ P('\\b').map(=>'\b') ,Escape ])
	Unit â† P.|([
		,Escape
		,P('.').map(=> $(/[^\n\r\u2028\u2029]/))
		,P(['(?:',Regex,')']).map(..1)
		# ! evidently these four are atomic, which i didn't know
		# atomic â† Î¹=> re`(?=(â€¦${Î¹}))\1`
		,P(['(?=',Regex,')']).map(..1).R`not`.R`not`
		,P(['(?!',Regex,')']).map(..1).R`not`
		,P(['(?<=',Regex,')']).map(..1).R`behind`
		,P(['(?<!',Regex,')']).map(..1).R`behind`.R`not`
		,P(['(',Regex,')']).map(..1).R`capture`
		,P(['[' ,/\^?/ ,(=>{ t â† P.|([ Set_Escape,/[^\]]/ ]) ;â†© P.|([ P([t,'-',t]).map(Î¹=>[Î¹[0],Î¹[2]]) ,t ]).* })() ,']'])
			.map(([Ë£,not,Î¹,Ê¸])=>{ r â† R(`Â¦`,Î¹.map(Î¹=> Tarr(Î¹)? R(`â‹¯`,Î¹) â€¦â† (â‹¯inspect) : Î¹ )) ;if( not ) r = !Î¹.â€–? R(`any`,âˆ…) : R(`seq`,[ R(`not`,r) ,R(`any`,âˆ…) ]) ;â†© r })
		,P(/[$^]/).R`^$`
		,/[^)]/
		])
	Postfix â† P([ Unit ,P([ P.|([ '*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/ ]) ,P('?').? ,]).? ]).map(([Î¹,rep])=>{
		if(! rep ) â†© Î¹
		for_ â† Î¹=> Î¹==='*'? [0,âˆž] : Î¹==='+'? [1,âˆž] : Î¹==='?'? [0,1] : (=>{ [Ë£,a,two,b] â† Î¹ ;â†© [a|0,b? b|0 : two? âˆž : a|0] })()
		â†© R(`Ã—` ,âˆ…)â€¦â† ({ ,Î¹ ,for:for_(rep[0]) ,greedy:!rep[1] }) })
	Infix â† Postfix.*?.R`seq`.sep_by('|').?.map(Î¹=> Î¹.â€–===1? Î¹[0] : R(`Â¦`,Î¹) )
	Regex â† Infix
	â†© Regex })()

regexpu â† npm`regexpu-core@4.1.3`
parse_regex â† Î¹=>{ [flags,Î¹] â† Tstr(Î¹)? ['',Î¹] : [Î¹.flags,Î¹.source]
	if( flags.re`y` ) â€½('/y is a caller thing')
	if( flags.re`g` ) â€½('/g is a caller thing')
	# g should be part of the call, not the regex (split no care, search no care, replace,match care simple, exec care weird) ,test idk
	# y: match,exec care simple ;split,search,replace,test idk

	if( flags.re`i` ) â€½('no /i support yet')
	flags.re`u` &&( Î¹ = regexpu(Î¹,flags) )


	Î¹ = Regex.parse(Î¹)
	walk_regex(Î¹,Î¹=> Î¹.â‰ˆ`^$` && flags.re`m` &&( Î¹.Î¹ += 'm' ) )
	â†© Î¹ }

normalize_to_axioms_regex â† Î¹=> walk_regex(Î¹,(Î¹,{ifÎ”!})=>{
	# these seem redundant. why?
	is_null â† Î¹=> Tstr(Î¹)? âœ— : ( (Î¹.â‰ˆ`Â¦` || Î¹.â‰ˆ`seq`) && Î¹.Î¹.every(is_null) ) || ( Î¹.â‰ˆ`not` && is_bottom(Î¹.Î¹) )
	is_bottom â† Î¹=> Tstr(Î¹)? âœ— : ( Î¹.â‰ˆ`Â¦` && Î¹.Î¹.every(is_bottom) ) || ( Î¹.â‰ˆ`seq` && Î¹.Î¹.some(is_bottom) ) || ( Î¹.â‰ˆ`not` && is_null(Î¹.Î¹) )

	is_1not â† Î¹=> Tstr(Î¹)? âœ— : Î¹.â‰ˆ`seq` && Î¹.Î¹.â€–===2 && Î¹.Î¹[0].â‰ˆ && Î¹.Î¹[0].â‰ˆ`not` && Î¹.Î¹[1].â‰ˆ && Î¹.Î¹[1].â‰ˆ`any`
	Î¹_1not â† .Î¹[0].Î¹

	if( is_1not(Î¹) && is_1not(Î¹_1not(Î¹)) ){
		Î¹ = Î¹_1not(Î¹_1not(Î¹))
		# if( length(Î¹)===1 ) â†© Î¹ ;else
		â†© R(`seq`,[ R(`not`,R(`not`,Î¹)) ,R(`any`,âˆ…) ])
		}

	if( Î¹.â‰ˆ`seq` ) Î¹ = ifÎ”!( { Î¹: Î¹.Î¹.mapâ€¦(Î¹=> Î¹.tag && Î¹.â‰ˆ`seq`? Î¹.Î¹ : [Î¹] ) } ,_.isEqual )

	if( (Î¹.â‰ˆ`Â¦`||Î¹.â‰ˆ`seq`) && Î¹.Î¹.â€–===1 ) â†© Î¹.Î¹[0]

	if( is_null(Î¹) ) â†© R(`seq`,[])
	# if( is_bottom(Î¹) ) â†© R(`not`,R(`seq`,[]))

	if( Î¹.â‰ˆ`^$` ) â†© $({ ,'^':'(?<![^])' ,'$':'(?![^])' ,'^m':'(?<![^\n\r])' ,'$m':'(?![^\n\r])' }[Î¹.Î¹])
	â†© Î¹ })

$0 â† Î¹=> normalize_to_axioms_regex(parse_regex(Î¹))
ð…‹ð…ð…ƒð…ƒð…® â† memoize_proc($0)
$ â† Î¹=>{ Î¹= Î¹ |>(ð…‹ð…ð…ƒð…ƒð…®) ;â†© _l.cloneDeep(Î¹) â€¦â† ({tag:Î¹.tag}) } # aka parse_normalize_regex_memoized

# exportsâ†; exports || ( exports = global )
# t â† { Regex,parse_regex,normalize_to_axioms_regex }
# exports â€¦â† (t)

ð…‹ð…©ð…«ð…«ð…ª â† .map(.filter(Î¹=>Î¹!==âˆ…).join(''))
P_ify â† Î¹=> walk_regex(Î¹,Î¹â‡’
	: Î¹.â‰ˆ`Â¦`? P.|(Î¹.Î¹)
	: Î¹.â‰ˆ`â‹¯`? P.â‹¯(â€¦Î¹.Î¹)
	: Î¹.â‰ˆ`any`? P.any1
	: Î¹.â‰ˆ`not`? Î¹.Î¹.not
	: Î¹.â‰ˆ`Ã—`? P(Î¹.Î¹).Ã—(Î¹.for,Î¹.greedy) |>(ð…‹ð…©ð…«ð…«ð…ª)
	: Î¹.â‰ˆ`seq`? P(Î¹.Î¹) |>(ð…‹ð…©ð…«ð…«ð…ª)
	# backref: P(result of a previous capture)
	# behind: reverse this parser and proceed in reverse
		# â€¡ needs parser.Î¶ support
		# nested behind seems to be implemented as noop
	# capture: index the captures found in the regex during the regex parsing. return an array with the match results. implicit capture around the entire regex.
	: â€½(Î¹.tag) )

################################################################################
module.if_main_do(=>{

# _log â† =>âˆ…
_log â† cn.log

;[
	,/(?:)(?!)(?:(|))(|)/u
	,/foo[a-x][^imu]/u
	,/^(foo)?(?:b(b.)){2,7}\baz[^]??[^\n](?:\\b.ar|\b[\ba-c-e()}][^\s]|b*?|baz(gremlin\u2424$)?(?!groblem)|)*\3(#!.*\n)?$/u
	,/\{([0-9]+)(?:(,)([0-9]*))?\}/u
	,/(['"])((\\.|(?!\1|\\)[^])*?\1)/u
	,/(?:\\[^]|(?!`|\$\{)[^])+/u
	,/(?=a|b)[^a]/u
	,/[^]\B[\d][^\D]/u
].forEach(Î¹=>_log( Î¹,/*'\n=',parse_regex(Î¹),*/'\n=',$0(Î¹),'\n' ))

;[
	,[ /[^]*?(?:#!.*)$/m ,'lambda bar lorem ipsum\nsalem peacemaker #!/usr/bin/env Î¶\n{Ráµ¢:R} â† it\n# 5\n\n' ]
	# ,[ /[^]*?#!.*\n/u ,'lambda bar lorem ipsum\nsalem peacemaker #!/usr/bin/env Î¶\n{Ráµ¢:R} â† it\n# 5\n\n' ]
	# ,[ /[^]*?#!/u ,' #!' ]
].forEach(([Î¹,test])=>{
	_log(Î¹)
	ast â† $0(Î¹)
	_log('=',ast)
	p â† P_ify(ast)
	_log('=',p)
	_log('using:',[test])
	_log('=',[p.exec0(test)])
	})

t â† P.|([
	,P.err_if_partial([ /'/,P(/([^]*?)'/).map(([Ë£,s])=> s) ])
	,/[^]+/
	]).catch(P.err_if_partial)
cn.log('and',t.parse("'foobar'"))
cn.log('and',t.parse("'foobar"))

})

################################### /u notes ###################################
# Without the u flag, . matches any BMP symbol except line terminators. When the ES6 u flag is set, . matches astral symbols too.
# with the u flag set, things like \a (where a is not an escape character) wonâ€™t be equivalent to a anymore.
# with u, the string is parsed as code points, without, parsed as string indices
# with u, negated char classes are for the full unicode range
# without u, theyre just for â‹¯0x10000
# affects i for sure
