#!/usr/bin/env Œ∂
P ‚Üê require('./parser').string
P.| = Œπ=> P(Set(‚Ä¶Œπ))

‚ãØinspect ‚Üê { ,inspect(À£,opt,tag){‚Ü© util.inspect(@.Œπ[0],opt)+opt.stylize(@.tag,'regexp')+util.inspect(@.Œπ[1],opt) } }

walk_regex ‚Üê (Œπ,f)=> Œπ |> (Œª me(Œπ){ if( Œπ&&Œπ.tag ){
	clone ‚Üê _u.once(=>{ Œπ = Tag() ‚Ä¶‚Üê (Œπ) })
	# ifŒî is weird. why?
	ifŒî! ‚Üê (a,f=Object.is)=>{ for(k‚Üê in a) f(Œπ[k],a[k]) ||( clone() ,Œπ[k] = a[k] ) ;‚Ü© Œπ }
	if( Œπ.Œπ ) Œπ = ifŒî!({ Œπ: Tarr(Œπ.Œπ)? Œπ.Œπ.map(me) : me(Œπ.Œπ) })
	Œπ = f(Œπ,{ifŒî!})
	} ;‚Ü© Œπ })

Regex ‚Üê (=>{
	Regex ‚Üê =>Regex
	hex ‚Üê /[0-9a-fA-F]/u
	Escape ‚Üê P([ ,'\\' ,P.|([
		,P(Set( ,re`x(${hex}{2})` ,re`u\{(${hex}+)\}` ,re`u(${hex}{4})` )).map(Œπ=> chr(parseInt(Œπ[1],16)))
		,P(/c([A-Z])/).map(Œπ=> chr( ord(Œπ[1]) - ord('A') + 1 ))
		,P(/[trnvf0]/).map(Œπ‚áí {t:'\t',r:'\r',n:'\n',v:'\v',f:'\f',0:'\0'}[Œπ])
		,P(/[dDwWsSbB]/).map(Œπ=> $({
			,d:/[0-9]/
			# this will send unintended modes
			,w:/[A-Za-z0-9_]/
			,s:/[ \f\n\r\t\v\xa0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/
			,b:String.raw`(?<=\w)(?!\w)|(?<!\w)(?=\w)`
			,D:/[^\d]/ ,W:/[^\w]/ ,S:/[^\s]/ ,B:/(?!\b)/
			}[Œπ]))
		,P(/[1-9][0-9]*/).map(Œπ=> Tag(`backref`,Œπ|0) )
		,/[^]/
		]) ]).map(..1)
	Set_Escape ‚Üê P.|([ P('\\b').map(=>'\b') ,Escape ])
	Unit ‚Üê P.|([
		,Escape
		,P('.').map(=> $(/[^\n\r\u2028\u2029]/))
		,P(['(?:',Regex,')']).map(..1)
		# ! evidently these four are atomic, which i didn't know
		# atomic ‚Üê Œπ=> re`(?=(‚Ä¶${Œπ}))\1`
		,P(['(?=',Regex,')']).map(..1).Tag`not`.Tag`not`
		,P(['(?!',Regex,')']).map(..1).Tag`not`
		,P(['(?<=',Regex,')']).map(..1).Tag`behind`
		,P(['(?<!',Regex,')']).map(..1).Tag`behind`.Tag`not`
		,P(['(',Regex,')']).map(..1).Tag`capture`
		,P(['[' ,/\^?/ ,(=>{ t ‚Üê P.|([ Set_Escape,/[^\]]/ ]) ;‚Ü© P.|([ P([t,'-',t]).map(Œπ=>[Œπ[0],Œπ[2]]) ,t ]).* })() ,']'])
			.map(([À£,not,Œπ, ∏])=>{ r ‚Üê Tag(`¬¶`,Œπ.map(Œπ=> Tarr(Œπ)? Tag(`‚ãØ`,Œπ) ‚Ä¶‚Üê (‚ãØinspect) : Œπ )) ;if( not ) r = !Œπ.‚Äñ? Tag(`any`,‚àÖ) : Tag(`seq`,[ Tag(`not`,r) ,Tag(`any`,‚àÖ) ]) ;‚Ü© r })
		,P(/[$^]/).Tag`^$`
		,/[^)]/
		])
	Postfix ‚Üê P([ Unit ,P([ P(Set( '*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/ )) ,P('?').? ,]).? ]).map(([Œπ,rep])=> !rep? Œπ :
		Tag(`√ó`,‚àÖ) ‚Ä¶‚Üê ({ ,Œπ ,for:rep[0] |>(Œπ=> Œπ==='*'? [0,‚àû] : Œπ==='+'? [1,‚àû] : Œπ==='?'? [0,1] : (([À£,a,two,b])=>[ a|0 ,b? b|0 : two? ‚àû : a|0 ])(Œπ)) ,sort:rep[1]?'asc':'desc' }) )
	Infix ‚Üê Postfix.*?.Tag`seq`.join('|').?.map(Œπ=> Œπ.‚Äñ===1? Œπ[0] : Tag(`¬¶`,Œπ) )
	Regex ‚Üê Infix
	‚Ü© Regex })()

regexpu ‚Üê npm`regexpu-core@4.1.3`
parse_regex ‚Üê Œπ=>{ [flags,Œπ] ‚Üê Tstr(Œπ)? ['',Œπ] : [Œπ.flags,Œπ.source]
	if( flags.re`y` ) ‚ÄΩ('/y is a caller thing')
	if( flags.re`g` ) ‚ÄΩ('/g is a caller thing')
	# g should be part of the call, not the regex (split no care, search no care, replace,match care simple, exec care weird) ,test idk
	# y: match,exec care simple ;split,search,replace,test idk

	if( flags.re`i` ) ‚ÄΩ('no /i support yet')
	flags.re`u` &&( Œπ = regexpu(Œπ,flags) )

	Œπ = Regex.parse(Œπ)
	walk_regex(Œπ,Œπ=> Œπ.‚âà`^$` && flags.re`m` &&( Œπ.Œπ += 'm' ) )
	‚Ü© Œπ }

normalize_to_axioms_regex ‚Üê Œπ=> walk_regex(Œπ,(Œπ,{ifŒî!})=>{
	# these seem redundant. why?
	is_null ‚Üê Œπ=> Tstr(Œπ)? ‚úó : ( (Œπ.‚âà`¬¶` || Œπ.‚âà`seq`) && Œπ.Œπ.every(is_null) ) || ( Œπ.‚âà`not` && is_bottom(Œπ.Œπ) )
	is_bottom ‚Üê Œπ=> Tstr(Œπ)? ‚úó : ( Œπ.‚âà`¬¶` && Œπ.Œπ.every(is_bottom) ) || ( Œπ.‚âà`seq` && Œπ.Œπ.some(is_bottom) ) || ( Œπ.‚âà`not` && is_null(Œπ.Œπ) )

	is_1not ‚Üê Œπ=> Tstr(Œπ)? ‚úó : Œπ.‚âà`seq` && Œπ.Œπ.‚Äñ===2 && Œπ.Œπ[0].‚âà && Œπ.Œπ[0].‚âà`not` && Œπ.Œπ[1].‚âà && Œπ.Œπ[1].‚âà`any`
	Œπ_1not ‚Üê .Œπ[0].Œπ

	if( is_1not(Œπ) && is_1not(Œπ_1not(Œπ)) ){
		Œπ = Œπ_1not(Œπ_1not(Œπ))
		# if( length(Œπ)===1 ) ‚Ü© Œπ ;else
		‚Ü© Tag(`seq`,[ Tag(`not`,Tag(`not`,Œπ)) ,Tag(`any`,‚àÖ) ])
		}

	if( Œπ.‚âà`seq` ) Œπ = ifŒî!( { Œπ: Œπ.Œπ.map‚Ä¶(Œπ=> Œπ.tag && Œπ.‚âà`seq`? Œπ.Œπ : [Œπ] ) } ,‚âà )

	if( (Œπ.‚âà`¬¶`||Œπ.‚âà`seq`) && Œπ.Œπ.‚Äñ===1 ) ‚Ü© Œπ.Œπ[0]

	if( is_null(Œπ) ) ‚Ü© Tag(`seq`,[])
	# if( is_bottom(Œπ) ) ‚Ü© Tag(`not`,Tag(`seq`,[]))

	if( Œπ.‚âà`^$` ) ‚Ü© $({ ,'^':'(?<![^])' ,'$':'(?![^])' ,'^m':'(?<![^\n\r])' ,'$m':'(?![^\n\r])' }[Œπ.Œπ])
	‚Ü© Œπ })

$0 ‚Üê Œπ=> normalize_to_axioms_regex(parse_regex(Œπ))
êÖãêÖùêÖÉêÖÉêÖÆ ‚Üê memoize_proc($0)
$ ‚Üê Œπ=>{ Œπ= Œπ |>(êÖãêÖùêÖÉêÖÉêÖÆ) ;‚Ü© _l.cloneDeep(Œπ) ‚Ä¶‚Üê ({tag:Œπ.tag}) } # aka parse_normalize_regex_memoized

# exports‚Üê; exports || ( exports = global )
# t ‚Üê { Regex,parse_regex,normalize_to_axioms_regex }
# exports ‚Ä¶‚Üê (t)

êÖãêÖ©êÖ´êÖ´êÖ™ ‚Üê .map(.filter(Œπ=>Œπ!==‚àÖ).join(''))
P_ify ‚Üê Œπ=> walk_regex(Œπ,Œπ‚áí
	: Œπ.‚âà`¬¶`? P(Set(‚Ä¶Œπ.Œπ))
	: Œπ.‚âà`‚ãØ`? P.‚ãØ(‚Ä¶Œπ.Œπ)
	: Œπ.‚âà`any`? P.any1
	: Œπ.‚âà`not`? P.not(Œπ.Œπ)
	: Œπ.‚âà`√ó`? P(Œπ.Œπ).√ó(Œπ.for,Œπ.sort) |>(êÖãêÖ©êÖ´êÖ´êÖ™)
	: Œπ.‚âà`seq`? P(Œπ.Œπ) |>(êÖãêÖ©êÖ´êÖ´êÖ™)
	# backref: P(result of a previous capture)
	# behind: reverse this parser and proceed in reverse
		# ‚Ä° needs parser.Œ∂ support
		# nested behind seems to be implemented as noop
	# capture: index the captures found in the regex during the regex parsing. return an array with the match results. implicit capture around the entire regex.
	: ‚ÄΩ(Œπ.tag) )

################################################################################
module.if_main_do(=>{

;[
	,/(?:)(?!)(?:(|))(|)/u
	,/foo[a-x][^imu]/u
	,/^(foo)?(?:b(b.)){2,7}\baz[^]??[^\n](?:\\b.ar|\b[\ba-c-e()}][^\s]|b*?|baz(gremlin\u2424$)?(?!groblem)|)*\3(#!.*\n)?$/u
	,/\{([0-9]+)(?:(,)([0-9]*))?\}/u
	,/(['"])((\\.|(?!\1|\\)[^])*?\1)/u
	,/(?:\\[^]|(?!`|\$\{)[^])+/u
	,/(?=a|b)[^a]/u
	,/[^]\B[\d][^\D]/u
].forEach(Œπ=>log( Œπ,/*'\n=',parse_regex(Œπ),*/'\n=',$0(Œπ),'\n' ))

;[
	,[ /[^]*?(?:#!.*)$/m ,'lambda bar lorem ipsum\nsalem peacemaker #!/usr/bin/env Œ∂\n{R·µ¢:T} ‚Üê it\n# 5\n\n' ]
	# ,[ /[^]*?#!.*\n/u ,'lambda bar lorem ipsum\nsalem peacemaker #!/usr/bin/env Œ∂\n{R·µ¢:T} ‚Üê it\n# 5\n\n' ]
	# ,[ /[^]*?#!/u ,' #!' ]
].forEach(([Œπ,test])=>{
	log(Œπ)
	ast ‚Üê $0(Œπ)
	log('=',ast)
	p ‚Üê P_ify(ast)
	log('=',p)
	log('using:',[test])
	log('=',[p.exec0(test)])
	})

})

################################### /u notes ###################################
# https://mathiasbynens.be/notes/es6-unicode-regex
# Without the u flag, . matches any BMP symbol except line terminators. When the ES6 u flag is set, . matches astral symbols too.
# with the u flag set, things like \a (where a is not an escape character) won‚Äôt be equivalent to a anymore.
# with u, the string is parsed as code points, without, parsed as string indices
# with u, negated char classes are for the full unicode range
# without u, theyre just for ‚ãØ0x10000
# affects i for sure
