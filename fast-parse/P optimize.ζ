# i am being pretty despair about this optimization task

# things many of you could do to help:
# find a parser like JSON.parse plus a simple efficient parsimmon thing to compare perf data against, maybe? as a loose reference point


P â† require(Ï†`~/code/scratch/fast-parse/parser`+'').list
lang â† require_new(Ï†`~/code/scratch/fast-parse/lang.Î¶`)

# walk_regex â† (Î¹,f)=> Î¹ |> (Î» me(Î¹){ if( Î¹&&Î¹.tag ){
# 	clone â† _u.once(=>{ Î¹ = Tag() â€¦â† (Î¹) })
# 	# ifÎ” is weird. why?
# 	ifÎ”! â† (a,f=Object.is)=>{ for(kâ† in a) f(Î¹[k],a[k]) ||( clone() ,Î¹[k] = a[k] ) ;â†© Î¹ }
# 	if( Î¹.Î¹ ) Î¹ = ifÎ”!({ Î¹: Tarr(Î¹.Î¹)? Î¹.Î¹.map(me) : me(Î¹.Î¹) })
# 	Î¹ = f(Î¹,{ifÎ”!})
# 	} ;â†© Î¹ })
# P_walk â† (p,f)

Function.prototypeâ€˜.means .get= Î»(){ Î¹ â† @+'' ;â†© Î¹===(..1)+'' ? Tag('.',1) : âˆ… }
is_map â† Î¹=>{tâ† ;â†© Î¹.tag==='chain' && (t= Î¹.f['â‰«']) && t.â€–===2 && t[1]===P.of }

root â† lang.ğ…ªğ…¨s_s
is_map(root)
root.f['â‰«'][0].means
Î¹ â† root.Î¹
Î¹.tag==='seq'
Î¹ â† Î¹.Î¹[1]
Î¹.tag==='Ã—'
Î¹.sort==='asc'
â‰ˆ( Î¹.for_ ,[0,âˆ] )
is_map(Î¹.Î¹)
Î¹ â† Î¹.Î¹.Î¹.Î¹[0]
Î¹.tag==='chain'
Î¹.Î¹

â€¡ hmm
â€¡ well, i cant see this
â€¡ i dont know how id change it
â€¡ next: see this?
â€¡ goodness, seeing already

normalize_to_axioms_regex â† Î¹=> walk_regex(Î¹,(Î¹,{ifÎ”!})=>{
	# these seem redundant. why?
	is_null â† Î¹=> Tstr(Î¹)? âœ— : ( (Î¹.â‰ˆ`Â¦` || Î¹.â‰ˆ`seq`) && Î¹.Î¹.every(is_null) ) || ( Î¹.â‰ˆ`not` && is_bottom(Î¹.Î¹) )
	is_bottom â† Î¹=> Tstr(Î¹)? âœ— : ( Î¹.â‰ˆ`Â¦` && Î¹.Î¹.every(is_bottom) ) || ( Î¹.â‰ˆ`seq` && Î¹.Î¹.some(is_bottom) ) || ( Î¹.â‰ˆ`not` && is_null(Î¹.Î¹) )

	is_1not â† Î¹=> Tstr(Î¹)? âœ— : Î¹.â‰ˆ`seq` && Î¹.Î¹.â€–===2 && Î¹.Î¹[0].â‰ˆ && Î¹.Î¹[0].â‰ˆ`not` && Î¹.Î¹[1].â‰ˆ && Î¹.Î¹[1].â‰ˆ`any`
	Î¹_1not â† .Î¹[0].Î¹

	if( is_1not(Î¹) && is_1not(Î¹_1not(Î¹)) ){
		Î¹ = Î¹_1not(Î¹_1not(Î¹))
		# if( length(Î¹)===1 ) â†© Î¹ ;else
		â†© Tag(`seq`,[ Tag(`not`,Tag(`not`,Î¹)) ,Tag(`any`,âˆ…) ])
		}

	if( Î¹.â‰ˆ`seq` ) Î¹ = ifÎ”!( { Î¹: Î¹.Î¹.mapâ€¦(Î¹=> Î¹.tag && Î¹.â‰ˆ`seq`? Î¹.Î¹ : [Î¹] ) } ,â‰ˆ )

	if( (Î¹.â‰ˆ`Â¦`||Î¹.â‰ˆ`seq`) && Î¹.Î¹.â€–===1 ) â†© Î¹.Î¹[0]

	if( is_null(Î¹) ) â†© Tag(`seq`,[])
	# if( is_bottom(Î¹) ) â†© Tag(`not`,Tag(`seq`,[]))

	if( Î¹.â‰ˆ`^$` ) â†© $({ ,'^':'(?<![^])' ,'$':'(?![^])' ,'^m':'(?<![^\n\r])' ,'$m':'(?![^\n\r])' }[Î¹.Î¹])
	â†© Î¹ })

$0 â† Î¹=> normalize_to_axioms_regex(parse_regex(Î¹))
ğ…‹ğ…ğ…ƒğ…ƒğ…® â† memoize_proc($0)
$ â† Î¹=>{ Î¹= Î¹ |>(ğ…‹ğ…ğ…ƒğ…ƒğ…®) ;â†© _l.cloneDeep(Î¹) â€¦â† ({tag:Î¹.tag}) } # aka parse_normalize_regex_memoized
