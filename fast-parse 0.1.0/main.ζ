#!/usr/bin/env Œ∂
// [parsimmon] would be so fun to optimize

// ----------------------------- todo eventually ---------------------------- //
// issue: makes parser not reentrant, as perf optimization
// G_opt ‚Üê {fast:null}
// G_opt.fast = true; r ‚Üê p.skip(/$/)._(in_,0); if (!r.status){ G_opt.fast = false; r ‚Üê p.skip(/$/)._(in_,i); /*!!r.status && ‚ÄΩ*/; r.status || ‚ÄΩ({ i:make_line_col_index(in_, r.furthest), expected:r.expected, in_:in_.slice(i,i+1e3), })
// merge_replies ‚Üê (r,last)=>{ if (G_opt.fast) ‚Ü© r
// Don't use backtracking, instead explore all variants concurrently. Backtracking requires to keep the entire input in memory (also known as a memory leak).
// Support left recursion.

// ---------------------------------- util ---------------------------------- //
log ‚Üê { levels:{ info:0, warn:1, } }
log.set = Œπ=> log.level = Œπ
_(log.levels).keys().forEach(t=>{
	log[t] = (‚Ä¶a)=> log.levels[log.level] <= log.levels[t] && cn.log(‚Ä¶a)
	})
log.set('warn')

// ------------------ eve-style records with tags, sort of ------------------ //
Tagged ‚Üê Œª(){ @.tag = new Set() }
Tagged.prototype.inspect = Œª(d,opt){
	ks ‚Üê (‚Ä¶a)=> _(@).keys().sort()._.isEqual(a.sort())
	‚Ü© @.tag.map(Œπ=> opt.stylize('#'+Œπ,'regexp')).join('')+( ks('tag')? '' : ' '+util.inspect( ks('tag','Œπ')? @.Œπ : _(_(@).pairs()._.object()).omit('tag') ,opt) ) }
Tagged.prototype.‚âà  = Œª(ss,‚Ä¶Œπs){ ss.length===1 || ‚ÄΩ; Œπ ‚Üê ss[0]; Œπ.re`^#` || ‚ÄΩ; ‚Ü© @.tag.has(Œπ.replace(/^#/,'')) }
Tagged.prototype.+= = Œª(ss,‚Ä¶Œπs){ ss.length===1 || ‚ÄΩ; Œπ ‚Üê ss[0]; Œπ.re`^#` || ‚ÄΩ; @.tag.add(Œπ.replace(/^#/,'')); ‚Ü© @ }
Tagged.prototype.-= = Œª(ss,‚Ä¶Œπs){ ss.length===1 || ‚ÄΩ; Œπ ‚Üê ss[0]; Œπ.re`^#` || ‚ÄΩ; @.tag.delete(Œπ.replace(/^#/,'')); ‚Ü© @ }
// Tagged.prototype.<- = 
R ‚Üê (‚Ä¶a)=>{t‚Üê;
	if (is_template(a)){ r ‚Üê new Tagged(); easy_template(Œπ=>Œπ)(‚Ä¶a).mapcat(Œπ=> Tstr(Œπ)? Œπ.trim().split(' ') : [{Œπ:Œπ[0]}]).forEach(Œπ=> Tstr(Œπ)? r.+=([Œπ]) : _(r).assign(Œπ) ); ‚Ü© r }
	a.length===1 || ‚ÄΩ; Œπ ‚Üê a[0]
	if (Œπ instanceof Tagged) ‚Ü© Œπ
	if (Tprim(Œπ)) ‚Ü© R`${Œπ}`
	if ((t=Object.getPrototypeOf(Œπ))===null || t===Object.prototype) ‚Ü© _(new Tagged()).assign(Œπ)
	‚ÄΩ }
// Œπ = {Œπ:6}
// R`#foo #bar ${Œπ}`
// R`#foo #bar ‚Ä¶${Œπ}`
// R`#foo #bar f:${Œπ}`
// R`#foo #bar ‚Ä¶${{f:Œπ}}`
// R(Œπ).+=`#repeat` vs R`#repeat ‚Ä¶${Œπ}`

map_tag_tree ‚Üê (Œπ,f)=>{ if(Œπ&&( Tarr(Œπ) || Œπ.tag )) _(Œπ).forEach((v,k)=> Œπ[k] = map_tag_tree(v,f) ); ‚Ü© f(Œπ) }

// ------------------------------- regex_parse ------------------------------ //
// P ‚Üê require_new(œÜ`~/file/code/scratch/fast-parse/main.Œ∂`+'')
anon_eefm3‚Üênull;
regex_parse ‚Üê Œπ=> (anon_eefm3 || ( anon_eefm3 = _.memoize(flags=>{
	ENC ‚Üê Œπ=> parse_external(OR_or_SEQ,Œπ.source || Œπ)
	dehex ‚Üê Œπ=> String.fromCodePoint(parseInt(Œπ,16))
	simplify ‚Üê Œπ=>{ if (Œπ && Œπ.tag){
		if (Œπ.Œπ){ if (Tarr(Œπ.Œπ)) Œπ.Œπ = Œπ.Œπ.map(simplify); else Œπ.Œπ = simplify(Œπ.Œπ) }
		if (Œπ.‚âà`#seq`){
			Œπ.Œπ = Œπ.Œπ.mapcat(Œπ=> Œπ.tag && Œπ.‚âà`#seq`? Œπ.Œπ : [Œπ] )
			if (Œπ.Œπ.length===1) ‚Ü© simplify(Œπ.Œπ[0])
			}
		if (Œπ.‚âà`#not` && Œπ.Œπ.‚âà`#set` && !Œπ.Œπ.Œπ.length) ‚Ü© ENC(/(?:)/)
		}; ‚Ü© Œπ }

	ESCAPE ‚Üê P(['\\',P.or([
		P(/x([0-9a-fA-F]{2})/).map(Œπ=> dehex(Œπ[1])),
		P(/u\{([0-9a-fA-F]+)\}/).map(Œπ=> dehex(Œπ[1])),
		P(/u([0-9a-fA-F]{4})/).map(Œπ=> dehex(Œπ[1])),
		P(/c[A-Z]|[trnvf0]|[dDwWsSbB]|[1-9][0-9]*/).map(Œπ‚áí
			{t:'\t',r:'\r',n:'\n',v:'\v',f:'\f',0:'\0'}[Œπ] ||( 0?0
			: Œπ[0]==='c'? String.fromCodePoint(Œπ[1].codePointAt() - 'A'.codePointAt() + 1)
			: Œπ==='d'? ENC(/[0-9]/u)
			: Œπ==='D'? ENC(/[^0-9]/u)
			: Œπ==='w'? ENC(/[A-Za-z0-9_]/u)
			: Œπ==='W'? ENC(/[^A-Za-z0-9_]/u)
			: Œπ==='s'? ENC(/[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/u)
			: Œπ==='S'? ENC(/[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/u)
			: Œπ==='b'? ENC(String.raw`(?<=\w)(?!\w)|(?<!\w)(?=\w)`)
			: Œπ==='B'? ENC(String.raw`(?<=\w)(?=\w)|(?<!\w)(?!\w)`)
			: ( Œπ===(Œπ = Œπ|0)+'' || ‚ÄΩ, R`#backref ${Œπ}` ) ) ),
		/[^]/
		])]).map(Œπ=>Œπ[1])
	SET_ESCAPE ‚Üê P.or([ P('\\b').map(()=>'\b'), ESCAPE ])
	s1 ‚Üê P.or([
		/[^.()[\]^$|\\]/,
		ESCAPE,
		P`.`.map(()=> ENC(/[^\n\r\u2028\u2029]/)),
		P`(?:${()=>OR_or_SEQ})`,
		P`(?!${()=>OR_or_SEQ})`.R`#not`,
		P`(?=${()=>OR_or_SEQ})`.R`#not`.R`#not`,
		P`(?<=${()=>OR_or_SEQ})`.R`#behind`,
		P`(?<!${()=>OR_or_SEQ})`.R`#behind`.R`#not`,
		P`(${()=>OR_or_SEQ})`.R`#capture`,
		P`[${[ /\^?/, (Œª(){ t ‚Üê P.or([ SET_ESCAPE,/[^\]]/ ]); ‚Ü© P.or([ P([ P([t,'-']).map(Œπ=>Œπ[0]), t ]), t, ]).* })() ]}]`
			.map(Œπ=>{ r ‚Üê R`#set ${Œπ[1]}`; if (Œπ[0]) r = R`#seq ${[ R`#not ${r}`, R`#any` ]}`; ‚Ü© r }),
		])
	TIMES ‚Üê P([ s1, P([ P.or([ '*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/ ]), P('?').?, ]).? ]).map(([Œπ,rep])=>{
		if (!rep) ‚Ü© Œπ
		for_ ‚Üê Œπ=> Œπ==='*'? [0,‚àû] : Œπ==='+'? [1,‚àû] : Œπ==='?'? [0,1] : (Œª(){ [À£,a,two,b] ‚Üê Œπ; ‚Ü© [a|0,b? b|0 : two? ‚àû : a|0] })()
		‚Ü© R({ Œπ, for:for_(rep[0]), greedy:!rep[1], }).+=`#repeat` })
	q ‚Üê dir=> ENC((!flags.re`m`? { '^':'(?<![^])', '$':'(?![^])' } : { '^':'(?<![^\n\r])', '$':'(?![^\n\r])' })[dir])
	s2 ‚Üê P.or([ P('^').map(q), P('$').map(q), TIMES ])
	OR_or_SEQ ‚Üê P.sep_by(s2.*.R`#seq`, '|').map(Œπ=> Œπ.length > 1? R`#or ${Œπ}` : Œπ[0] )
	‚Ü© Œπ=>{
		r ‚Üê parse_external(OR_or_SEQ,Œπ)
		if (flags.re`y`) r = R`#seq ${[R`#sticky`,r]}`
		if (flags.re`u`) r = R`#unicode ${r}`; else ‚ÄΩ('can only parse unicode regex')
		if (flags.re`i`) r = R`#ignore_case ${r}`
		if (flags.re`g`) ‚ÄΩ
		// g should be part of the call, not the regex (split no care, search no care, replace care simple, match care simple, exec care weird)
		‚Ü© R(simplify(r)).+=`#RegExp`
		} }) ))(Œπ.flags || '')(Œπ.source || Œπ)

// ------------------------------- fast_parse ------------------------------- //
P ‚Üê (Œπ,‚Ä¶Œπs)‚áí
	: Œπ.tag? Œπ
	: is_template([Œπ,‚Ä¶Œπs])? (()=>{
		Œπ = easy_template(Œπ=>Œπ)(Œπ,‚Ä¶Œπs)
		i ‚Üê Œπ.map((Œπ,i)=>[Œπ,i]).filter(([Œπ,i])=>Tarr(Œπ)).map(([Œπ,i])=>i)
		‚Ü© P(Œπ.map(Œπ=> Tarr(Œπ)?Œπ[0]:Œπ)).map(Œπ=> i.length===1? Œπ[i[0]] : i.map(i=> Œπ[i]) )
		})()
	: Tfun(Œπ)? R`#graph_thunk ${()=> P(Œπ())}`
	: Tstr(Œπ)? P(re`${Œπ}`)
	: T.RegExp(Œπ)? R`#regex ${Œπ}`
	// ---- regex-overlap --- //
	: Tarr(Œπ)? R`#seq ${Œπ.map(P.X)}`
	// ---------------------- //
	: ‚ÄΩ('cant make parser from',Œπ)
// ----- regex-overlap ---- //
P.any = ()=> R`#any`
// P.behind = Œπ=> R`#behind ${P(Œπ)}`
P.not = Œπ=> R`#not ${P(Œπ)}`
P.or = Œπ=> R`#or ${Œπ.map(P.X)}`
P.repeat = o=>{ o.Œπ = P(o.Œπ); ‚Ü© R(o).+=`#repeat` }
// P.set = Œπ=> R`#set ${Œπ}`
// ------------------------ //
P.return = o=> R(o).+=`#return`
P.__chain = ({Œπ,f})=> R({ Œπ:P(Œπ), f }).+=`#chain`
// ------------------------ //
P.__map = ({Œπ,f})=> P(Œπ).chain((Œπ,etc)=> P.return({ Œπ:f(Œπ,etc) }))
P.? = (Œπ,greedy=true)=> P.repeat({ Œπ, for:[0,1], greedy }).map(Œπ=> Œπ[0])
P.* = (Œπ,greedy=true)=> P.repeat({ Œπ, for:[0,‚àû], greedy })
P.+ = (Œπ,greedy=true)=> P.repeat({ Œπ, for:[1,‚àû], greedy })
P.?? = Œπ=> P.?(Œπ,false)
P.*? = Œπ=> P.*(Œπ,false)
P.+? = Œπ=> P.+(Œπ,false)
// ------------------------ //
Tagged.prototype.chain = Œª(f){‚Ü© P.__chain({ Œπ:@, f }) }
Tagged.prototype.map = Œª(f){‚Ü© P.__map({ Œπ:@, f }) }
Tagged.prototype.R = Œª(ss,‚Ä¶Œπs){ Œπs = [‚Ä¶Œπs,null]; ss = _([‚Ä¶ss,'']).assign({raw:[‚Ä¶ss.raw,'']}); ‚Ü© @.map(Œπ=>{ Œπs[-1] = Œπ; ‚Ü© R(ss,‚Ä¶Œπs) }) }
def(Tagged.prototype,'?',{get(){‚Ü© P.?(@) }})
def(Tagged.prototype,'*',{get(){‚Ü© P.*(@) }})
def(Tagged.prototype,'+',{get(){‚Ü© P.+(@) }})
def(Tagged.prototype,'??',{get(){‚Ü© P.??(@) }})
def(Tagged.prototype,'*?',{get(){‚Ü© P.*?(@) }})
def(Tagged.prototype,'+?',{get(){‚Ü© P.+?(@) }})
// ------------------------ //
P.sep_by = (p,sep)=> P.or([ P.sep_by1(p,sep), P.return({Œπ:[]}) ])
P.sep_by1 = (p,sep)=> P(p).chain(Œπ=> P([sep,p]).map(Œπ=>Œπ[1]).*.map(Œπs=> [Œπ].concat(Œπs)))

parse ‚Üê (p,in_,i)=>(Œª(){ L ‚Üê in_.length - i; if(0);
	// ---- regex-overlap --- //
	else if( @.‚âà`#any` ) ‚Ü© L > 0? make_win(i+1,in_[i]) : make_lose(i,{inspect(d,opt){‚Ü© opt.stylize('anything','special') }})
	else if( @.‚âà`#seq` ){ r ‚Üê []; t‚Üê; for(var p of @.Œπ){ t = merge_replies(parse(p,in_,i),t); if (!t.status) ‚Ü© t; r.push(t.Œπ); i = t.i }; ‚Ü© merge_replies(make_win(i,r),t) }	
	else if( @.‚âà`#or` ){ r‚Üê; for(var p of @.Œπ){ r = merge_replies(parse(p,in_,i),r); if (r.status) ‚Ü© r }; ‚Ü© r }
	else if( @.‚âà`#repeat` ){ @.greedy || ‚ÄΩ
		r ‚Üê []; prev_t‚Üê; j‚Üê0
		for(;j<@.for[0];j++){ t ‚Üê parse(@.Œπ,in_,i); prev_t = merge_replies(t,prev_t); if( t.status ){ i = t.i; r.push(t.Œπ) }else ‚Ü© prev_t }
		for(;j<@.for[1];j++){ t ‚Üê parse(@.Œπ,in_,i); prev_t = merge_replies(t,prev_t); if( t.status ){ i = t.i; r.push(t.Œπ) }else break }
		‚Ü© merge_replies(make_win(i,r), prev_t) }
	else if( @.‚âà`#not` ){ if( @.Œπ.tag && @.Œπ.‚âà`#not` ){ t ‚Üê parse(@.Œπ.Œπ,in_,i); ‚Ü© t.status? make_win(i,undefined) : t }else{ t ‚Üê parse(@.Œπ,in_,i); self ‚Üê @; ‚Ü© t.status? make_lose(i,{inspect(d,opt){‚Ü© opt.stylize('not','special')+' '+util.inspect(self.Œπ,opt) }}) : make_win(i,undefined) } }
	// else if( @.‚âà`#behind` ){ }
	// else if( @.‚âà`#set` ){ }
	// ---------------------- //
	else if( @.‚âà`#return` ) ‚Ü© @.e? make_lose(i,@.e) : make_win(i,@.Œπ)
	else if( @.‚âà`#chain` ){ r ‚Üê parse(@.Œπ,in_,i); ‚Ü© !r.status? r : merge_replies(parse(@.f(r.Œπ,{ start:i, i:r.i, in_ }),in_,r.i),r) }
	else if( @.‚âà`#regex` ){ !@.Œπ.flags.replace(/[muy]/g,'') || ‚ÄΩ; t ‚Üê @.Œπ.u.y.exec_at(in_,i); ‚Ü© t? make_win( i+t[0].length, t.length===1? t[0] : t.slice() ) : make_lose(i,@.Œπ) }
	// ---------------------- //
	else if( @.‚âà`#graph_thunk` ) ‚Ü© parse(( Tfun(@.Œπ) &&( @.Œπ = @.Œπ() ), @.Œπ ),in_,i)
	else ‚ÄΩ }).call(p)
p2 ‚Üê parse
parse = (p,in_,i)=>{ r ‚Üê p2(p,in_,i); log.info('parse',{p,in:in_.slice(i),r}); ‚Ü© r }
parse_external ‚Üê (p,in_,i=0)=>(Œª(){
	r ‚Üê parse(P([@,/$/]).map(Œπ=> Œπ[0]),in_,i)
	r.status || ‚ÄΩ({ i:make_line_col_index(in_, r.furthest), expected:r.expected, in_:in_.slice(i).slice(0,1e3), })
	‚Ü© r.Œπ }).call(p)

make_line_col_index ‚Üê (in_,i)=>{ lines ‚Üê in_.slice(0,i).split('\n'); ‚Ü© { offset:i, line:lines.length, column:lines[-1].length+1, } }

// make_win ‚Üê (i,Œπ)‚áí { status:true, i, Œπ, }
make_win ‚Üê (i,Œπ)‚áí { status:true, i, Œπ, furthest:-1, expected:[], }
make_lose ‚Üê (i,expected)‚áí { status:false, i:-1, Œπ:null, furthest:i, expected:[expected], }

interpret_regex_exec_at ‚Üê (Œπ,str,i)=>{
// 	regex_parse produces these tags:
// 	any
// 	not
// 	or
// 	repeat
// 	seq

// 	behind
// 	set

// 	backref
// 	capture
// 	ignore_case
// 	RegExp
// 	sticky
// 	unicode
	Œπ = regex_parse(Œπ)
	Œπ.‚âà`#unicode` || ‚ÄΩ
	Œπ = Œπ.Œπ
	Œπ.‚âà`#seq` && Œπ.Œπ[0].‚âà`#sticky` || ‚ÄΩ
	Œπ.Œπ.shift()
	Œπ = map_tag_tree(Œπ,Œπ‚áí
		: Tstr(Œπ)? P(Œπ)
		: Œπ.tag &&( Œπ.‚âà`#seq` || Œπ.‚âà`#repeat`)? Œπ.map(Œπ=> Œπ.join(''))
		: Œπ )
	cn.log('running',Œπ)
	log.set('info')
	t ‚Üê parse(Œπ,str,i)
	log.set('warn')
	‚Ü© !t.status? null : t.Œπ }

// resolve ‚Üê p=>{
// 	t ‚Üê search_graph(p,Œπ=> Œπ instanceof Parser)
// 	‚Ü© t.map(Œπ=> _(Œπ).omit('_','ps','p'))
// 	}

// Parser.prototype.resolve = Œª(seen){ seen ||( seen = new Map() )
// 	if (seen.has(@)) ‚Ü© seen.get(@); seen.set(@,@)
// 	switch( @.type ){
// 		default: ;
// 		break; case 'lazy': Tfun(@.Œπ) &&( @.Œπ = @.Œπ(), @.Œπ.resolve(seen) )
// 		break; case 'seq': case 'alt': @.ps.map(Œπ=> Œπ.resolve(seen))
// 		break; case 'times': case 'map': case 'map_js': case 'chain': @.p.resolve(seen)
// 		}
// 	‚Ü© seen.get(@) }
// Parser.prototype.optimize = Œª(seen){ seen ||( seen = new Map() )
// 	if (seen.has(@)) ‚Ü© seen.get(@); seen.set(@,@)
// 	switch( @.type ){
// 		default:;
// 		break; case 'lazy': seen.set(@,@.Œπ); @.Œπ = @.Œπ.optimize(seen); seen.set(@,@.Œπ)
// 		break; case 'seq': case 'alt': @.ps = @.ps.map(Œπ=> Œπ.optimize(seen))
// 		break; case 'times': case 'map': case 'map_js': case 'chain': @.p = @.p.optimize(seen)
// 		}
// 	‚Ü© seen.get(@) }

// -------------------------- extra (mostly unused) ------------------------- //

merge_replies ‚Üê (r,last)=>{
	// Returns the sorted set union of two arrays of strings. Note that if both arrays are empty, it simply returns the first array, and if exactly one array is empty, it returns the other one unsorted. This is safe because expectation arrays always start as [] or [x], so as long as we merge with this function, we know they stay in sorted order.
	unsafe_union ‚Üê (xs,ys)=>{
		xL ‚Üê xs.length
		yL ‚Üê ys.length
		if (xL===0) ‚Ü© ys; else if (yL===0) ‚Ü© xs
		r ‚Üê {}
		for (i ‚Üê 0; i < xL; i++) r[xs[i]] = true
		for (i ‚Üê 0; i < yL; i++) r[ys[i]] = true
		‚Ü© _.keys(r).sort() }
	if (!last) ‚Ü© r
	if (r.furthest > last.furthest) ‚Ü© r
	expected ‚Üê r.furthest===last.furthest? unsafe_union(r.expected, last.expected) : last.expected
	‚Ü© { status:r.status, i:r.i, Œπ:r.Œπ, furthest:last.furthest, expected, } }

// ---------------------------------- final --------------------------------- //

typeof module !== 'undefined' && ( module.exports = {P,parse_external} )

if (!module.parent){

word_extra ‚Üê re`‚ôà-‚ôìüîÖüîÜ`; word_extra_gu ‚Üê re`[${word_extra}]`.g
word ‚Üê re`A-Za-z0-9_$ ∞- ∏À°-À£Œë-Œ°Œ£-œâ·¥¨-·µõ·µ¢-·µ•·∂ú·∂†·∂ª‚Å∞‚Å±‚Åø‚Çê-‚Çì‚Çï-‚Çú‚ÑÇ‚Ñï‚Ñö‚Ñù‚Ñ§‚±º‚±Ω${word_extra}`
ident ‚Üê P(re`(?![0-9])[${word}]+|@`)
comment ‚Üê re`(?://.*|/\*[^]*?(?:\*/|$))+`
simple_js ‚Üê P(()=> P.or([
	P(comment).R`#comment`,
	P([ P('{'), simple_js, P('}') ]),
	P([ P.or([
		P(/(['"])((\\.|(?!\1|\\)[^])*?\1)/).map(Œπ=> Œπ[0]).R`#string`,
		ident,
		P([ P('`').R`#template`, tmpl_Œπ.*, P('`').R`#template` ]),
		/[)\]0-9]/,
		]), P(re`[ \t]*(?!${comment})/`).?.map(Œπ=> Œπ||'') ]),
	P(re`/(?:(?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/(?:[a-z]*)`).R`#regex`,
	P(re`[^{}/'"‚Ä¶${'`'})@\]${word}]+|[^}]`)
	]).* )
tmpl_Œπ ‚Üê P.or([ [ P('${').R`#template`, simple_js, P('}').R`#template` ], P(/(?:\\[^]|(?!`|\$\{)[^])+/).R`#template` ])
js_file ‚Üê P([ P(/(?:#!.*\n)?/).R`#shebang`, simple_js ])

Œ∂_parse ‚Üê code=>{ r ‚Üê []; for(var t of parse_external(js_file,code)._.flatten()) Tstr(t) && Tstr(r[-1])?( r[-1]+=t ): r.push(t); ‚Ü© r }
test ‚Üê ()=> Œ∂_parse(in_); in_ ‚Üê œÜ`/tmp/foo`.text // œÜ`~/code/scratch/Œ∂/index.Œ∂`.text
// pass ‚Üê JSON.stringify(test())===œÜ`/tmp/aaaa`.text
// cn.log(pass?'pass ‚úì':'fail X')
// cn.log('perf',bench(test,{TH:3}))
// cn.log('output',test())
// cn.log(regex_parse(/\{([0-9]+)(?:(,)([0-9]*))?\}/u))
// cn.log(regex_parse(/[^imu]/u))
// cn.log(regex_parse(/(['"])((\\.|(?!\1|\\)[^])*?\1)/u))
// cn.log(regex_parse(/(?:\\[^]|(?!`|\$\{)[^])+/u))
// cn.log(regex_parse(/(#!.*\n)?/u))

// cn.log(js_file)
// cn.log('perf',pretty_time_num(bench1(test) * (œÜ`~/code/scratch/Œ∂/index.Œ∂`.text.length / œÜ`/tmp/foo`.text.length)))
// cn.log(regex_parse(/^(foo)?(?:b(b.)){2,7}\baz[^]??[^\n](?:\\b.ar|\b[\ba-c-e()}][^\s]|b*?|baz(gremlin\u2424$)?(?!groblem)|)*\3/iuy))
// cn.log(/(?:b|a|r| |f|o|m)*foo+/uy.exec_at('bar fooooooo m fooo fo',0))
// cn.log([interpret_regex_exec_at(/(?:b|a|r| |f|o|m)*foo+/uy,'bar fooooooo m fooo fo',0)])

}




/*fix
regex_parse(/[^\s]/u)
regex_parse(/[üí©-üí´]/u)
regex_parse(/[\D]/)

#unicode#RegExp #seq [ #not #set [ #set [ ' ',
      '\f',
      '\n',
      '\r',
      '\t',
      '\u000b',
      '¬†',
      '·öÄ',
      '·†é',
      [ '‚ÄÄ', '‚Ää' ],
      '‚Ä®',
      '‚Ä©',
      '‚ÄØ',
      '‚Åü',
      '„ÄÄ',
      'Ôªø' ] ],
  #any ]

#unicode#RegExp #set [ 'ÔøΩ', [ 'ÔøΩ', 'ÔøΩ' ], 'ÔøΩ' ]

#set#RegExp [ #seq [ #not #set [ [ '0', '9' ] ], #any ] ]
*/

// -------- trash? -------- //
// seq_map ‚Üê P.seq_map = (‚Ä¶a)=>{ f ‚Üê a[-1]; a = a.slice(0,-1); Tfun(f) || ‚ÄΩ; ‚Ü© P(a).map(Œπ=> f(‚Ä¶Œπ)) }
// Parser.prototype.mark = Œª(){‚Ü© seq_map(P_index,@,P_index,(start,Œπ,end)‚áí { start, Œπ, end } ) }
// Parser.prototype.desc = Œª(e){‚Ü© P.or([ @,P.return({e}) ]) }
// __index ‚Üê ()=> P2({ type:'index', _(in_,i){‚Ü© make_win(i,make_line_col_index(in_,i)) }, })
