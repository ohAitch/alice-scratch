# .consider buffer .consider vectorlang
# pal::a.b = `https://cryptopals.com/sets/${a}/challenges/${b}`
# @pal::1.1 @<pre> Œπ0 as base64 = Œπ1
# @pal::1.2 @<pre> Œπ0 xor Œπ1 = Œπ2

# @pal::1.3
# [@<pre>] = msg xor byte
# msg: guess by √ó-avg [Œπ * [wikipedia::cat text freq normalize]] (?laplacian prior?) (?update syntax?)
# msg: guess by [wikipedia::cat text freq]

# @pal::1.4
# @md`[this file](‚Ü©)`
# find [= msg xor byte]

# @pal::1.5
# @<pre> Œπ0 xor [repeat "ICE"] as hex = Œπ1

# @pal::1.6
# edit_distance(a,b) = [a,b]‚ààbinary xor /[=1] .‚Äñ
#     edit_distance ‚Ä¶[@<pre>] = 37
# ciph = @md`[There's a file here](‚Ü©)`
# ciph = msg xor [repeat key]
# assume key.‚Äñ ‚äÇ 2..40

###################################### 1.3 #####################################
{nk,norm1,mean} ‚Üê numeric2
# ‚Åò write a vec_distance thing i guess http://www.numericjs.com/

################ prelude ###############
buffer ‚Üê Œπ=> Tstr(Œπ)? Buffer.from(Œπ,'utf8') : Œπ
bits ‚Üê Œπ=> Tarr(Œπ)? Œπ : [‚Ä¶buffer(Œπ)].map‚Ä¶(Œπ=> 8..map(i=> (Œπ>>i)&1 ))
Ox ‚Üê Œπ=>{Œπ+='' ;‚Ü© Buffer.from(Œπ,'hex') }
Ob ‚Üê Œπ=>{Œπ+='' ;‚Ü© [‚Ä¶Œπ].map(Œπ=> Œπ==='0'?0:1) }
b8 ‚Üê Œπ=> Buffer.from([Œπ])
xor_repeat ‚Üê (a,b)=>{ ;if( b.‚Äñ > a.‚Äñ ) #swap a b ;r ‚Üê Buffer.alloc(a.‚Äñ) ;for( i‚Üê0;i<r.‚Äñ;i++ ) r[i] = a[i] b^ b[i % b.‚Äñ] ;‚Ü© r }

########################################
texts ‚Üê @device_memo(=> [
	,wikipedia_source('English_language')
	,wikipedia_source('Cat')
	,'abc'
	,'abcabcabcabcabcabcabc'
	,'abcabcabcabcabcabc^abc'
	,Ob`11101000101011000010001001000000001100011001010010110000101001100100011010000100011010101110100100000000`
	,Ob`00010111110100111100011000111010111110111010101111110000011011111001010111110111110011001100101000001100`
	,Ob`11000111011011000111110100000000`
	,Ob`11101011101111111111110110101011111011000010110111100000110111111001111110111101010101010111100100001111`
	,‚Ä¶ 0x100.map(Œπ=> xor_repeat(b8(Œπ),Ox`1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736`))
	].map(bits) )()

êÖØêÖ´êÖ¨êÖú ‚Üê 4
find_mostlikely_frequencies_assuming_Œπ_has_fixed_frequencies_over_Œ±Œ≤ ‚Üê Œπ=>{
	/*assume*/ Œ±Œ≤ ‚Üê ‚ãØ(2^êÖØêÖ´êÖ¨êÖú)
	‚Ü© mean([ norm1(Œ±Œ≤.map(=>1)) ,‚Ä¶Œπ.map(Œπ=> Œ±Œ≤.map(Œ±=> Œ±===Œπ?1:0) ) ]) }

module.exports = texts
	.map(.chunk(êÖØêÖ´êÖ¨êÖú).map(Œπ=> parseInt(Œπ.reverse().join(''),2) ))
	.map(find_mostlikely_frequencies_assuming_Œπ_has_fixed_frequencies_over_Œ±Œ≤)

# i want to See 4b
# how can i code that see.Œ∂ visualization?
# obvs bar graph
# ‚Ä° this is something worth Seeing :) ‚Ä°

# so theres like, a number of texts and they have frequencies over 4b
# um
# what about the uh char graph? offsets make it weird, um, i guess a bar graph makes more sense
# bars above elements of 4b? lets just start with numbers for the xaxis
# this can be a simple bar graph, right?
# ‚Ä°‚Ä° check to make sure
# ‚Ä°‚Ä° then make it

# a simple 2d matrix
# bit freqs √ó texts

# or as a heatmap? probably yes, test it
# ‚Ä°‚Ä°‚Ä°
