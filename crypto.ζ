# .consider buffer .consider vectorlang
# pal::a.b = `https://cryptopals.com/sets/${a}/challenges/${b}`
# @pal::1.1 @<pre> ι0 as base64 = ι1
# @pal::1.2 @<pre> ι0 xor ι1 = ι2

# @pal::1.3
# [@<pre>] = msg xor byte
# msg: guess by ×-avg [ι * [wikipedia::cat text freq normalize]] (?laplacian prior?) (?update syntax?)
# msg: guess by [wikipedia::cat text freq]

# @pal::1.4
# @md`[this file](↩)`
# find [= msg xor byte]

# @pal::1.5
# @<pre> ι0 xor [repeat "ICE"] as hex = ι1

# @pal::1.6
# edit_distance(a,b) = [a,b]∈binary xor /[=1] .‖
#     edit_distance …[@<pre>] = 37
# ciph = @md`[There's a file here](↩)`
# ciph = msg xor [repeat key]
# assume key.‖ ⊂ 2..40

###################################### 1.3 #####################################
# ⁘ xor the cryptopal string with all the bytes
# ⁘ do a LOT of refactoring
# ⁘ write a vec_distance thing i guess

########### prelude ##########
nk ← npm`numeric@1.2.6`
buffer ← ι=> Tstr(ι)? Buffer.from(ι,'utf8') : ι
bits ← ι=>{ if( Tarr(ι) ) ↩ ι ;ι = buffer(ι) ;↩ […ι].map…(ι=> 8..map(i=> (ι & 1<<i) >>i)) }
Ox ← ι=>{ι+='' ;↩ Buffer.from(ι,'hex') }
Ob ← ι=>{ι+='' ;↩ […ι].map(ι=> ι==='0'?0:1) }
b8 ← ι=> Buffer.from([ι])
xor_repeat ← (a,b)=>{ ;if( b.‖ > a.‖ ) #swap a b ;r ← Buffer.alloc(a.‖) ;for( i←0;i<r.‖;i++ ) r[i] = a[i] b^ b[i % b.‖] ;↩ r }
norm∞ ← ι=> nk.div( ι ,ι.fold(nk.max.XX) )
norm1 ← ι=> nk.div( ι ,ι.fold(nk.add.XX) )
mean ← ι=> nk.diveq( ι.fold(nk.add.XX) ,ι.‖ )

##############################
texts ← memoize_persist(=> [
	,'abc'
	,'abcabcabcabcabcabcabc'
	,'abcabcabcabcabcabc^abc'
	,… 0x100.map(ι=> xor_repeat(b8(ι),Ox`1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736`))
	,wikipedia_source('English_language')
	,wikipedia_source('Cat')
	,Ob`11101000101011000010001001000000001100011001010010110000101001100100011010000100011010101110100100000000`
	,Ob`00010111110100111100011000111010111110111010101111110000011011111001010111110111110011001100101000001100`
	,Ob`11000111011011000111110100000000`
	,Ob`11101011101111111111110110101011111011000010110111100000110111111001111110111101010101010111100100001111`
	].map(bits) )()

find_mostlikely_frequencies_assuming_ι_has_fixed_frequencies_over_αβ ← ι=>{
	/*assume*/ αβ ← ⋯(2^4)
	↩ mean([ norm1(αβ.map(=>1)) ,…ι.map(ι=> αβ.map(α=> α===ι?1:0) ) ]) }
t ← texts.map(.chunk(4).map(ι=> parseInt(ι.join(''),2) )).map(find_mostlikely_frequencies_assuming_ι_has_fixed_frequencies_over_αβ)
# t.map(.map((ι,i)=> '▁▂▃▄▅▆▇█▁▂▃▄▅▆▇█'[i].×(round(173*ι)) ).join('') ).join('\n')

# i want to See 4b
# how can i code that see.ζ visualization?
# obvs bar graph
# ‡ this is something worth Seeing :) ‡
