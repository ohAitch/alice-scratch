# pal::a.b = `https://cryptopals.com/sets/${a}/challenges/${b}`
pal â† (a,b)=> pal.root+`/sets/${a}/challenges/${b}`
pal.root = 'https://cryptopals.com'

################################### @pal::1.1 ##################################
# @<pre> Î¹0 as base64 = Î¹1
[a,b] â† (GET_L(pal(1,1),âˆ)+'').match(re`<pre>.*?</pre>`.g).map(.re`<pre>(.*?)</pre>`[1])
Buffer.from(a,'hex').toString('base64') === b || â€½

################################### @pal::1.2 ##################################
# @<pre> Î¹0 xor Î¹1 = Î¹2
[a,b,r] â† (GET_L(pal(1,2),âˆ)+'').match(re`<pre>.*?</pre>`.g).map(.re`<pre>(.*?)</pre>`[1])
	.map(Î¹=> Buffer.from(Î¹,'hex'))
â‰ˆ( npm`buffer-xor@2.0.2`(a,b) ,r ) || â€½

################################### @pal::1.3 ##################################
# [@<pre>] = msg xor byte
# msg: guess by Ã—-avg [Î¹ * [wikipedia::cat text freq normalize]] (?laplacian prior?) (?update syntax?)
# msg: guess by [wikipedia::cat text freq]

bits â† Î¹=> [â€¦Î¹].mapâ€¦(Î¹=> 8..map(i=> (Î¹>>i)&1 ))
Ox â† Î¹=>{Î¹+='' ;â†© Buffer.from(Î¹,'hex') }
Ob â† Î¹=>{Î¹+='' ;â†© [â€¦Î¹].map(Î¹=> Î¹==='0'?0:1) }
b8 â† Î¹=> Buffer.from([Î¹])
xor_repeat â† (a,b)=>{ ;if( b.â€– > a.â€– ) #swap a b ;r â† Buffer.alloc(a.â€–) ;for( iâ†0;i<r.â€–;i++ ) r[i] = a[i] b^ b[i % b.â€–] ;â†© r }

ğ…‹ğ…®ğ…¬ğ…‹ â† Î¹=>{ # find_mostlikely_frequencies_assuming_Î¹_has_fixed_frequencies_over_Î±Î²
	/*assume*/ Î±Î² â† â‹¯(2^8)
	â†© numeric2.mean([ numeric2.norm1(Î±Î².map(=>1)) ,â€¦Î¹.map(Î¹=> Î±Î².map(Î±=> Î±===Î¹?1:0) ) ]) }
looks_english â† Î¹=> -numeric2.L2(
	,ğ…«ğ…­ğ…¦ğ…¦||(ğ…«ğ…­ğ…¦ğ…¦= ğ…‹ğ…®ğ…¬ğ…‹([â€¦Buffer.from(wikipedia_source('English_language'))]) )
	,ğ…‹ğ…®ğ…¬ğ…‹([â€¦Î¹]) ) ;ğ…«ğ…­ğ…¦ğ…¦â†;

0&& 0x100.map(b8.X).map(b=> xor_repeat(b,Ox`1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736`)|>(x=>[ ,'âŠ•'+b.toSting('hex')+':'+see_buffer(x) ,looks_english(x) ]) )._.sortBy(Î¹=>-Î¹[1])

################################### @pal::1.4 ##################################
# @md`[this file](â†©)`
# find [= msg xor byte]

t â† pal.root+(GET_L(pal(1,4),âˆ)+'').re`<a href='(.*?)'>this file</a>`[1]
;0&& (GET_L(t,âˆ)+'').split('\n').map(Î¹=> Buffer.from(Î¹,'hex'))
	.map(a=> 0x100.map(b8.X).map(b=>{
	r â† xor_repeat(a,b) ;r â† [see_buffer(a),see_buffer(b),see_buffer(r),looks_english(r)]
	if( !ğ…­ğ…¦ğ…«ğ…­ || r[3] > ğ…­ğ…¦ğ…«ğ…­[3] ){ ğ…­ğ…¦ğ…«ğ…­ = r ;log('found best',r) }
	})) ;ğ…­ğ…¦ğ…«ğ…­â†;

################################### @pal::1.5 ##################################
# @<pre> Î¹0 xor [repeat "ICE"] as hex = Î¹1
[a,r] â† (GET_L(pal(1,5),âˆ)+'').match(re`<pre>[^]*?</pre>`.g).map(.re`<pre>([^]*?)</pre>`[1])
a â† xor_repeat(Buffer.from('ICE'),Buffer.from(a))
b â† Buffer.from(r.replace(/\s/g,''),'hex')
â‰ˆ(a,b) || â€½

################################### @pal::1.6 ##################################
# edit_distance(a,b) = [a,b]âˆˆbinary xor /[=1] .â€–
#     edit_distance â€¦[@<pre>] = 37
# ciph = @md`[There's a file here](â†©)`
# ciph = msg xor [repeat key]
# assume key.â€– âŠ‚ 2..40

# https://cryptopals.com/sets/1/challenges/6
