#!/usr/bin/env node
# hey, if you're gonna break this, keep a previous stable version ready this time. ive spent entirely too much time rescuing our state

# ι = it
# ‖ = size/length/shape
# odd synonym: k, name(, id)(, i?), 𐑯𐑱𐑥

#################################### prelude ###################################
'use strict' ;require('module').wrapper[0] += `'use strict';` # enable strict mode everywhere

#################################### ζ infra ###################################
γ ← global
γ.γ = γ
def0 ← Object.defineProperty
γ.def = (o,name,ι)=> def0(o,name,_u({,configurable:✓,enumerable:✓}).assign(ι))
γ.𐅯Set = (…ι)=> new Set(ι)

#################################### prelude ###################################
γ._u = npm`underscore@1.8.3` # lodash is better than underscore except for _()

γ.‽ = (…a)=>{ throw a.‖===1 && T.Error(a[0])? a[0] : Error(a.map(ι=> Tstr(ι)? ι : ζ_inspect(ι)).join(' ')) }
γ.catch_union = f=>{ try{ r ← f() ;bad ← T.Error(r) ;if( !bad) ↩ r }catch(e){ r ← e ;T.Error(r) || ‽ ;↩ r } ;bad && ‽ }
γ.catch_union2 = f=>{ try{↩ f() }catch(e){↩ e } }
γ.catch_ι = f=>{ try{ r ← f() ;bad ← r===∅ ;if( !bad) ↩ r }catch(e){} ;bad && ‽ }
γ.catch_ = f=> λ(){ try{ ↩ f.apply(@,arguments) }catch(e){ '__catchable' in e || ‽(e) ;↩ e.__catchable } }
γ.return_ = ι=>{ throw {__catchable:ι} }
γ.new_ = ι=> Object.create( ι? ι.prototype || ι : null )

γ.T = ι=>{t←;
	if( (t= typeof ι)!=='object' ) ↩ t==='boolean'? '✓✗' : t ;if( ι===null ) ↩ 'null'
	if( Object.getPrototypeOf(ι)===Object.prototype ) ↩ 'object'
	for( t of is_l ) if( t[1](ι) ) ↩ t[0]
	↩ 'object' }
b_util ← catch_ι(=> process.binding('util') )
is_l ← [
	,['Array',Array.isArray]
	,['Buffer',Buffer.isBuffer]
	# , ['Error',ι=> Object.prototype.toString.call(ι)==='[object Error]' || ι instanceof Error]
	,… ['Error','String','Boolean','Number'].map(ty=> [ty,ι=> Object.prototype.toString.call(ι)==='[object '+ty+']'])
	,… !b_util? [] : ['AnyArrayBuffer','DataView','Date','Map','MapIterator','Promise','RegExp','Set','SetIterator','TypedArray'].map(ι=> [ι,eval(`ι=> b_util.is${ι}(ι)`)])
	]
# would like to be using ∈ instead
Object.assign(T,_u(is_l).object(),{
	,symbol: ι=> typeof ι==='symbol'
	,✓✗: ι=> typeof ι==='boolean'
	,string: ι=> typeof ι==='string'
	,number: ι=> typeof ι==='number'
	,function: ι=> typeof ι==='function'
	,primitive: ι=>{ switch(typeof ι){ case'undefined': case'boolean': case'number': case'string': case'symbol': ↩ ✓ ;case'object': ↩ ι===null ;default: ↩ ✗ } }
	,boxed: ι=>{ if( ι===null || typeof ι!=='object' ) ↩ ✗ ;t ← Object.getPrototypeOf(ι) ;t = t.constructor&&t.constructor.name ;↩ ( t==='Boolean'||t==='String'||t==='Number' ) && /^\[object (Boolean|String|Number)\]$/.test(Object.prototype.toString.call(ι)) }
	,ℤ: Number.isInteger
	,'-0': ι=> ι===0 && 1/ι < 0
	,NaN: Number.isNaN
	})
Object.assign(γ,{ ,Tstr:T.string ,Tnum:T.number ,Tfun:T.function ,Tarr:T.Array ,Tprim:T.primitive })
T.primitive.ι = Set(,'undefined','boolean','number','string','symbol','null')
T.boxed.ι = Set(,'Boolean','String','Number')

γ.falsy = ι=> ι===∅||ι===null||ι===✗
γ.or∅ = (a,b)=> a!==∅? a : b

#################################### ζ infra ###################################
# prefix hook . does not require parens around the right side, but can only do side effects
γ.𐅯𐅮𐅦𐅬𐅂 = f=>{ 𐅭𐅩𐅝𐅋𐅩.f = f ;↩ 𐅭𐅩𐅝𐅋𐅩 } ;𐅭𐅩𐅝𐅋𐅩 ← def({ f:∅ },'ι',{ set(ι){ @.f(ι) } })

################ postfix ###############
# def(Function.prototype,'‘@',{ ,get(){↩ @.call.bind(@) } })
# def(Function.prototype,'flip_',{ ,get(){↩ (a,b)=> @(b,a) } })

Iterator_from ← ι⇒ { ,ι ,@@iterator:ι.@@iterator.bind(ι) }
γ.postfix = new Proxy(Iterator_from(Set()),{set(@0,id,ι,@_){t←; id+='' ;@0.ι.add(id)
	;(γ[id] = ι).@@toPrimitive = (ι=>=>ι)(Symbol(id))
	wrap ← f⇒ { ,enumerable:✗ ,get:(ι=>=>ι)( λ(){↩ f.call(∅,@,…arguments) } ) ,set(f){ def(@,ι,wrap(f)) } }
	def(Object.prototype,ι,wrap(ι))
	↩ ✓ }})

postfix['|>'] = (ι,f)=> f(ι)
postfix['<|'] = (f,ι)=> f(ι)
postfix['!>'] = (ι,f)=>( f(ι) ,ι )
postfix['…←'] = Object.assign
postfix['…←|'] = (a,…b)=>{ for(ι← of b) for(i← of Object.getOwnPropertyNames(ι)) a.hasOwnProperty(i) ||( a[i] = ι[i] ) ;↩ a }
postfix['∋'] = (a,b)=> Object.prototype.isPrototypeOf.call( a.prototype||a ,b )

𐅨𐅝𐅃𐅂𐅮 ← => λ me(…a){ l ← me['≫'] ;t ← l[0].call(@,…a) ;for(i←1;i<l.‖;i++) t = l[i](t) ;↩ t }
# should be on Function.prototype instead of Object.prototype
postfix['≫'] = (…ι)=>{ ι=ι.map…(ι=> ι['≫'] || [ι] ) ;↩ ι.‖<=1? ι : 𐅨𐅝𐅃𐅂𐅮() …←({'≫':ι}) }
postfix['≪'] = (…ι)=> γ['≫'](…ι.reverse())

# obj_hash ← ι=> [ ,[(a,b)=>a===b,[…protos(ι)][1]] ,[≈,ps(ι)] ,…(Tfun(ι)? [[(a,b)=>a===b,Function.prototype.toString.call(ι)]] : []) ]
# postfix['#obj='] = (a,b)=> [a,b].map(obj_hash) |> (ι=> _u.zip(…ι)).every(([a,b])=> a[0](a[1],b[1]))

############### Property ###############
# minimal
γ.Property = λ(o,_id){ ;this.o = o ;this._id = _id }
def(Property.prototype,'ι',{ ,get(){↩ @.o[@._id] } ,set(ι){ @.o[@._id] = ι } })
def(Property.prototype,'∃',{ ,get(){↩ Object.prototype.hasOwnProperty.call(@.o,@._id) } ,set(ι){ !ι? delete @.o[@._id] : @.∃ || def(@.o,@._id,{ ,value:∅ ,writable:✓ ,enumerable:or∅(ι.enumerable,✓) }) } })
def(Property.prototype,'host',{ ,get(){↩ Object.getOwnPropertyDescriptor(@.o,@._id) } ,set(ι){ def0(@.o,@._id,ι) } }) # not a real setter. funky!
def(Property.prototype,'enumerable',{ ,get(){↩ @.host.enumerable } ,set(ι){ @.∃ = ✓ ;@.host = {enumerable:ι} } })
def(Property.prototype,'🔒',{ ,get(){↩ !@.host.configurable } ,set(ι){ @.∃ = ✓ ;@.host = {configurable:!ι} } })
def(Property.prototype,'value',{ ,get(){↩ @.host.value } ,set(ι){ @.∃ = ✓ ;@.host = {value:ι} } })
def(Property.prototype,'slot',{set(ι){ @.∃ = {enumerable:✗} ;@.host = Tfun(ι)? ι.‖===0? {get:ι} : {set:ι} : ‽ }})
def(Property.prototype,'get',{
	,set(ι){ @.∃ = ✓ ;@.host = {get:ι} }
	# ,get(){ h ← @.host ;↩ h && 'get' in h? h.get : => @.host.value }
	})
def(Property.prototype,'set',{
	,set(ι){ @.∃ = ✓ ;@.host = {set:ι} }
	# ,get(){ h ← @.host ;↩ h && 'get' in h? h.set : (ι=> @.host = {value:ι}) }
	})
γ.𐅯𐅭𐅝𐅨𐅮 = new Proxy({},{get(ˣ,id){↩ new Property(𐅋𐅨𐅦𐅨𐅭,id) }}) ;γ.𐅋𐅨𐅦𐅨𐅭 = ∅

Property.prototype.map! = λ(f){ @.ι = f(@.ι,@._id,@.o) ;↩ @ }
Property.prototype.Δ = λ(f){
	ι←; @ …← ({ ,get(){↩ ι } ,set(_ι){ f(_ι) ;ι = _ι } ,🔒:✓ })
	↩ @ }
Property.prototype‘.f .get=λ(){↩ @.ι.bind(@.o) }
Property.prototype.bind = λ(ι){ ι instanceof Property || ‽
	@ .host= { ,get(){↩ ι.get.call(@) } ,set(ι){↩ ι.set.call(@,ι) } ,enumerable:ι.enumerable }
	↩ @ }
thunk_s ← ff=> λ(ι){ _id ← @._id
	get ← Tfun(ι)? ff(ι,_id) : T.Promise(ι)? => ι.ι : ‽
	@ .host= { ,configurable:✓ ,get ,set(ι){ @‘[_id] .host= { ,value:ι ,writable:✓ } } } }
Property.prototype‘.thunk .set= thunk_s((ι,_id)=> λ(){↩ @[_id] = ι.call(@) })
Property.prototype‘.f1ι .set= thunk_s((ι,_id)=> λ(){ r← ι.call(@) ;r!==∅ &&( @[_id] = r ) ;↩ r })

################################### module.ζ ###################################
γ.node = {} ;𐅩𐅋 ← (a,b)=> node‘[a] .thunk==> require(b) ;npm`builtin-modules@2.0.0`.map(ι=>𐅩𐅋(ι,ι)) ;𐅩𐅋('EventEmitter','events') ;𐅩𐅋('Module','module')
γ._l = npm`lodash@4.17.4`
γ._ = _u
γ.require_new = ι=> (𐅃𐅜𐅞𐅰𐅯||(𐅃𐅜𐅞𐅰𐅯= npm`require-uncached@1.0.3` ))( (ι+'').replace(/^\.(?=\/)/,φ.cwd) ) ;𐅃𐅜𐅞𐅰𐅯←;

γ.npm = (…a)=>{ ι←a[0]+'' ;↩ ι.includes('@')? require(npm_init(…a)) : 'npm`'+ι+'@'+shᵥ`npm show ${ι} version`+'`' }
npm_init ← (id_ver,sub='')=>{ id_ver+=''
	𐅫 ← φ`/usr/local/lib/𐅪𐅩modu/${id_ver+'__'+process.versions.modules}/node_modules`
	# to match ABI, https://github.com/electron/electron/blob/master/docs/tutorial/using-native-node-modules.md
	if(! 𐅫.∃ ) shᵥ`cd ${𐅫.dir_ensure.φ`..`} && npm --cache-min=Infinity install ${id_ver}`
	↩ 𐅫.φ`${id_ver.split('@')[0]}`+sub }
# in theory, log whenever somebody uses an outdated lib

#################################### prelude ###################################
γ.memoize_proc = f=>{ cache ← new Map() ;↩ ((…ι)=> cache.has…(…ι)? cache.get…(…ι) : cache.set…(…ι,f(…ι)) ) …← ({cache}) }
γ.memoize_weak = f=>{ cache ← new WeakMap() ;↩ (ι=>{ if( cache.has(ι) ) ↩ cache.get(ι) ;Tprim(ι) && ‽ ;r ← f(ι) ;cache.set(ι,r) ;↩ r }) …← ({cache}) }
# resource management is a thing & i havent thought about it enough
# WeakMap doesn't fix memoization resource management when keys are Tprim or equality isn't ===
# this does
γ.memoize_tick = f=>{ f = memoize_proc(f) ;cache ← f.cache ;↩ (ι=>{ t ← ι+'' ;process.nextTick(=> cache.delete(t) ) ;↩ f(ι) }) …← ({cache}) }
# ? frp will remove the last use(s) of @device0
γ.device0_n1_dir = '/~/Library/Caches/ζ.persist.0'
γ.@device0 = ι=> φ(device0_n1_dir).φ`${ι+''}`‘.json
γ.@device0buf = ι=> φ(device0_n1_dir).φ`${ι+''}`‘.buf
γ.@proc = ι=> 𐅜𐅩𐅭𐅦𐅰‘[ι+''] ;𐅜𐅩𐅭𐅦𐅰 ← {}

#################################### ζ infra ###################################
γ‘.§_ .thunk==> (ι=>ι+'') ≫(memoize_proc(ι=> require_new('/~/code/scratch/fast-parse/lang.ζ').parse(ι)))
γ‘.§0 .thunk==> (ι=>ι+'') ≫(@device_memo(ι=> require('/~/code/scratch/fast-parse/lang0.ζ').parse(ι)))
γ.§1 = ι=>{
	ι.length===1||‽ ;ι = ι[0]
	ι.tag===':' && falsy(ι.ι[1]) || ‽ ;ι = ι.ι[0]
	↩ {set _(b){
		𐅨𐅪𐅋𐅪 ← ι=> ι.tag==='.'? […𐅨𐅪𐅋𐅪(ι.ι[0]),ι.ι[1]] : [ι] ;ι = 𐅨𐅪𐅋𐅪(ι)
		ι.every(ι=> Tstr(ι) || ι.tag==='string' || ( ι.tag==='{}' && falsy(ι.ι[0]) && ι.ι.slice(1).every(ι=> Tstr(ι) || ι.tag==='string' ) ) ) || ‽ ;ι = cartesian(… ι.map(ι=> Tstr(ι)? [ι] : ι.tag==='string'? [ι.ι] : ι.ι.slice(1)) ) # bullshit
		b = b.get||b.set||'value' in b? b : { ,configurable:✓ ,enumerable:✓ ,writable:✓ ,value:b }
		ι.forEach(ι=> ι.slice(0,-1).reduce((r,ι)=>r[ι],γ) ‘[ι[ι.length-1]] .host= b )
		}}
	}
γ.§ = ι=> §1(§0(ι))

γ.__name = name=> ‘.name !>(.enumerable= ✗) .value= name
γ.seq_ws = ι=> (ι+'').split(/\s+/)
γ.alt_s = ι=> Set(… _u(ι).sortBy(ι=> -ι.‖) )
γ.alt_ws = ι=> alt_s(seq_ws(ι))
γ.lines = ι=>{ t ← ( ι.raw? ι.raw[0] : ι ).split('\n') ;↩ t.slice( t[0].trim()?0:1 ,t.‖ - (t[-1].trim()?0:1) ) }
γ.ζword =∅
γ‘.ζ_compile .thunk==>{ 𐅭𐅋𐅦𐅝𐅜←;𐅨𐅋𐅦𐅜𐅦←;𐅩𐅜𐅃𐅩𐅪←;𐅂𐅂𐅃𐅝𐅦←;𐅨𐅂𐅫𐅯𐅃←;𐅋𐅝𐅞𐅬𐅰←;𐅝𐅩𐅭𐅪𐅃←;𐅮𐅰𐅰𐅝𐅭←;𐅭𐅦𐅫𐅩𐅝←;𐅦𐅞𐅃𐅝𐅪←;𐅃𐅪𐅜𐅫𐅮←;𐅪𐅯𐅯𐅯𐅦←;𐅫𐅃𐅞𐅦←;
	word_extra0 ← re`(?:ifΔ!|object≫0)`
	word_extra1 ← re`(?:[♈-♓🔅🔆🎵🎲‡⧫◊§▣⋯‽‘≈≉⧗‖]|𐅃op<|𐅃𐅭op<)`
	word ← γ.ζword = re`(?:[A-Za-z0-9_$ʰ-ʸˡ-ˣΑ-ΡΣ-ωᴬ-ᵛᵢ-ᵥᶜᶠᶻ⁰ⁱⁿₐ-ₓₕ-ₜℂℕℚℝℤⱼⱽ⚓𐅂𐅃𐅋𐅜𐅝𐅞𐅦𐅨𐅩𐅪𐅫𐅬𐅭𐅮𐅯𐅰𐑐-𐑿∞ᛟ]|${word_extra0}|${word_extra1})`
	ζ_parse ← γ.ζ_parse = (=>{
		P ← require('./parsimmon2.js')
		ident ← P(re`(?![0-9])${word}+|@`)
		comment ← re`(//.*|/\*[^]*?(\*/|$)|#[\s#].*)+`
		simple_js ← P(=> P.alt(
			,P(comment).T`comment`
			,P.seq( P('{') ,simple_js ,P('}') )
			,P(re`(?:https://|file:)(?:[^\s"“”'<>]*[^\s"“”'<>)},.:;])`).map(ι=> js`${ι}`).T`js`
			,P.seq( P.alt(
				,P(/(['"])(((?!\1)[^\\]|\\.)*?\1)/).T`string`
				,ident
				,P.seq( P('`').T`template` ,tmpl_ι.many() ,P('`').T`template` )
				,P(/[)\]0-9]/)
				) ,P.alt( P(re`[ \t]*(?!${comment})/`) ,P.of('') ) )
			,P(/\[#persist_here .*?\]/)
			,P(re`/((?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/([a-z]*)`).T`regex`
			,P(re`(?:(?!${word})[^{}/#'"…${'`'})@\[\]])+|[^}]`)
			).many() )
		tmpl_ι ← P.alt( P.seq( P('${').T`template` ,simple_js ,P('}').T`template` ) ,P(/(?:\\[^]|(?!`|\$\{)[^])+/).T`template` )
		js_file ← P.seq( P(/(#!.*\n)?/).T`shebang` ,simple_js )
		↩ code=>{
			ι ← js_file.parse(code)._.flatten()
			r ← [] ;for(t← of ι) t.T? r.push(t) : r[-1]&&r[-1].T? r.push(t) : (r[-1]+=t)
			↩ r } })()
	id_c ← alt_ws`filter! map… map! has… get… set… join? join2? ⁻¹uniq _0_φ_seenbydevice0⁻¹ then⚓ ⁻¹ ∪! ∩! -! ?? *? +? ∪ ∩ ⊕ ‖ ⚓ -= += ? * + & | ∃ × ! -0 -1 -2 -3 -4 - 🔒 …`
	id_num ← alt_ws`0 1 2 3 4`
	ζ_compile_nonliteral ← ι=> ι
		# .replace(/\b(?:https:\/\/|file:)(?:[^\s"“”'<>]*[^\s"“”'<>)},.:;])/g ,ι=> js`url(${ι})`)
		.replace(𐅫𐅃𐅞𐅦||(𐅫𐅃𐅞𐅦= re`${word_extra0}+`.g ) ,unicode_names.X)
		.replace(/\b([0-9]+(?:\.[0-9]+)?)d/g,(ˣ,ι)=> `(${ι}*86400)` )
		.replace(𐅂𐅂𐅃𐅝𐅦||(𐅂𐅂𐅃𐅝𐅦= re`\.?@@(${word}+)`.g ),'[Symbol.$1]')
		.replace(/@/g,'this')
		.replace(/(=>|[=←:(,?]) *(?!\.\.\.)(‘?\.)/g,(ˣ,a,b)=> a+'(𐅭𐅞)=>𐅭𐅞'+b )
		.replace(𐅃𐅪𐅜𐅫𐅮||(𐅃𐅪𐅜𐅫𐅮= re`‘\.(${word}+)`.g ),(ˣ,ι)=> js`|> (ι=> new Property(ι,${ι}))` )
		.replace(/‘(?=\[)/g ,`|> (o=>( 𐅋𐅨𐅦𐅨𐅭 = o ,𐅯𐅭𐅝𐅨𐅮 ))` )
		.replace(𐅦𐅞𐅃𐅝𐅪||(𐅦𐅞𐅃𐅝𐅪= re`(\.)?(${alt_s([…postfix])})(?=\s*([(:])?)`.g ),(ˣ,dot,id,right)⇒ { ,∅:js`γ[${id}]` ,'(':js`[γ[${id}]]` ,':':js`${id}` }[dot?'(':right] )
		.replace(/✓/g,'true')
		.replace(/✗/g,'false')
		.replace(/∅/g,'undefined')
		.replace(𐅋𐅝𐅞𐅬𐅰||(𐅋𐅝𐅞𐅬𐅰= re`🏷(${word}+)(\s*)←`.g ),(ˣ,ι,s)=> js`…${ι+s}← 𐅯𐅮𐅦𐅬𐅂(__name(${ι})).ι=`) # an initial try ;probably .name inference needs another form
		.replace(/‘lexical_env/g,`𐅯𐅮𐅦𐅬𐅂(ι=> ι.eval_in_lexical_env= ι=>eval(ι) ).ι=`)
		.replace(/‽(?!\(|`| = \(…a\)=>)/g,'‽()')
		.replace(𐅨𐅋𐅦𐅜𐅦||(𐅨𐅋𐅦𐅜𐅦= re`(\[(?:${word}|[,…])+\]|\{(?:${word}|[,:…])+\}|${word}+)(\s*)←(?=[ \t]*(;|of\b|in\b)?)`.g ),(ˣ,name,ws,eq0)=> 'var '+name+ws+(eq0?'':'=') )
		.replace(/λ(?=\*?(?:[ \t][^\(=←]*)?\([^\)]*\)[ \t]*\{)/g,'function')
		.replace(𐅪𐅯𐅯𐅯𐅦||(𐅪𐅯𐅯𐅯𐅦= re`\.\.(${id_num})`.g ),(ˣ,ι)=> `[${ι}]`)
		.replace(𐅩𐅜𐅃𐅩𐅪||(𐅩𐅜𐅃𐅩𐅪= re`\.(${id_c})`.g ),(ˣ,ι)=> js`[${ι}]`)
		.replace(𐅝𐅩𐅭𐅪𐅃||(𐅝𐅩𐅭𐅪𐅃= re`(${id_c}):`.g ),(ˣ,ι)=> js`${ι}:`)
		.replace(/…/g,'...')
		# ! this is going to be really hard to take out
			.replace(/(['"])map\.\.\.\1/g,`'map…'`)
			.replace(/(['"])has\.\.\.\1/g,`'has…'`)
			.replace(/(['"])get\.\.\.\1/g,`'get…'`)
			.replace(/(['"])set\.\.\.\1/g,`'set…'`)
			.replace(/(['"])\.\.\.((?:←\|?)?)\1/g,`'…$2'`)
			# .replace(/\.‘this/g,'["‘@"]')
		.replace(/∞/g,'Infinity')
		.replace(/⇒(\s*([:{]))?/g,(ˣ,x,ι)=> '=>'+({ ,':':'0?0' ,'{':'0?0:' }[ι]||‽)+x )
		.replace(𐅭𐅦𐅫𐅩𐅝||(𐅭𐅦𐅫𐅩𐅝= re`(^|(?!${word})[^\s\)]\s*)(=>(?:\s*=>)*)`.g ),(ˣ,t,ι)=> t+'()=>'.×(ι.match(/=>/g).‖))
		.replace(/↩ ?/g,'return ')
		.replace(/([^]|^)\^/g,(ˣ,ι)=> ι==='b'? '^' : ι+'**' )
		.replace(𐅨𐅂𐅫𐅯𐅃||(𐅨𐅂𐅫𐅯𐅃= re`#swap ((?:${word}|[.])+) ((?:${word}|[.])+)`.g ),(ˣ,a,b)=>{ t ← '_'+🎲id.greek(9) ;↩ ζ_compile_nonliteral(`for(;;){ ${t} ← ${a} ;${a} = ${b} ;${b} = ${t} ;break}`) }) # why not just [a,b] = [b,a]?
		.replace(/\[#persist_here (.*?)\]/g,(ˣ,ι)=> '('+json2_read+js`)(${json2_show(φ(ι).buf)})`)
		.replace(𐅭𐅋𐅦𐅝𐅜||(𐅭𐅋𐅦𐅝𐅜= re`${word_extra1}+`.g ) ,unicode_names.X)
		.replace(/_double_vertical_line_(?=['"])/g,'‖')
		.replace(/([{([]\s*),/g,'$1')
		.replace(𐅮𐅰𐅰𐅝𐅭||(𐅮𐅰𐅰𐅝𐅭= re`return\s+var\s+(${word}+)`.g ),(ˣ,ι)=> `var ${ι} ;return ${ι}`)
		.replace(/(^|(?:^|(?:^|(?:^|(?!new ).).).)(?![.\w]|𐅯).)Set(?=\()/gm,(ˣ,a)=> a+'𐅯Set')
	ζ_compile ← memoize_tick(code=>{
		# ! it is a clumsy hack to put this on all of these code paths
		t ← code ;t = /^(\{|λ\s*\()/.test(t)? '0?0: '+t : t ;if( /^(\{|λ\s*\()/.test(t) ) t = '0?0: '+t
	
		r ← ζ_parse(t)

		# you fucker
		get𐅃𐅰𐅦𐅩 ← i=> i+2 < r.‖? [i,i+1,i+2].map(i=> r[i]).every(.T==='template')? r[i+1].ι : ∅ : ∅
		for(i←0;i<r.‖;i++) if( Tstr(r[i]) && r[i].endsWith('npm') && get𐅃𐅰𐅦𐅩(i+1)!==∅ && get𐅃𐅰𐅦𐅩(i+1).includes('@') )
			{ ;r[i] = r[i].replace(/npm$/,'') ;r[i+1] = `require(` ;r[i+2] = { ,T:'js',ι:`'${npm_init(r[i+2].ι)}'` } ; r[i+3] = `)` }
		𐅦𐅦𐅨𐅪 ← ι=> ( t[0]==='§'? ζ_compile('§1')+'('+JSON.stringify(§0(ι))+')' : ζ_compile(t[0])+'`'+ι+'`' ) + (ι.re`:$`?'._=':'')
		for(i←0;i<r.‖;i++) if( Tstr(r[i]) && (t= r[i].match(/§\w*$/)) && get𐅃𐅰𐅦𐅩(i+1)!==∅ )
			{ ;r[i] = r[i].replace(/§\w*$/,'') ;r[i+1] = { ,T:'js',ι:𐅦𐅦𐅨𐅪(get𐅃𐅰𐅦𐅩(i+1)) } ;r[i+2] = r[i+3] = '' }

		↩ r.map(ι⇒
			: ι.T==='comment'? ι.ι.replace(/^#/,'//')
			: ι.T? ι.ι
			: ζ_compile_nonliteral(ι) ).join('') })
	ζ_compile.⁻¹ = ι=> ι.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$Α-ΡΣ-Ωα-ω]+)(\s*)(=?)|\.\.\./g ,(ι,name,s,eq)⇒ {'function':'λ','return':'↩','this':'@','...':'…'}[ι] || (eq==='='? name+s+'←' : name+s+'←;') )
	↩ ζ_compile }

if( require.extensions && !require.extensions['.ζ'] )(=>{
	require.extensions['.ζ'] = (module,ι)=> module._compile(ζ_compile(node.fs.readFileSync(ι,'utf8')),ι)
	super_ ← require.extensions['.js'] ;require.extensions['.js'] = (module,ι)=>{ (node.path.extname(ι)==='' && node.fs.readFileSync(ι,'utf8').re`#!/usr/bin/env ζ\s`? require.extensions['.ζ'] : super_)(module,ι) }
	})()

#################################### prelude ###################################
γ.protos = λ*(ι){ for(;!( ι===null || ι===∅ ) ;ι = Object.getPrototypeOf(ι)) yield ι }

γ.simple_flesh = ι=> Tfun(ι)? T(ι)+ι : JSON.stringify(ι,(ˣ,ι)=>{ if( Tprim(ι)||Tarr(ι)) ↩ ι ;else{ r←{} ;_l.keys(ι).sort().forEach(i=> r[i]=ι[i]) ;↩ r } })
	# a shame this doesnt include json2_show s work at all ... gonna be slow on buffers
	# try{ ... }catch(e){ e.message==='Converting circular structure to JSON' || ‽(e) ;↩ npm`circular-json@0.4.0`.stringify(ι) } }
γ‘.simple_hash .thunk==>{
	bigintstr_to_buf ← ι=>{ ;ι ← npm`big-integer@1.6.26`(ι) ;r ← Buffer.alloc(8) ;r.writeUInt32BE( +ι.shiftLeft(-32) ,0 ) ;r.writeUInt32BE( +ι.and(2^32-1) ,4 ) ;↩ r }
	buf36 ← npm`base-x@1.0.4`([…/[0-9a-z]/].join('')).encode
	farmhash_stable_64 ← npm`farmhash@2.0.4`.fingerprint64 ≫ (bigintstr_to_buf)
	↩ simple_flesh ≫ (Buffer.from) ≫ (farmhash_stable_64) ≫ (buf36) ≫ (.padStart(13,'0').slice(1)) }

γ.poll1_simple = f=> Π(re=>{
	𐅩𐅫𐅂𐅬 ← (λ*(){ yield 0 ;ι ← 0.01 ;yield ι ;yield* ⋯(12).map(=> ι *= 1.5 ) ;yield* ⋯(10).map(=> 1) ;yield* ⋯(10).map(=> 5) ;for(;;) yield 30 })() |>(seq)
	𐅂 ← => (=>{ t ← f() ;t===∅||t===null? 𐅂() : re(t) }).in(𐅩𐅫𐅂𐅬.next_ι) ;𐅂() })

γ.@device_memo = f=>{
	d ← @device0('𐅦𐅃𐅂𐅂'+simple_hash(f)) ;d_ ← d.ι||{} ;𐅪𐅋𐅃𐅨 ← (t,ι)=>( ι.ι = t ,d.ι = d_ ,d_ = d.ι ,ι.ι )
	↩ (…a)=>{t←; ι ← d_‘[simple_hash(a)] ;↩ ι.∃? ι.ι : T.Promise(t= f(…a) )? t.union.then(t=> 𐅪𐅋𐅃𐅨(t,ι)) : 𐅪𐅋𐅃𐅨(t,ι) } }
	# may race condition but is unlikely & relatively harmless
	# it would be lovely if this s could use data from their previous versions
	# the Promise addition makes race conditions way more likely

γ.unicode_names = ι=> […ι].map(@device_memo(ι=>
	(𐅩𐅩𐅩𐅝𐅋||(𐅩𐅩𐅩𐅝𐅋= (=>{
		unicode ← npm('unicode@10.0.0','/category') |>(_l.values) .map…(_l.values)
		↩ unicode.filter(ι=> !/^</.test(ι.name)).map(ι=>[ parseInt(ι.value,16) ,'_'+ι.name.replace(/[- ]/g,'_').toLowerCase()+'_' ])._.object()
		})() ) )[ord(ι)]).X).join('') ;𐅩𐅩𐅩𐅝𐅋←;

########### parsers and such ###########
γ‘.regex_parse_0 .thunk==>{t←; # soon to be deprecated
	P ← require('./parsimmon2.js')
	𐅬𐅬 ← ι=> chr(parseInt(ι,16))
	ESCAPE ← P('\\').then(P.alt( P(/x([0-9a-fA-F]{2})/,1).map(𐅬𐅬) ,P(/u\{([0-9a-fA-F]+)\}/,1).map(𐅬𐅬) ,P(/u([0-9a-fA-F]{4})/,1).map(𐅬𐅬) ,P(/./).map(ι=> '.[|^$()*+?{}\\/'.includes(ι)? ι : P.T('escape',ι) ) ))
	s1 ← P.alt(
		,P(/[^.()[\]^$|\\]/)
		,ESCAPE
		,P`.`.T`any`
		,P`(?:${=>OR_or_SEQ})`
		,P`(?=${=>OR_or_SEQ})`.T`lookahead`
		,P`(?!${=>OR_or_SEQ})`.T`nlookahead`
		,P`(${=>OR_or_SEQ})`.T`capture`
		,P`[${[ /\^?/ ,( t= ESCAPE.or(/[^\]]/) ,P([ t.skip('-') ,t ]).or(t) ).many() ]}]`.map(ι=> P.T(ι[0]? 'nset' : 'set' ,ι[1]))
		)
	TIMES ← P([ s1 ,P.alt('*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/,P.of())
		.map(ι=> ι = !ι? ι : ι==='*'? [0,∞] : ι==='+'? [1,∞] : ι==='?'? [0,1] : (=>{ [ˣ,a,two,b] ← ι.match(/\{([0-9]+)(?:(,)([0-9]*))?\}/) ;↩ [a|0,b? b|0 : two? ∞ : a|0] })() )
		]).map(([ι,for_])=> !for_? ι : {T:'times' ,ι ,for:for_} )
	s2 ← P.alt( P('^').T`begin` ,P('$').T`end` ,TIMES )
	OR_or_SEQ ← P.sep_by(s2.many().T`seq` ,'|').map(ι=> ι.‖ > 1? P.T('or',ι) : ι[0])
	↩ ι⇒ {ι:OR_or_SEQ.parse(ι.source) ,flags:ι.flags} }
γ‘.applescript .thunk=⇒ {
	,parse: (=>{
	  P ← require('./parsimmon2.js')
	  ws ← ι=> ws_.then(ι).skip(ws_) ;ws_ ← P(/[ \t\n\r]*/)
	  value ← P(=> P.alt(false_,true_,number,object,array,string,raw) )
	  false_ ← P('false').map(=> ✗)
	  true_ ← P('true').map(=> ✓)
	  number ← P(/-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][-+]?[0-9]+)?/).map(ι=> +ι)
	  _member ← P.seq(P(/[ a-z0-9-]+/i).skip(ws(P(':'))) ,value)
	  object ← ws(P('{')).then(P.sep_by(_member,ws(P(',')))).skip(ws(P('}'))).map(ι=> ι.‖? _u.object(ι) : [])
	  array ← ws(P('{')).then(P.sep_by(value,ws(P(',')))).skip(ws(P('}')))
	  _char ← P(/[\n\t\x20-\x21\x23-\x5B\x5D-\u{10FFFF}]|\\(["\\\/bfnrt]|u[0-9a-fA-F]{4})/u).map(ι=> ι[0]!=='\\'? ι : {'"':'"','\\':'\\','/':'/',b:'\b',f:'\f',n:'\n',r:'\r',t:'\t'}[ι[1]] || chr(parseInt(ι.slice(2),16)) )
	  string ← P('"').then( _char.many().map(.join('')) ).skip(P('"'))
	  raw ← P(/[^,}"]+/).or(string.map_js((ι,[i0,i1],l)=> l.slice(i0,i1))).many().map(ι=>{ ι=ι.join('') ;↩ ι==='missing value'? ∅ : {T:'raw',ι} })
	  ↩ ι=> ι===''? ∅ : ws(value).parse(ι) })()
	,print: ι=> Tnum(ι)? ι+'' : Tstr(ι)? '"'+ι.replace(/["\\]/g,'\\$&')+'"' : Tarr(ι)? '{'+ι.map(applescript.print.X).join(',')+'}' : ‽
	}

genex ← λ Λ(ι){↩ 0?0
	: Tstr(ι)? [ι]
	: ι.flags!==∅?( ι.flags.replace(/u/,'') && ‽ ,Λ(ι.ι) )
	: ι.T==='capture'? Λ(ι.ι)
	: ι.T==='escape'? ‽
	: ι.T==='or'? ι.ι.map…(Λ)
	: ι.T==='seq'? cartesian(…ι.ι.map(Λ)).map(.join(''))
	# : ι.T==='times'? # Λ(ι.ι).map…(x=> _l.range(ι.for[0],ι.for[1]+1).map(i=> x.×(i)) )
	# 	ιs ← Λ(ι.ι)
	: ι.T==='set'? ι.ι.map…(ι⇒
		: Tarr(ι)? _l.range(ord(ι[0]),ord(ι[1])+1).map(chr)
		: ι.T==='escape'? ‽
		: [ι] )
	: ‽(ι) }

########################################
γ …←(_u(Math).pick('abs','ceil','exp','floor','log10','log2','max','min','round','sqrt','cos','sin','tan'),{ ,ln:Math.log ,π:Math.PI ,τ:Math.PI*2 ,e:Math.E ,'⍟':Math.log })
γ.🎲 = λ(ι){↩ arguments.length===0? Math.random() : Tnum(ι)? 🎲()*ι |0 : _l.sample(ι) }
γ‘.🎲id .thunk==>{
	t ← αβ=> (L=> L.map(=> 🎲(αβ)).join('')) …← ({αβ})
	🎲id ← t([…/[0-9a-z]/])
	🎲id.braille = t([…re`[⠁-⣿]`])
	🎲id.greek = t([…'𐅂𐅃𐅋𐅜𐅝𐅞𐅦𐅨𐅩𐅪𐅫𐅬𐅭𐅮𐅯𐅰'])
	↩ 🎲id }
γ‘.anon .get==> 🎲id.greek(4)

γ.ord = (ι,i)=> Tnum(ι)? ι : ι.codePointAt(i)
γ.chr = ι=> Tstr(ι)? ι : String.fromCodePoint(ι)

𐅯𐅩𐅪𐅨𐅃 ← λ*(θ){ for(;θ.i<θ.l.‖;) yield θ.l[θ.i++] }
γ.seq = ι=>{
	r ← new_(seq)
	if( Tarr(ι) ){ ;r.ι = 𐅯𐅩𐅪𐅨𐅃(r) ;r.i = 0 ;r.l = ι }
	else if( !ι.next ) r.ι = ι.@@iterator()
	else r.ι = ι
	↩ r }
seq.prototype = {
	,ι:∅ ,i:∅ ,l:∅
	,map:λ*(f){ for(t← of @.ι) yield f(t) }
	# ,'map…':λ(){} ,fold(){} ,×(){} ,filter(){} ,pin(){} ,find_(){} ,slice(){} ,'‖':λ(){} ,some(){} ,every(){}
	,get next_ι(){↩ @.ι.next().value }
	,get next_ιι(){ t ← @.ι.next() ;if( t.done )↩ ;t = t.value ;t===∅ && ‽ ;↩ t }
	,get clone(){ t← seq(@.l) ;t.i= @.i ;↩ t }
	}
seq.cartesian = (…ι)=> 𐅮𐅋𐅮𐅯(ι) ;𐅮𐅋𐅮𐅯 ← λ*(ι,i=0){ if( ι.length-i===0 ) yield [] ;else for(b← of ι[i]) for(c← of 𐅮𐅋𐅮𐅯(ι,i+1)) yield [b,…c] }
γ.cartesian = (…ι)=> […seq.cartesian(…ι)]
# (λ*(){ yield 5 })().next()
# Object.getOwnPropertyDescriptors([…protos(λ*(){}())][2])
# […protos(Set())].map(Object.getOwnPropertyDescriptors)
# […protos(Set().@@iterator())].map(Object.getOwnPropertyDescriptors)
# ok,,,, the cloneability property desired here is fundamentally impossible .yay

γ.⋯ = ι=> _l.range(ι)
γ.≈ = (a,b)=> _l.isEqualWith(a,b,(a,b)=> T.Buffer(a) && T.Buffer(b)? a.equals(b) : ∅ )
γ.≉ = (a,b)=> ! ≈(a,b)
γ.zip_min = (a,b)=> _l.zip( a.‖>b.‖? a.slice(0,b.‖) : a , a.‖<b.‖? b.slice(0,a.‖) : b )

§`{Array Set Map}.prototype._ :`{ get(){↩ _u(@)} }

# link: it.ζ
§`{Array Buffer String Function}.prototype.‖ :`{ get(){↩ @.length } }
§`{Set Map}.prototype.‖ :`{ get(){↩ @.size } }

# goal: replace `map` with `≫` everywhere .implementation slowed in hope for clarity wrt lists in the future of See
# 'Array.prototype.map'
# ,'Buffer.prototype.map':λ(f){ r ← Buffer.alloc(@.‖) ;for(i←0;i<@.‖;i++) r.push(f(@[i])) ;↩ r } does not even work
Set.prototype.map = λ(f){↩ […@].map(f) }
Map.prototype.map = λ(f){↩ […@.entries()].map(([i,ι])=> f(ι,i,@)) }
Number.prototype.map = λ(f){'use strict' ;ι←+@ ;r ← Array(ι) ;for(i←0;i<ι;i++) r[i] = f(i,i,ι) ;↩ r }

Array.prototype.map_ = Array.prototype.map
Set.prototype.map_ = λ(f){↩ new Set([…@].map(f)) }
Map.prototype.map_ = λ(f){↩ new Map([…@.entries()].map(f)) }

§`{Set Map}.prototype.some :`λ(f){↩ […@].some(f) }
§`{Set Map}.prototype.every :`λ(f){↩ […@].every(f) }

Array.prototype.map… = λ(f){ r ← [] ;for(i←0;i<@.‖;i++) r.push(…f(@[i],i,@)) ;↩ r }
§`{Set Map Number}.prototype.map… :`λ(f){↩ @.map(f).… }

Set.prototype.filter = λ(f){↩ Set(…[…@].filter(f)) }

Array.prototype.edge_comple = λ(f){ 𐅃𐅝←{}; r ← [] ;for(ι← of @){ t ← f(ι) ;t===𐅃𐅝 ||( 𐅃𐅝= t ,r.push([]) ) ;r[-1].push(ι) } ;↩ r }
Set.prototype.partition = λ(f){↩ _u([…@]).partition(f).map(ι=> Set(…ι)) }

Array.prototype‘['…'] .host= { get(){↩ @.map…(ι=>ι) } }

Array.prototype.fold = Array.prototype.reduce
Array.prototype.foldr = Array.prototype.reduceRight

Array.prototype.repeat = λ(x){↩ x<=0? [] : x.map…(=> @) }
Buffer.prototype.repeat = λ(x){↩ Buffer.concat(x<=0? [] : x.map(=> @)) }

# ,'String.prototype.trim':λ(ι=/\s+/)){↩ @.replace(re`^${ι}|${ι}$`.g,'') }
Array.prototype.trim = λ(ι){ a ← @[0]===ι ;b ← @[-1]===ι ;↩ !(a||b)? @ : @.slice( a?1:0 ,b?-1:@.‖ )}

String.prototype.× = String.prototype.repeat
Array.prototype.× = λ(x){↩ 0?0
	: Tnum(x)? x<=0? [] : x.map…(=> @)
	: Tarr(x)? @.map…(a=> x.map(b=> [a,b] ))
	: ‽ }
Buffer.prototype.× = λ(x){↩ Buffer.concat(x<=0? [] : x.map(=> @)) }

Set.prototype.join = λ(ι){↩ […@].join(ι) }

§`{Array Buffer String Set}.prototype.count :`λ(){ r ← new Map() ;for (t← of @) r.set(t ,(r.has(t)? r.get(t) : 0)+1 ) ;↩ r }
§`{Array Buffer String Set}.prototype.group :`λ(f){ f||(f = ι=>ι) ;r ← new Map() ;for (t← of @){ ;t2 ← f(t) ;t3 ← r.get(t2) ||( r.set(t2,t3=Set()) ,t3 ) ;t3.add(t) } ;↩ r }
§`{Array Buffer String Set}.prototype.group_uniq :`λ(f){ f||(f = ι=>ι) ;r ← new Map() ;for (ι← of @){ t ← f(ι) ;r.has(t) && ‽ ;r.set(t,ι) } ;↩ r }
§`{Array Buffer String Set}.prototype.group_uniq_reduce :`λ(f){ f||(f = ι=>ι) ;r ← new Map() ;for (t← of @) r.set(f(t),t) ;↩ r }

Map.prototype.zip = λ(…a){ a.unshift(@) ;r ← new Map() ;a.forEach((ι,i)=> ι.forEach((ι,k)=>{ t ← r.get(k) || [∅].×(a.‖) ;t[i] = ι ;r.set(k,t) })) ;↩ r }
# ! what is this? what does it do?

§`{Array Buffer String}.prototype.chunk :`λ(L){↩ _l.range(0,@.‖,L).map(i=> @.slice(i,i+L)) }
§`{Array Buffer String}.prototype.windows :`λ(L){↩ (@.‖-L+1).map(i=> @.slice(i,i+L)) }
§`{Array Buffer String}.prototype.'-1' :`{get(){↩ @.‖<1? ∅ : @[@.‖-1] },set(ι){ @.‖<1 || (@[@.‖-1] = ι) }}
§`{Array Buffer String}.prototype.'-2' :`{get(){↩ @.‖<2? ∅ : @[@.‖-2] },set(ι){ @.‖<2 || (@[@.‖-2] = ι) }}
§`{Array Buffer String}.prototype.'-3' :`{get(){↩ @.‖<3? ∅ : @[@.‖-3] },set(ι){ @.‖<3 || (@[@.‖-3] = ι) }}
§`{Array Buffer String}.prototype.'-4' :`{get(){↩ @.‖<4? ∅ : @[@.‖-4] },set(ι){ @.‖<4 || (@[@.‖-4] = ι) }}

§`{Array Set}.prototype.'∪' :`λ(…a){↩ new Set([@,…a].…) }
§`{Array Set}.prototype.'∩' :`λ(…a){ r ← new Set(@) ;for(x← of a){ x = T.Set(x)? x : new Set(x) ;for(ι← of r) x.has(ι) || r.delete(ι) } ;↩ r }
§`{Array Set}.prototype.'-' :`λ(…a){↩ new Set(@).-!(…a) }
§`{Array Set}.prototype.'⊕' :`λ(b){a←@ ;↩ a.-(b).∪(b.-(a)) }
§`{Array Set}.prototype.'∪!' :`λ(…a){ for(b← of a) for(ι← of b) @.add(ι) ;↩ @ }
# §`{Array Set}.prototype.'∩!' :`λ(…a){
§`{Array Set}.prototype.'-!' :`λ(…a){ for(t← of a) for(ι← of t) @.delete(ι) ;↩ @ }
# §`{Array Set}.prototype.'⊕!' :`λ(…a){

Map.prototype.has… = λ(…as){ι←@ ;as.‖>=1||‽ ;_1 ← as.pop() ;for(a← of as){ if(!ι.has(a))↩ ;ι = ι.get(a) } ;↩ ι.has(_1) }
Map.prototype.get… = λ(…as){ι←@ ;for(a← of as){ if(!ι.has(a))↩ ;ι = ι.get(a) } ;↩ ι }
Map.prototype.set… = λ(…as){t←;ι←@ ;as.‖>=2||‽ ;v ← as.pop() ;_1 ← as.pop() ;for(a← of as) ι = ι.has(a)? ι.get(a) : (ι.set(a,t=new Map()),t) ;ι.set(_1,v) ;↩ v }
# Map.prototype.| = λ(f){↩ ((…ι)=> @.has…(…ι)? @.get…(…ι) : f(…ι)) …←([@,f]) …←({set…:(…ι)=>@.set…(…ι)}) }

§`{Set Map}.prototype.filter! :`λ(f){ @.forEach((ι,i)=> f(ι,i,@) || @.delete(i)) }
Set.prototype.pop = λ(){ t ← @[0] ;@.delete(t) ;↩ t }
Set.prototype‘[0] .host= {get(){↩ seq(@).next_ι }}
§`{Array Set}.prototype.'-eq' :`λ(…a){ t ← _u([…@]).groupBy(simple_flesh) ;a.forEach(.forEach(ι=> delete t[simple_flesh(ι)])) ;↩ _l.values(t).… }

γ.Δset = (a,b)=> new Map([ ,… a.-(b).map(ι=>[ι,-1]) ,… b.-(a).map(ι=>[ι,1]) ]) # assume uniq
γ.object≫0 = (o,i_s,f)=> Object.create(o) …←(i_s.map(i=>[ i ,(…a)=> f(o[i](…a),i,o) ])._.object())
Set.prototype.Δ = λ(f){↩ object≫0(@,alt_ws`add clear delete`,ι=>{ f(@) ;↩ ι }) }

Map.prototype‘['⁻¹uniq'] .host= {get(){↩ new Map([…@.entries()].map(([a,b])=>[b,a])) }}
Map.prototype‘['⁻¹'] .host= {get(){↩ […@.keys()].group(ι=> @.get(ι)) }}

Array.prototype.find_ = λ(f){ r←; if( @.some(λ(ι,i,o){t←; if( (t= f(ι,i,o))!==∅ ){ r = [i,ι,t] ;↩ ✓ } })) ↩ r }
Array.prototype.find_index_deep = λ(f){
	for(i←0;i<@.‖;i++){ ι ← @[i]
		if( Tarr(ι)){ t ← ι.find_index_deep(f) ;if( t) ↩ [i,…t] }
		else{ if( f(ι) )↩ [i] }
		} }
Array.prototype.find_last_index = λ(f){ for(i←@.‖-1;i>=0;i--) if( f(@[i],i,@) ) ↩ i }
Array.prototype.join_ = λ(…s){ r← [] ;_0← ✓ ;for(t← of @) _0?( _0= ✗ ,r.push(t) ): r.push(…s,t) ;↩ r }

# ,'Set.prototype.@@iterator':Set.prototype.values
# ,'Map.prototype.@@iterator':Map.prototype.entries
RegExp.prototype.@@iterator = λ*(){yield* genex(regex_parse_0(@)) }
RegExp.prototype.exec_at = λ(ι,i){ @.lastIndex = i ;↩ @.exec(ι) }

node.stream.Readable.prototype.pin = λ(){↩ Π(yes=>{ t ← [] ;@.resume() ;@.on('data',ι=> t.push(ι) ).on('end',=> yes(Buffer.concat(t)) ) })}
Buffer.prototype.pipe = λ(to,opt){ t ← new node.stream.Duplex() ;t.push(@) ;t.push(null) ;↩ t.pipe(to,opt) }
node.EventEmitter.prototype.P = λ(id){id+='' ;↩ new_(𐅯𐅜𐅝𐅃𐅋) …← ({,host:@,id}) }
node.EventEmitter.prototype.Π = λ(id){↩ @.P(id).Π }

𐅯𐅜𐅝𐅃𐅋 ← { ,emit(…a){↩ @.host.emit(@.id,…a) } ,on(f){ @.host.on(@.id,f) ;↩@ } }
𐅯𐅜𐅝𐅃𐅋‘.Π …← ({ ,get(){↩ Π(yes=> @.host.once(@.id,yes)) } })
Promise.prototype‘.status .f1ι= λ(){get←;
	if(get= b_util&&b_util.getPromiseDetails ){ [r,ι] ← get(@) ;r = [∅,✓,✗][r] ;if( r!==∅ ){ [@.status,@.ι] = [r,ι] ;↩ r } }
	else{ t ← r=> ι=>{ [@.status,@.ι] = [r,ι] ;↩ @.status } ;@.then(t(✓),t(✗)) ;t(∅)(∅) ;↩ @.status } }
Promise.prototype‘.ι .f1ι= λ(){ if( @.status!==∅ ) ↩ @.ι }
# Promise.prototype[|>] = (ι,f)=> ι===Promise.prototype? f(ι) : ι.status? f(ι.ι) : ι.then(f) # breaks things
Promise.prototype‘.union .get=λ(){↩ @.then(ι=>ι,ι=>ι) }

Function.prototype‘.X !>(.enumerable=✗) .get=λ(){↩ ι=> @(ι) }
Function.prototype‘.XX !>(.enumerable=✗) .get=λ(){↩ (a,b)=> @(a,b) }
Function.prototype.P = λ(…a){↩ @.bind(∅,…a) }

TimerCons ← λ(a,b){@.a=a;@.b=b} ;TimerCons.prototype = { ,clear:λ(){@.a.clear();@.b.clear()} ,ref:λ(){@.a.ref();@.b.ref()} ,unref:λ(){@.a.unref();@.b.unref()} }
Function.prototype.defer = λ(){↩ setImmediate(@) }
Function.prototype.in = λ(time){↩ setTimeout(@,max(0,time||0)*1e3) }
Function.prototype.in_Π = λ(time){↩ Π((yes,no)=> setTimeout(=> Π(@()).then(yes,no),(time||0)*1e3)) }
Function.prototype.every = λ(time,opt){opt||(opt={}) ;r ← setInterval(@,max(0,time)*1e3) ;↩ !opt.leading? r : new TimerCons(@.in(0),r) }

Function.prototype‘['!'] !>(.enumerable=✗) .get=λ(){↩ (…a)=> !@(…a) }

;[Set,Map].map(Seq=>
	Object.getPrototypeOf( new Seq().entries() ) …← ({
		,map(f){↩ […@].map(f) }
		}) )
t←; Object.getPrototypeOf(( t=setImmediate(=>{}) ,clearImmediate(t) ,t )) …← ({
	,clear(){ clearImmediate(@) }
	,ref(){} ,unref(){}
	})
t←; Object.getPrototypeOf(( t=setTimeout(=>{},0) ,clearTimeout(t) ,t )) …← ({
	,clear(){ @._repeat? clearInterval(@) : clearTimeout(@) }
	})

γ.walk = (ι,f,k,o)=>( Tprim(ι)||_u(ι).forEach((ι,k,o)=> walk(ι,f,k,o)) ,ι!==∅ && ι!==null && f(ι,k,o) ,ι )
γ.walk_graph = (ι,f,seen=[])=> !( Tprim(ι) || seen.includes(ι) ) && ( seen.push(ι) ,_u(ι).forEach(ι=> walk_graph(ι,f,seen)) ,seen.pop() ,ι!==∅ && ι!==null && f(ι) ,ι )
γ.walk_both_obj = (ι,fᵃ,fᵇ,fseen,seen=[])=> fseen && seen.includes(ι)? fseen(ι) : !( Tprim(ι) || Tfun(ι) || seen.includes(ι) ) && ( fᵃ(ι) ,seen.push(ι) ,_u(ι).forEach(ι=> walk_both_obj(ι,fᵃ,fᵇ,fseen,seen)) ,seen.pop() ,fᵇ(ι) ,ι )
γ.walk_fold = (ι,f,k,o)=> Tprim(ι)? ι : Tarr(ι)? ( ι = ι.map((ι,k,o)=> walk_fold(ι,f,k,o)) ,f(ι,k,o) ) : ( ι = _u(ι).map((ι,k,o)=> [k,walk_fold(ι,f,k,o)])._.object() ,f(ι,k,o) ) # has 1 use
γ.walk_obj_edit = (ι,f)=> Tprim(ι) || Tfun(ι)? ι : Tarr(ι)? ι.map(ι=> walk_obj_edit(ι,f)) : (=>{ for (k← in ι) if( Object.prototype.hasOwnProperty.call(ι,k)) ι[k] = walk_obj_edit(ι[k],f) ;↩ f(ι) })()
γ.search_obj = (ι,f)=>{ r←[] ;walk(ι,(ι,k,o)=> ι!==∅ && ι!==null && f(ι,k,o) && r.push(ι)) ;↩ r }
γ.search_graph = (ι,f)=>{ r←[] ;walk_graph(ι,ι=> ι!==∅ && ι!==null && f(ι) && r.push(ι)) ;↩ r }
# the right name for walk is going to be along the lines of
# f /@ x       x.map(f)
# f //@ x      postwalk(x,f) # MapAll
# it could be a data structure that you can fmap over

γ.hrtime = λ(ι){ t ← arguments.length===0? process.hrtime() : process.hrtime([ι|0,(ι-(ι|0))*1e9]) ;↩ t[0] + t[1]*1e-9 }
γ.Time = λ(ι){ r ← arguments.length===0? new Date() : ι instanceof Date? ι : new Date(Tnum(ι)? ι*1e3 : ι) ;r.toString = λ(){↩ node.util.inspect(@) } ;↩ r }
Date.prototype‘.i .get=λ(){↩ +@ / 1e3}

γ.cmd_log_loc = cmd=>{
	id ← φ(cmd).name+'.'+simple_hash(cmd) ;↩ { ,id
		,out:φ`~/Library/Caches/ζ.logic/${id}.out`.ensure_dir()+''
		,err:φ`~/Library/Caches/ζ.logic/${id}.err`.ensure_dir()+''
		} }
γ.os_daemon = (cmd,opt)=>{ cmd+='' ;{once} ← opt||{}
	t ← cmd_log_loc(cmd)
	job ← {
		,[once?'RunAtLoad':'KeepAlive']:✓
		,Label:`Z.${t.id}`
		,ProgramArguments:['sh','-c',sh`export anon_tns7w=${cmd} ;PATH="/usr/local/bin:$PATH" ;${cmd}`]
		,StandardOutPath  :t.out
		,StandardErrorPath:t.err
		}
	job_path ← φ`~/Library/LaunchAgents/${job.Label}.plist` ;job_path.∃ ||( job_path.ι = job ) ;≈( job_path.plist ,job ) || ‽
	↩ { ,cmd ,job_path ,restart(){ t ← @.job_path ;shᵥ`launchctl unload ${t} &>/dev/null ;launchctl load ${t}` } } }
os_daemon‘.this .thunk==> process.env.anon_tns7w && os_daemon(process.env.anon_tns7w)

module.__proto__.if_main_do = λ(f,b){ !@.parent? f(…process.argv.slice(2)) : b&&b() }

###### metaprogramming → runtime macros built on top of template literals ######
γ.is_template0 = (ss,ιs)=> ss && Tarr(ss.raw) && ss.raw.‖-1 === ιs.‖
γ.is_template = ([ss,…ιs])=> is_template0(ss,ιs)
tmpl_flatten ← (raw2,ιs2)=> _l.zip(raw2,ιs2).….slice(0,-1).filter(ι=> ι!=='')
γ.simple_template = (ss,ιs,filter)=>{ is_template0(ss,ιs) || ‽
	if( Tarr(filter) ){ [root,join] ← filter ;filter = ι=> Tarr(ι)? ι.map(ι=> root`${ι}`).join(join) : falsy(ι)? '' : ∅ }
	filter_special ← ι=> falsy(ι)? '' : ι+''
	ι ← tmpl_flatten( ss.raw.map(.replace(/\\(?=\$\{|`)/g,'')) ,ιs.map(ι⇒{raw:ι}) )
	for(i←0;i<ι.‖-1;i++) if( Tstr(ι[i]) && !Tstr(ι[i+1])) ι[i] = ι[i].replace(/…$/,=>{ ι[i+1] = filter_special(ι[i+1].raw) ;i++ ;↩ '' })
	filter &&( ι = ι.map(ι=> Tstr(ι)? ι : or∅(filter(ι.raw),ι) ) )
	↩ ι }
γ.easy_template = (=>{
	read ← (ss,ιs)=> tmpl_flatten(ss.raw,ιs.map(ι=>[ι]))
	show ← ι=>{ raw ← [''] ;ιs ← [] ;ι.forEach(ι=> Tstr(ι)? raw[-1]+=ι : (ιs.push(ι) ,raw.push('')) ) ;↩ [{raw},…ιs] }
	↩ f=> λ(ss,…ιs){↩ f.call(@,read(ss,ιs),show) }
	})()

γ.re = (ι,…ιs)=>(
	is_template0(ι,ιs)
		? simple_template(ι,ιs,[(…a)=>re(…a).source,'']).map(ι=> !Tstr(ι)? 𐅋𐅨𐅨𐅜𐅦(ι.raw) : ι).join('')
		: 𐅋𐅨𐅨𐅜𐅦(ι)
	) |>(ι=> RegExp(ι,'u'))
𐅋𐅨𐅨𐅜𐅦 ← ι⇒
	: T.RegExp(ι)? ( ι.flags.replace(/[gy]/g,'')==='u' || ‽ ,ι.source )
	: Tarr(ι)? ι.map(𐅋𐅨𐅨𐅜𐅦).join('')
	: T.Set(ι)? `(?:${ι.map(𐅋𐅨𐅨𐅜𐅦).join('|')})`
	: (ι+'').replace(/([.*+?^${}()\[\]|\\])/g ,String.raw`\$1`)
String.prototype.re = λ(…a){↩ @.match(re(…a)) }
RegExp.prototype‘.g .get=λ(){↩ RegExp(@.source,@.flags.replace(/g/,'')+'g') }
RegExp.prototype‘.i .get=λ(){↩ RegExp(@.source,@.flags.replace(/i/,'')+'i') }
RegExp.prototype‘.m .get=λ(){↩ RegExp(@.source,@.flags.replace(/m/,'')+'m') }
RegExp.prototype‘.u .get=λ(){↩ RegExp(@.source,@.flags.replace(/u/,'')+'u') }
RegExp.prototype‘.y .get=λ(){↩ RegExp(@.source,@.flags.replace(/y/,'')+'y') }

γ.js = γ.py = (ss,…ιs)=>{ ENC ← JSON.stringify ;↩ simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι ).join('') }
γ.ζjs = (ss,…ιs)=>{ ENC ← JSON.stringify ;↩ simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ζ_compile(ι) ).join('') }
γ.ζ = (ss,…ιs)=>{ ENC ← ι=> ι===∅? '∅' : JSON.stringify(ι) ;↩ simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('') }

γ.sh = (ss,…ιs)=>{ ENC ← ι=> "'"+(ι+'').replace(/'/g,"'\\''")+"'" ;↩ simple_template(ss,ιs,[sh,' ']).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('') }

if_sh_err ← (name,code,ι)=>{ if( ι.status ) throw Error(name+'`'+code+'` → status:'+ι.status+' ,stderr:'+(ι.stderr+'').slice(0,100)) …← (_u(ι).pick('status','stdout','stderr')) !>(ι=> ι.stderr+='' ) }
γ.shᵥ = (ss,…ιs)=>{ code ← sh(ss,…ιs)
	# ι ← process_spawn('/bin/sh',{ ,args:['-c',code] ,⚓:1 })
	ι ← node.child_process.spawnSync(code,{shell:✓})
	if_sh_err('shᵥ',code,ι)
	↩ ι.stdout …← ({ toString(…a){ ι ← Buffer.prototype.toString.call(@,…a) ;↩ a.‖? ι : ι.replace(/\n$/,'') } }) }
γ.shᵥexit = (ss,...ιs)=>{ r ← catch_union(=>shᵥ(ss,…ιs)); ↩ T.Error(r)? r.status===0 : ✓ }
_shₐ ← opt=> (…ι)=>{ code ← sh(…ι)
	# ι ← process_spawn('/bin/sh',{ ,args:['-c',code] } …← (opt))
	# ι.exit.then(exit=>{ if_sh_err('shₐ',code,ι …← ({exit})) })
	ι ← node.child_process.spawn(code,{shell:✓} …← (_u(opt).pick('stdio','detached')))
		.on('exit',status=>{ if_sh_err('shₐ',code,{status} …← (ι)) })
	↩ ι }
γ.shₐ = _shₐ({})
γ.shₐin = ι=> _shₐ({stdio:[φ.fd.from(ι),'pipe','pipe',]})
γ.shₐi = _shₐ({stdio:process.stdio})
γ.shₐlone = (…ι)=> _shₐ({,detached:✓,stdio:'ignore'})(…ι) !>(.unref())

process‘.stdio .get=λ(){↩ [ @.stdin,@.stdout,@.stderr ] }
γ.♓_on_exits = f=> npm`signal-exit@3.0.2`((i,sig)=>{
	if( i===null ) i = 128+{ ,SIGHUP:1,SIGINT:2,SIGQUIT:3,SIGTRAP:5,SIGABRT:6,SIGIOT:6,SIGSYS:12,SIGALRM:14,SIGTERM:15,SIGXCPU:24,SIGXFSZ:25,SIGVTALRM:26,SIGUSR2:31 }[sig]
	f(i,sig) })
γ.♓_sub = ι=> ♓_on_exits(=>ι.kill()) # user ish?

γ.osa = (ss,…ιs)=>{t←;
	ι ← simple_template(ss,ιs)
	# ! this is such a mess
	if( Tstr(ι[0]) && (t=ι[0].re`^(?!tell )([\w ]+):`)){ ι[0] = ι[0].slice(t[0].‖) ;ι = [osa`tell app ${t[1]};` ,…ι ,' ;end tell'] }
	if( !Tstr(ι[0]) && Tstr(ι[0].raw) && ι[0].raw.re`^[\w ]+$` && Tstr(ι[1]) && (t=ι[1].re`^ *:`)){ ι[1] = ι[1].slice(t[0].‖) ;ι = [osa`tell app ${ι.shift().raw};` ,…ι ,' ;end tell'] }
	↩ ι.map(ι=> !Tstr(ι)? applescript.print(ι.raw) : ι.replace(/;/g,'\n') ).join('') }
γ.osaᵥ = (ss,…ιs)=>{ ι ← osa(ss,…ιs) ;↩ applescript.parse(shᵥ`osascript -ss -e ${ι}`+'') }
γ.osaₐ = (ss,…ιs)=>{ ι ← osa(ss,…ιs) ;shₐlone`osascript -ss -e ${ι}` }

# such hack
# YET ANOTHER Tag
json2_read ← ι=>{ r ← JSON.parse(ι) ;(λ Λ(ι,k,o){if( ι.type==='Buffer' ){
	t ← 'data' in ι || 'utf8' in ι? Buffer.from(ι.data||ι.utf8) : 'base64' in ι? Buffer.from(ι.base64,'base64') : ‽
	if( o===∅ ) r = t ;else o[k] = t
	} else if(! Tprim(ι) ) _u(ι).forEach(Λ)})(r) ;↩ r }
json2_show ← ι=> JSON_pretty(ι,(ˣ,ι)=>{t←;
	if( T.Buffer(ι)) ↩ ≈(ι,Buffer.from(t=ι+''))? { ,type:'Buffer' ,utf8:t} : { ,type:'Buffer' ,base64:ι.toString('base64') }
	↩ ι})
γ‘.φ .thunk==>{
	# https://www.npmjs.com/package/glob-to-regexp
	fs ← node.fs
	ENC ← ι=> ι.re`/`? ι.replace(/[\/%]/g ,encodeURIComponent.X) : ι
	φ.⁻¹ = ι=> /%2F/i.test(ι)? ι.replace(/%2[F5]/gi ,decodeURIComponent.X) : ι
	φ.fd = {} ;φ.fd.from = ι=> fs.createReadStream(∅,{ fd:fs.openSync(φ`/tmp/fd${🎲id.greek(20)}` …← ({ι}) +'','r') })

	existsSync ← ι=> !T.Error(catch_union(=> fs.accessSync(ι)))
	mkdir_p ← ι=>{ try{ fs.mkdirSync(ι) }catch(e){ if( e.code==='EEXIST'||e.code==='EISDIR') ↩ ;t ← node.path.dirname(ι) ;if( e.code!=='ENOENT' || ι===t) throw e ;mkdir_p(t) ;fs.mkdirSync(ι) } }
	read_file ← ι=>{ try{↩ fs.readFileSync(ι) }catch(e){ if( !(e.code==='ENOENT')) throw e } }
	ensure_exists ← (ι,ifdne)=>{ existsSync(ι) || ( mkdir_p(node.path.resolve(node.path.dirname(ι))) ,fs.writeFileSync(ι,ifdne) ) }
	write_file ← (ι,data)=>{ try{ fs.writeFileSync(ι,data) }catch(e){ if( !(e.code==='ENOENT')) throw e ;ensure_exists(ι,data) } }
	globmatch ← (glob,ι)=> ι.re`^…${[…glob].map(ι=> ι==='*'? '.*' : re`${ι}`.source).join('')}$`
	φ‘.cwd .host= { ,get:=> new Φ(process.cwd()) ,set:ι=> φ(ι+'')._ι !>(mkdir_p) !>(process.chdir) }
	normHs ← ι=>{ if( ≈( ι,['~'] ) ) ↩ [process.env.HOME] ;Tstr(ι[0]) && (ι[0] = ι[0].replace(/^~(?=\/)/,process.env.HOME)) ;↩ ι }
	λ Φ(ι){@._ι = ι} ;Φ.prototype = {
		,φ
		,toString(){↩ @._ι }
		,toJSON(){↩ {type:'φ' ,ι:@._ι} }
		,inspect(ˣ,opts){↩ opts.stylize('φ','special')+opts.stylize(util_inspect_autodepth(@._ι.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') }
		,get nlink(){↩ fs.statSync(@._ι).nlink }
		,get mtime(){↩ fs.statSync(@._ι).mtime }
		,get birthtime(){↩ fs.statSync(@._ι).birthtime }
		,get url(){↩ encodeURI('file:'+@.root('/')) } # ! should this be part of root
		,get is_dir(){↩ !!catch_ι(=> fs.statSync(@._ι).isDirectory()) }
		,get name(){↩ node.path.basename(@._ι) }
		,TMP_children(){↩ @._ι |>(λ Λ(ι){↩ φ(ι).is_dir? fs.readdirSync(ι).map(t=> ι+'/'+t).map…(Λ) : [ι] }) }
		,TMP_parents(){ r ← [@.root('/')] ;while(r[-1].φ`..`+'' !== r[-1]+'') r.push(r[-1].φ`..`) ;↩ r.slice(1) }
		,root(x){switch(arguments.length){default: 
			case 0: ↩ @._ι[0]==='/'? '/' : '.'
			case 1: ↩ new Φ( x==='/'? node.path.resolve(@._ι) : x==='.'? node.path.relative(x,@._ι) : ‽('not yet implemented: nonstandard roots') )
			}}
		,ensure_dir(){ @.φ`..`.∃ || mkdir_p(@.φ`..`+'') ;↩ @ }
		,get dir_ensure(){ @.∃ || mkdir_p(@+'') ;↩ @ }

		# ,get ι(){↩}
		,set ι(ι){
			if( @.is_dir) ‽('TODO')
			if( ι===∅||ι===null){ catch_union(=> fs.unlinkSync(@._ι) ) ;↩ }
			e ← node.path.extname(@._ι)
			if( e==='.csv'){ @.csv = ι ;↩ }
			if( e==='.xml'){ @.xml = ι ;↩ }
			if( e==='.plist'){ @.plist = ι ;↩ }
			ι = e==='.json'? JSON_pretty(ι) :
				Tstr(ι)? ι :
				ι instanceof Buffer? ι :
				JSON_pretty(ι)
			write_file(@._ι,ι) }
		,get buf(){↩ read_file(@._ι) || Buffer.alloc(0) }
		,set buf(ι){ write_file(@._ι,ι) }
		,get base64(){↩ Buffer.from(@.text,'base64') }
		# ,set base64(ι){}
		,get text(){↩ (read_file(@._ι) || '')+'' }
		,set text(ι){ write_file(@._ι,ι) }
		,get lines(){↩ λ(…ιs){
			d ← ((read_file(@._ι)||'\n')+'').replace(/\n$/,'').split('\n')
			if( ιs.‖ > 1) ↩ ιs.map(ι=> Tnum(ι)? d[ι] : d.slice(ι.re`^(\d+):$`[1]|0).join('\n')+'\n')
			else if( ιs.‖ === 0){
				↩ {
					map(…a){↩ d.map(…a)},
					} }
			else ‽('TODO')
			}}
		,set lines(ι){ write_file(@._ι, ι.join('\n')+'\n') }
		,get json(){↩ JSON.parse(read_file(@._ι) || 'null') }
		,set json(ι){ write_file(@._ι, JSON_pretty(ι)) }
		,get json2(){↩ json2_read(@.text) }
		,set json2(ι){ @.text = json2_show(ι) }
		,get ini(){↩ npm`ini@1.3.4`.parse(@.text) }
		# ,set ini(ι){}
		# ,get csv(){↩}
		,set csv(ι){ t ← φ`/tmp/csv${🎲id.greek(25)}` ;t.json = ι ;shᵥ`ζ ${'npm`csv@0.4.6`.stringify('+js`φ(${t+''}).json,(e,ι)=>{ φ(${@.root('/')+''}).buf = ι })`}` }
		# ,get xml(){↩ JSON.parse(shᵥ`ζ ${js`npm`xml2js@0.4.17`.parseString(φ(${@+''}).text,λ(e,ι){ process.stdout.write(JSON.stringify(ι)) })`}`+'') }
		,set xml(ι){ @.text = npm`xmlbuilder@8.2.2`.create(ι,{allowSurrogateChars:✓}).end({pretty:✓}) }
		,get plist(){t←; buf ← @.buf ;↩ 0?0
			# in case bplist-parser has bugs, this is available:
			# : which('plutil')? npm`plist@2.1.0`.parse(shᵥ`plutil -convert xml1 -o - ${@.root('/')+''}`+'')
			: buf.slice(0,6)+''==='bplist'? ( t= φ`/tmp/plist${🎲id.greek(25)}`, shᵥ`ζ ${'npm`bplist-parser@0.1.1`.parseFile('+js`${@.root('/')+''},(e,ι)=>{ φ(${t+''}).plist = ι })`}`, t.plist )
			: npm`plist@2.1.0`.parse(@.text)
			}
		,set plist(ι){ @.text = npm`plist@2.1.0`.build(ι) }
		,get size(){↩ fs.statSync(@._ι).size }
		,get ['‖'](){↩ fs.statSync(@._ι).size }
		}
	Φ.prototype‘['∃'] …←({ ,get(){↩ existsSync(@._ι) } ,set(ι){ ι===@.∃ ||( @.ι = ι?'':∅ ) } })
	λ Φs(ι){@._ι = ι} ;Φs.prototype = {
		,inspect(ˣ,opts){↩ opts.stylize('φ','special')+node.util.inspect(@._ι,opts)}
		,get name_TMP(){↩ @._ι.map(ι=> new Φ(ι).name)} # fs.readdirSync
		,get φs(){↩ @._ι.map(ι=> new Φ(ι))} # [φ]
		}
	λ φ(ss,…ιs){
		head ← @ instanceof Φ && @._ι
		if( @ instanceof Φs ) ‽('not yet implemented')
		tmpl ← is_template0(ss,ιs)
		if( tmpl){ι ← simple_template(ss,ιs,[φ,'/']) ;if( ι.filter(Tstr).join('').re`\*|\{[^}]*?,` ) {
			ι.‖ <= 1 || ‽('not yet implemented * ** ${}',ι)
			ι = normHs(ι)
			ι = ι[0]
			ι.includes('**') && ‽('not yet implemented ** ${}',ι)
			r ← ['.']
			if( ι[0]==='/' ) r = ['/']
			ι.split('/').forEach(ι=>{
				if( ι==='' )↩;
				r = r.map…(r=>{
					if( ι === '.' ) ↩ [r]
					if( ι === '..' ) ↩ [r==='.'? '..' : r.split('/').every(ι=>ι==='..')? r+'/..' : node.path.dirname(r)]
					↩ fs.readdirSync(r).filter(b=> globmatch(ι,b)).map(b=> r+'/'+b)
					})
				})
			↩ new Φs(r) } }
		else {ι ← ss ;if( ιs.‖ || Tarr(ι)) ‽('not yet implemented') ;if( ι instanceof Φs ) ‽('not yet implemented')}
		if( tmpl ){ι = normHs(ι).map(ι=> !Tstr(ι)? ENC(ι.raw+'') : ι).join('')}
		else if( ι instanceof Φ ){↩ head && ι._ι[0]!=='/'? new Φ(head+'/'+ι._ι) : ι}
		else {ι = (ι+'').replace(/^~(?=\/|$)/,process.env.HOME)}
		↩ new Φ(node.path.normalize(head? head+'/'+ι : ι).replace(/(?!^)\/$/,'')) }
	↩ φ }

############################## api interpretation ##############################
comp2 ← ι=> `'use strict';undefined;\n`+ζ_compile(ι)
mem_sc ← memoize_tick(ι=> new node.vm.Script(ι) )
ζ_verify_syntax ← ι=>{ ι = comp2(ι) ;try{ mem_sc(ι) }catch(e){ if( e instanceof SyntaxError ) ↩ e } }
γ.ζ_eval = ι=>{ ι = comp2(ι) ;↩ mem_sc.cache[ι]? mem_sc(ι).runInThisContext() : (0,eval)(ι) }

γ.returnfix_compile = (=>{↩ ι=>{t←; ↩ bad(ι) && !bad(t='(=>{'+ι+'})()')? t : ι }
	λ bad(ι){t←; ↩ (t= ζ_verify_syntax(ι)) && t.message==='Illegal return statement' }
	})()
γ.do_end_undefined_thing = .replace(/;\s*$/,';∅')

# i cut this out temporarily:
# e && Tstr(e.stack) &&( e.stack = e.stack.replace(/^([^]*)at repl:(.*)[^]*?$/,'$1at <repl:$2>') )
# e && Tstr(e.stack) &&( e.stack = e.stack.replace(/    at 𐅩𐅝𐅋𐅬𐅪[^]*/,'    at <eval>') )

###################################### see #####################################
;(…←)(node.util.inspect.styles,{ ,null:'grey' ,quote:'bold' })
;[process,module].map(.inspect = λ(){↩ '{'+Object.getOwnPropertyNames(@).map(ι=> ι+':').join(', ')+'}' }) # ‡ hack, like the [1] * 5 thing in ζ_repl_start. clean up by: can we override builtin inspects without problems? then: defining solid inspect functions for more things. otherwise: figure out something else.
;['γ','Object'].map(ι=>{
γ[ι].inspect = (d,opt)=> opt.stylize(ι,'quote')
})

𐅋𐅃 ← λ(a,b){ t ← @.__local? npm`moment@2.18.1`(@).format('YYYY-MM-DD[T]HH:mm:ss.SSS') : @.toISOString() ;t = t.slice(a,b) ;if( !@.__local && b > 10) t += 'Z' ;↩ t }
Date.prototype‘.local .get=λ(){↩ new Date(@) …← ({__local:✓})}
Date.prototype‘.y       .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY'.‖)}
Date.prototype‘.ym      .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM'.‖)}
Date.prototype‘.ymd     .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM-DD'.‖)}
Date.prototype‘.ymdh    .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM-DDTHH'.‖)}
Date.prototype‘.ymdhm   .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM-DDTHH:mm'.‖)}
Date.prototype‘.ymdhm   .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM-DDTHH:mm'.‖)}
Date.prototype‘.ymdhms  .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM-DDTHH:mm:ss'.‖)}
Date.prototype‘.ymdhmss .get=λ(){↩ 𐅋𐅃.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.‖)}
Date.prototype‘.mdhm    .get=λ(){↩ 𐅋𐅃.call(@,'YYYY'.‖,'YYYY-MM-DDTHH:mm'.‖)}
Date.prototype‘.hms     .get=λ(){↩ 𐅋𐅃.call(@,'YYYY-MM-DDT'.‖,'YYYY-MM-DDTHH:mm:ss'.‖)}
Date.prototype‘.day .get=λ(){↩ @.i/86400 }
Date.prototype‘.day_s .get=λ(){↩ (@.day+'').replace(/^(.*\..{4}).*/,'$1') }
Date.prototype‘.day_s3 .get=λ(){↩ (@.day+'').replace(/^(.*\..{3}).*/,'$1') }

γ.Unit = (ι,u)⇒ {ι,u}
	!>( ‘.valueOf !>(.enumerable= ✗) .ι=λ(){↩ @.ι } )
	!>( ‘.inspect !>(.enumerable= ✗) .ι=λ(ˣ,opt){↩ node.util.inspect(@.ι,opt)+' '+opt.stylize(@.u,'number') } )
Number.prototype.inspect = λ(d,opt){'use strict' ;ι ← @ ;if(! Tprim(ι) ) ↩ ι ;↩ ζ_inspect(ι,opt) }
Boolean.prototype.inspect = λ(d,opt){'use strict' ;ι ← @ ;if(! Tprim(ι) ) ↩ ι ;↩ ζ_inspect(ι,opt) }
Date.prototype.inspect = λ(d,opt){↩ opt.stylize(isNaN(+@)? 'Invalid Date' : @.getUTCSeconds()!==0? @.ymdhms : @.getUTCMinutes()!==0? @.ymdhm : @.getUTCHours()!==0? @.ymdh : @.ymd, 'date')}
# ,'Function.prototype.inspect':λ(rec,ctx){t ← ζ_compile.⁻¹(@+'').replace(/^λ \(/,'λ(').match(/^.*?\)/) ;↩ ctx.stylize('['+(t?t[0]:'λ ?(?)')+']', 'special')}
# ,'Buffer.prototype.inspect':λ Λ(){↩ Λ.super.call(@).replace(/(^<\w+)/,'$1['+@.‖+']')}
# ,inspect(ˣ,opt){↩ opt.stylize('φ','special')+opt.stylize(node.util.inspect(@._ι.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') }
Array.prototype‘.line .get=λ(){ @.toString = @.inspect = λ(){↩ @.join('\n') } ;↩ @ }
γ.util_inspect_autodepth = (ι,opt={})=>{ opt.L || (opt.L = 1e7) ;last←; for(i←1;;i++){ r ← node.util.inspect(ι,{ ,maxArrayLength:opt.L/3 |0 ,depth:i } …← (opt)) ;if( r===last || r.‖ > opt.L) ↩ last===∅? '<too large>' : last ;last = r } }
𐅯𐅦 ← (ι,opt={})=> util_inspect_autodepth(ι,_u(opt).pick('colors','L'))
promise_watch ← ι=>{ if(! ι.id ){
	ι.id = (𐅩𐅞𐅋𐅦𐅩++).toString(36)
	hr ← hrtime() ;ι.then(x=>{ x ← ζ_inspect(x) ;hrtime(hr) < 5 && x.‖ && hsᵥ`hs.alert(${`Promise #${ι.id} = ${x.slice(0,200)}`},12)` }) } ;↩ ι.id } ;𐅩𐅞𐅋𐅦𐅩←0
stylize ← ({colors})=>{ node.util.inspect({inspect(d,opt){ r = opt.stylize }},{colors}) ;r← ;↩ r }
γ.ζ_inspect = (ι,opt={})⇒
	: ι===∅? ''
	: T.✓✗(ι)? stylize(opt)(ι?'✓':'✗' ,'boolean')
	: Tstr(ι)? ι
	: Tnum(ι)? stylize(opt)(0?0
		: Object.is(ι,-0)? '-0' : ι===∞? '∞' : ι===-∞? '-∞'
		: Number.isSafeInteger(ι)? ''+ι
		: ι.toExponential().replace('+','').replace(/(\.\d\d)\d+/,'$1').replace('e0','')
		,'number')
	: T.Promise(ι)? 0?0
		: ι.status? 'Π '+𐅯𐅦(ι.ι,opt)
		: ι.status===∅? `Π #${promise_watch(ι)} #pending`
		: 𐅯𐅦(ι,opt)
	: Tarr(ι) && ι.‖ > 1 && ι.every(t=> t===ι[0]) && ⋯(ι.‖).every(t=> t in ι)
		? 𐅯𐅦([ι[0]],opt)+' × '+𐅯𐅦(ι.‖,opt)
	: 𐅯𐅦(ι,opt)
# node.EventEmitter.prototype.inspect
sh_inspect ← ι=>{t←;
	Π ← ι=> Promise.resolve(ι) # COPY
	↩ Π( 0?0
	: T.Promise(ι)? ι.then(sh_inspect)
	: ι===∅? {}
	: Tstr(ι)? {out:ι}
	: T.✓✗(ι)? {code:ι?0:1}
	: ( t= catch_union(=> JSON.stringify(ι)) ,!T.Error(t) )? {out:t}
	: {out:ι+''} )}

is_browser ← ( γ.process&&process.type==='renderer' ) || !( γ.process&&process.versions&&process.versions.node )
γ.single_if = ι=> ι.‖===1? ι[0] : ι
γ.log = (…ι)=>( log.ι(ι) ,ι[-1] )
log.ι = is_browser? ι=> console.log(…ι)
	: single_if ≫ (ι=> process.stdout.write(ζ_inspect(ι,{ colors:process.stdout.isTTY })+'\n'))
γ.log2 = (…ι)=> log( ,Time().day_s |>(t⇒{inspect:=>t}) ,…ι ) # log2rue

γ.JSON_pretty = (ι,replacer)=>{
	seen ← []
	tab ← '  '
	wrap_width ← 140
	indent_show ← ι=> show(ι).replace(/\n/g,'\n'+tab)
	show ← ι=>{t←;
		if( ι===∅||ι===null ) ↩ 'null'
		replacer && (ι = replacer(∅,ι))
		while( ι.toJSON ) ι = ι.toJSON()
		switch( typeof(ι)==='object'? Object.prototype.toString.call(ι) : typeof(ι) ){
			case 'string': case '[object String]': ↩ JSON.stringify(ι)
			case 'boolean': case '[object Boolean]': case 'number': case '[object Number]': ↩ ι+''
			case 'function': ↩ 'null'
			default:
				!seen.includes(ι) || ‽(TypeError('Converting circular structure to JSON'))
				seen.push(ι)
				if( Tarr(ι)) { [a,b] ← '[]' ;ι = ι.map(indent_show) ;for (i←0;i<ι.‖;i++) ι[i]===∅ && (ι[i] = 'null') }
				else { [a,b] ← '{}' ;ι = _l.toPairs(ι).filter(ι=> !(ι[1]===∅ || Tfun(ι[1]))).map(ι=> show(ι[0])+': '+indent_show(ι[1])) }
				seen.pop()
				↩ (t=a+ι.join(', ')+b).‖ <= wrap_width? t : a+'\n'+tab+ι.join(',\n'+tab)+'\n'+b
				} }
	↩ show(ι) }

process.on('unhandledRejection',(e,p)=> log(Time(),'process.unhandledRejection',p) )

################# repl #################
ζ_repl_start ← =>{
	# i know how to make the good repl for ct. i want to, but im tired
	diesis_compile ← ι=>{t←;
		# of course this is lovely but it is a dead end - we want Sight
		lock ← 0?0
			: ['ct','chrome_tabs','ps2','d','bookmarks'].∪([]).has(ι)? ι+'()'
			: (t= ι.re`^f(?: (.+))?$` )? js`go_to('path',${t[1]||'.'})`
			: ι
		lock===ι || log('⛓  '+lock)
		↩ lock }
	# @2018-01-04 current priority is to work on seeing first; merging w ζ_repl_start
	# '\x1b[30m\x1b[42mζ\x1b[0m '
	↩ (f=> f.call( node.repl.start({ ,useGlobal:✓ ,prompt:'\x1b[30m\x1b[100m‡\x1b[0m ' }) ))(λ(){
	@.In = [] ;@.Out = []
	super_ ← @.completer ;@.completer = λ(line,cb){ line.trim()===''? cb(∅,[]) : super_.call(@,line,cb) }
	@.removeAllListeners('line').on('line',λ(line){
		@.context.rl = @
		@.context.E = @.context # ! what?
		if( @.bufferedCommand ){ ι ← @.history ;ι.reverse() ;t ← ι.pop() ;ι[-1] += '\n'+t ;ι.reverse() }
		code ← @.bufferedCommand+line
		code = diesis_compile(code)
		if( ζ_verify_syntax(code) ){ @.bufferedCommand = code+'\n' ;@.outputStream.write('    ') ;↩ }
		try{ ι ← (0,eval)(ζ_compile(code)) }catch(e){ error ← e }
		@.bufferedCommand = ''
		if( code ){
			φ`~/.archive_ζ`.text = φ`~/.archive_ζ`.text + JSON.stringify({ ,time:Time() ,code }) + '\n'
			@.In.push(code) ;@.Out.push(error || ι)
			}
		if( error ) @._domain.emit('error' ,error.err || error)
		else{
			if( T.Promise(ι) ) @.context‘.__ .f1ι= ι
			else if( ι!==∅ ) @.context.__ = ι
			try{ t ← ζ_inspect(ι,{ colors:@.outputStream.isTTY }) }catch(e){ t ← '<repl inspect failed>:\n'+(e&&e.stack) }
			@.outputStream.write(t && t+'\n') }
		@.displayPrompt()
		})
	@.removeAllListeners('SIGINT').on('SIGINT',λ(){
		is_line ← @.bufferedCommand+@.line
		@.clearLine()
		if( is_line ){ @.bufferedCommand = '' ;@.displayPrompt() } else @.close()
		})
	delete @.context._ ;@.context._ = _u
	↩ @ }) }

################################### new tools ##################################
γ.simple_as_file = ι=> φ`/tmp/asf_${simple_hash(ι)}` …←({ι}) +''

##################################### user #####################################
process.env.PATH = [,'./node_modules/.bin','/usr/local/bin',…(process.env.PATH||'').split(':'),'.'].∪([]).join(':')

γ.🎵 = ι=> shₐlone`afplay ${ι}`
γ.🎵d = ι=> net1._0_φ_seenbydevice0(`https://www.dropbox.com/s/${ι}?dl=1`).then(ι=>🎵(ι.o))
γ‘.nacksoft .get==> 🎵d`kaphh65p0obaq93/nacksoft.wav`

#################################### prelude ###################################
require(φ`~/code/scratch/ζ/module.ζ`+'').put_γ()

################################## deprecated ##################################
𐅭𐅂𐅭𐅪 ← (names,within,f)=>{
	dir ← φ`~/file/.cache/memo_frp/${names}`
	if( within ){
		try{ t ← node.fs.readdirSync(dir+'') }catch(e){ e.code==='ENOENT' || ‽(e) ;t ← [] }
		now ← Time().i ;t = t.sort().filter(ι=> Time(ι.re`^\S+`[0]).i >= now - within )[-1]
		if( t ) ↩ dir.φ(t).json2.ι }
	a ← Time().ymdhmss ;ι ← f() ;b ← Time().ymdhmss
	dir.φ`${a} ${🎲id(10)}`.json2 = { ,names ,date:[a,b] ,ι } ;↩ ι }
γ.GET_L = (ι,within)=> 𐅭𐅂𐅭𐅪(['GET -L' ,ι+''] ,within ,=> shᵥ`curl -sL ${ι}`)
# ! some requests have short responses ;will need more intelligent caching for those 'cause the filesystem can't take too much
# ! curl error code 6 means can't resolve & is crashing things maybe

##################################### main #####################################
γ …←| ({ ,require ,module:{ ,exports:{} ,if_main_do:module.__proto__.if_main_do } ,i:0 })
γ.ζ_main = ({a})=>{ι←;
	a[0]==='--fresh' && a.shift()
	if( !a.‖ ) ζ_repl_start()
	else if( ι=a[0] ,φ(ι).∃ || ι.re`^\.?/` ){ process.argv = [process.argv[0],…a] ;t ← φ(ι).root('/')+'' ;o←node.Module._cache;m←node.Module._resolveFilename(t,∅,✓);oι←o[m] ;o[m] = ∅ ;node.Module._load(t,∅,✓) ;o[m] = oι }
	else {
		γ.a = a ;code ← a.shift() ;[γ.a0,γ.a1] = a ;γ.ι = a[0]
		sh_inspect( ζ_eval(returnfix_compile(do_end_undefined_thing(code))) )
			.then(ι=>{ ι.out && process.stdout.write(ι.out) ;ι.code &&( process.exitCode = ι.code ) })
		}
	}
module.if_main_do((…a)=>ζ_main({a}))
