// _ â† require('underscore')

// this would be so fun to optimize
// ok, i grok this now, & i see how i'd need to do various things b4 it's optimizeable. let's do this! later. yay grokking parser combinators :)

// well, first i'd need a js parser

_ins â† (name,f,m)=> Î»(â€¦a){â†© _(f.call(@,â€¦a)).assign({inspect:(d,opt)=> (!m? '' : util.inspect(@,opt)+'.')+name+'('+util.inspect(a,opt).slice(1,-1)+')' }) }
inspectify â† (â€¦a)=> _ins(â€¦a,false)
inspectify_m â† (â€¦a)=> _ins(â€¦a,true)

// ---------------------------------- core ---------------------------------- //

// issue: makes parser not reentrant, as perf optimization
G_opt â† {fast:null}

P â† (Î¹,â€¦Î¹s)=>
  Î¹ instanceof Parser? Î¹ :
  is_template([Î¹,â€¦Î¹s])? (()=>{
    Î¹ = easy_template(Î¹=>Î¹)(Î¹,â€¦Î¹s)
    i â† Î¹.map((Î¹,i)=>[Î¹,i]).filter(([Î¹,i])=>Tarr(Î¹)).map(([Î¹,i])=>i)
    â†© P(Î¹.map(Î¹=> Tarr(Î¹)?Î¹[0]:Î¹)).map(Î¹=> i.length===1? Î¹[i[0]] : i.map(i=> Î¹[i]) )
    })() :
  Tfun(Î¹)? p_wrap(Î»(stream,i){â†© (@._ = Î¹()._)(stream,i) }) :
  Tstr(Î¹)? p_wrap((stream,i)=>{ head â† stream.slice(i,i+Î¹.length); â†© head===Î¹? make_win(i+Î¹.length,head) : make_lose(i,Î¹) }) :
  Tarr(Î¹)? P.seq(â€¦Î¹) :
  T.RegExp(Î¹)? (()=>{ group â† Î¹s[0]||0
    re â† RegExp(Î¹.source,Î¹.flags.replace(/[^imu]/g,'')+'y'); re_s â† Î¹+''
    â†© p_wrap((stream,i)=>{ t â† re.exec_at(stream,i); â†© t && !(t[group]===null||t[group]===undefined)? make_win(i+t[0].length, t[group]) : make_lose(i,re_s) }) })() :
    â€½('cant make parser from',Î¹)
p_wrap â† Î¹=> new Parser(Î¹)
Parser â† Î»(f){ @._ = f }
P.proto = Parser.prototype

P.proto.parse = Î»(stream){ Tstr(stream) || â€½
  G_opt.fast = true; r â† @.skip(eof)._(stream,0)
  if (!r.status){ G_opt.fast = false; r â† @.skip(eof)._(stream,0); !!r.status && â€½; â€½({ index:make_line_col_index(stream, r.furthest), expected:r.expected, stream:stream.slice(0,1e3), }) }
  â†© r.value }

// make_win â† (index,value)â‡’ { status:true, index, value, }
make_win â† (index,value)â‡’ { status:true, index, value, furthest:-1, expected:[], }
make_lose â† (index,expected)â‡’ { status:false, index:-1, value:null, furthest:index, expected:[expected], }

P.seq = inspectify('P.seq', (â€¦ps)=>{ ps = ps.map(P.X)
  â†© p_wrap((stream,i)=>{râ†;
    accum â† []
    for (jâ†0;j<ps.length;j++){pâ†ps[j];  r = merge_replies(p._(stream,i), r); if (!r.status) â†© r; accum.push(r.value); i = r.index  }
    â†© merge_replies(make_win(i,accum), r) }) })

alt â† P.alt = (â€¦ps)=>{ ps = ps.map(P.X)
  if (!ps.length) â†© fail('zero alternates')
  â†© p_wrap((stream,i)=>{râ†;
    for (jâ†0;j<ps.length;j++){pâ†ps[j];  r = merge_replies(p._(stream,i), r); if (r.status) â†© r  }
    â†© r }) }

P.proto.many = Î»(){â†© @.times(0,âˆ) }
P.proto.times = Î»(min,max){
  if (arguments.length < 2) max = min
  Tnum(min) || â€½; Tnum(max) || â€½

  â†© p_wrap((stream,i)=>{
    accum â† []
    râ†;
    prev_râ†;

    for (times â† 0; times < min; times += 1){
      r = @._(stream,i)
      prev_r = merge_replies(r,prev_r)
      if (r.status){ i = r.index; accum.push(r.value) }
      else â†© prev_r
      }
    for (; times < max; times += 1){
      r = @._(stream,i)
      prev_r = merge_replies(r,prev_r)
      if (r.status){ i = r.index; accum.push(r.value) }
      else break
      }
    â†© merge_replies(make_win(i,accum), prev_r)
  })
}

P.proto.map    = inspectify_m('map', Î»(f){ Tfun(f) || â€½; â†© p_wrap((stream,i)=>{ r â† @._(stream,i); if (r.status) r.value = f(r.value); â†© r }) })
P.proto.map_js = Î»(f){ Tfun(f) || â€½; â†© p_wrap((stream,i)=>{ r â† @._(stream,i); if (r.status) r.value = f(r.value,[i,r.index],stream); â†© r }) }
P.proto.skip = Î»(next){â†© P([@,next]).map(Î¹=> Î¹[0]) }

eof â† P.eof = p_wrap((stream,i)=> i < stream.length? make_lose(i,'EOF') : make_win(i,null) )

P.proto.chain = Î»(f){â†© p_wrap((stream,i)=>{ r â† @._(stream,i); â†© !r.status? r : merge_replies(f(r.value)._(stream,r.index), r) }) }

// -------------------------- extra (mostly unused) ------------------------- //

merge_replies â† (r,last)=>{
  if (G_opt.fast) â†© r
  if (!last) â†© r
  if (r.furthest > last.furthest) â†© r
  expected â† r.furthest===last.furthest? unsafe_union(r.expected, last.expected) : last.expected
  â†© { status:r.status, index:r.index, value:r.value, furthest:last.furthest, expected, } }

// Returns the sorted set union of two arrays of strings. Note that if both arrays are empty, it simply returns the first array, and if exactly one array is empty, it returns the other one unsorted. This is safe because expectation arrays always start as [] or [x], so as long as we merge with this function, we know they stay in sorted order.
unsafe_union â† (xs,ys)=>{
  xL â† xs.length
  yL â† ys.length
  if (xL===0) â†© ys; else if (yL===0) â†© xs
  r â† {}
  for (i â† 0; i < xL; i++) r[xs[i]] = true
  for (i â† 0; i < yL; i++) r[ys[i]] = true
  â†© _.keys(r).sort() }

P.format_error = (stream,error)=>{
  t â† error.expected; ex â† t.length===1? t[0] : 'one of '+t.join(', ')
  index â† error.index; i â† index.offset
  prefix â† (i > 0 ? "'..." : "'")
  suffix â† (stream.length - i > 12 ? "...'" : "'")
  if (i===stream.length) â†© ', got the end of the stream'
  â†© 'expected '+ex+' at line ' + index.line + ' column ' + index.column +  ', got ' + prefix + stream.slice(i,i+12) + suffix }

seq_map â† P.seq_map = (â€¦a)=>{ f â† a[-1]; a = a.slice(0,-1); Tfun(f) || â€½; â†© P(a).map(Î¹=> f(â€¦Î¹)) }

// Allows to add custom primitive parsers
P.custom = f=> p_wrap(f(make_win,make_lose))

P.sep_by = (p,sep)=> P.sep_by1(p,sep).or(P.of([]))
P.sep_by1 = (p,sep)=>{ p = P(p); sep = P(sep)
  pairs â† sep.then(p).many()
  â†© p.chain(r=> pairs.map(rs=> [r].concat(rs) ) ) }

P.proto.or = Î»(p){â†© alt(@,p) }
P.proto.then = Î»(next){ next = P(next); â†© P([@,next]).map(Î¹=> Î¹[1]) }

P.proto.result = Î»(Î¹){â†© @.map(()=> Î¹) }
P.proto.at_most = Î»(n){â†© @.times(0,n) }
P.proto.at_least = Î»(n){â†© seq_map(@.times(n), @.many(), (init,r)=> init.concat(r) ) }
P.proto.mark = Î»(){â†© seq_map(index,@,index,(start,value,end)â‡’ { start, value, end } ) }
P.proto.desc = Î»(expected){â†© p_wrap((stream,i)=>{ r â† @._(stream,i); if (!r.status) r.expected = [expected]; â†© r }) }

P.of = Î¹=> p_wrap((stream,i)=> make_win(i,Î¹) )
fail â† P.fail = expected=> p_wrap((stream,i)=> make_lose(i,expected) )
P.any = p_wrap((stream,i)=> i >= stream.length? make_lose(i,'any character') : make_win(i+1, stream[i]) )
P.all = p_wrap((stream,i)=> make_win(stream.length, stream.slice(i)) )

test â† P.test = test=>( Tfun(test) || â€½,
  p_wrap((stream,i)=> i < stream.length && test(stream[i])? make_win(i+1,stream[i]) : make_lose(i,'a character matching '+test) )
  )
P.one_of = s=> test(ch=> s.indexOf(ch) >= 0 )
P.none_of = s=> test(ch=> s.indexOf(ch) < 0 )
P.take_while = test=>( Tfun(test) || â€½,
  p_wrap((stream,i)=>{ j â† i; while (j < stream.length && test(stream[j])) j++; â†© make_win(j,stream.slice(i,j)) })
  )

make_line_col_index â† (stream,i)=>{ lines â† stream.slice(0,i).split('\n'); â†© { offset:i, line:lines.length, column:lines[-1].length+1, } }

index â† P.index = p_wrap((stream,i)=> make_win(i,make_line_col_index(stream,i)) )

// ---------------------------------- final --------------------------------- //

Pretty_Typed â† Î»(T,Î¹){ @.T = T; @.Î¹ = Î¹ }; Pretty_Typed.prototype.inspect = Î»(d,opt){â†© @.T+':'+util.inspect(@.Î¹,opt) }
P.T = (T,Î¹)=> new Pretty_Typed(T,Î¹)
P.proto.T = inspectify_m('T',Î»(ss,â€¦Î¹s){â†© @.map(Î¹=> P.T(ss[0],Î¹) ) })

// deprecated
P.proto.type = Î»(T){â†© _(@.map(Î¹=> new Pretty_Typed(T,Î¹) )).assign({inspect:(d,opt)=> util.inspect(@,opt)+'.T`'+T+'`' }) }

typeof module !== 'undefined' && ( module.exports = P )

Î¶_parse â† (Î»(){
  word_extra â† re`â™ˆ-â™“ğŸ”…ğŸ”†`.source; word_extra_gu â† re`[â€¦${word_extra}]`.g
  word â† re`A-Za-z0-9_$Ê°-Ê¸Ë¡-Ë£Î‘-Î¡Î£-Ï‰á´¬-áµ›áµ¢-áµ¥á¶œá¶ á¶»â°â±â¿â‚-â‚“â‚•-â‚œâ„‚â„•â„šâ„â„¤â±¼â±½â€¦${word_extra}`.source
  ident â† P(re`(?![0-9])[â€¦${word}]+|@`)
  comment â† re`(//.*|/\*[^]*?(\*/|$))+`
  simple_js â† P(()=> P.alt(
    P(comment).type('comment'),
    P.seq( P('{'), simple_js, P('}') ),
    P.seq( P.alt(
      P(/(['"])(((?!\1)[^\\]|\\.)*?\1)/).type('string'),
      ident,
      P.seq( P('`').type('template'), tmpl_Î¹.many(), P('`').type('template') ),
      P(/[)\]0-9]/)
      ), P.alt( P(re`[ \t]*(?!â€¦${comment.source})/`), P.of('') ) ),
    P(re`/((?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/([a-z]*)`).type('regex'),
    P(re`[^{}/'"â€¦${'`'})@\]â€¦${word}]+|[^}]`)
    ).many() )
  tmpl_Î¹ â† P.alt( P.seq( P('${').type('template'), simple_js, P('}').type('template') ), P(/\\[^]|(?!`|\$\{)[^]/).type('template') )
  js_file â† P.seq( P(/(#!.*\n)?/).type('shebang'), simple_js )
  â†© code=>{
    Î¹ â† js_file.parse(code)._.flatten()
    r â† []; for(var t of Î¹) t.T? r.push(t) : r[-1]&&r[-1].T? r.push(t) : (r[-1]+=t)
    â†© r } })()
test â† ()=>{
  cn.log('test parsimmon')
  test â† ()=> Î¶_parse(in_); in_ â† Ï†`~/code/scratch/Î¶/index.Î¶`.text
  // pass â† JSON.stringify(test())===Ï†`/tmp/aaaa`.text
  // cn.log(pass?'pass âœ“':'fail X')
  cn.log('perf',bench(test,{TH:3}))
  }
if (!module.parent) test()
