//X // this would be so fun to optimize
//X // ok, i grok this now, & i see how i'd need to do various things b4 it's optimizeable. let's do this! later. yay grokking parser combinators :)
//X // well, first i'd need a js parser

// __lazy â† Î¹=> P2({ type:'lazy', Î¹, _(stream,i){ â†© @.Î¹._(stream,i) }, })
__lazy â† Î¹=> P2({
	type:'lazy',
	Î¹,
	_(stream,i){ t â† @.Î¹(); delete @.type; delete @.Î¹; delete @._; _(@) <- (t); â†© @._(stream,i) },
	})
__match_string â† Î¹=> P2({
	type:'match_string',
	Î¹,
	_(stream,i){ head â† stream.slice(i,i+@.Î¹.â€–); â†© head===@.Î¹? make_win(i+@.Î¹.â€–,head) : make_lose(i,@.Î¹) },
	})
__match â† (Î¹,group)=> P2({
	type:'match',
	re: RegExp(Î¹.source,Î¹.flags.replace(/[^imu]/g,'')+'y'),
	group,
	_(stream,i){ t â† @.re.exec_at(stream,i); â†© t && !(t[@.group]===null||t[@.group]===undefined)? make_win(i+t[0].â€–, t[@.group]) : make_lose(i,@.re+'') },
	})
__seq â† ps=> P2({
	type:'seq',
	ps,
	_(stream,i){râ†;
		accum â† []
		for (jâ†0;j<@.ps.â€–;j++){pâ†@.ps[j];  r = merge_replies(p._(stream,i), r); if (!r.status) â†© r; accum.push(r.value); i = r.index  }
		â†© merge_replies(make_win(i,accum), r) },
	})
__alt â† ps=> P2({
	type:'alt',
	ps,
	_(stream,i){râ†;
		for (jâ†0;j<@.ps.â€–;j++){pâ†@.ps[j];  r = merge_replies(p._(stream,i), r); if (r.status) â†© r  }
		â†© r },
	})
__times â† (p,min,max)=> P2({
	type:'times',
	p,
	min,
	max,
		_(stream,i){
		accum â† []
		râ†;
		prev_râ†;

		for (times â† 0; times < @.min; times += 1){
			r = @.p._(stream,i)
			prev_r = merge_replies(r,prev_r)
			if (r.status){ i = r.index; accum.push(r.value) }
			else â†© prev_r
			}
		for (; times < @.max; times += 1){
			r = @.p._(stream,i)
			prev_r = merge_replies(r,prev_r)
			if (r.status){ i = r.index; accum.push(r.value) }
			else break
			}
		â†© merge_replies(make_win(i,accum), prev_r)
		},
	})
__map    â† (p,f)=> P2({ type:'map', p, f, _(stream,i){ r â† @.p._(stream,i); if (r.status) r.value = @.f(r.value); â†© r }, })
__map_js â† (p,f)=> P2({ type:'map_js', p, f, _(stream,i){ r â† @.p._(stream,i); if (r.status) r.value = @.f(r.value,[i,r.index],stream); â†© r }, })
__chain â† (p,f)=> P2({ type:'chain', p, f, _(stream,i){ r â† @.p._(stream,i); â†© !r.status? r : merge_replies(@.f(r.value)._(stream,r.index), r) }, })
__of â† Î¹=> P2({ type:'of', Î¹, _(stream,i){â†© make_win(i,@.Î¹) }, })
__fail â† expected=> P2({ type:'fail', expected, _(stream,i){â†© make_lose(i,@.expected) }, })
__eof â† ()=> P2({ type:'eof', _(stream,i){â†© i < stream.â€–? make_lose(i,'EOF') : make_win(i,null) }, })
__index â† ()=> P2({ type:'index', _(stream,i){â†© make_win(i,make_line_col_index(stream,i)) }, })

// issue: makes parser not reentrant, as perf optimization
G_opt â† {fast:null}

P â† (Î¹,â€¦Î¹s)â‡’
	: Î¹ instanceof Parser? Î¹
	: is_template([Î¹,â€¦Î¹s])? (()=>{
		Î¹ = easy_template(Î¹=>Î¹)(Î¹,â€¦Î¹s)
		i â† Î¹.map((Î¹,i)=>[Î¹,i]).filter(([Î¹,i])=>Tarr(Î¹)).map(([Î¹,i])=>i)
		â†© P(Î¹.map(Î¹=> Tarr(Î¹)?Î¹[0]:Î¹)).map(Î¹=> i.â€–===1? Î¹[i[0]] : i.map(i=> Î¹[i]) )
		})()
	: Tfun(Î¹)? __lazy(Î¹)
	: Tstr(Î¹)? __match_string(Î¹)
	: Tarr(Î¹)? P.seq(â€¦Î¹)
	: T.RegExp(Î¹)? __match(Î¹,Î¹s[0]||0)
	: â€½('cant make parser from',Î¹)
P2 â† Î¹=> new Parser(Î¹)
Parser â† Î»(a){ _(@) <- (a) }

// resolve â† p=>{
// 	t â† search_graph(p,Î¹=> Î¹ instanceof Parser)
// 	â†© t.map(Î¹=> _(Î¹).omit('_','ps','p'))
// 	}

// Parser.prototype.resolve = Î»(seen){ seen ||( seen = new Map() )
// 	if (seen.has(@)) â†© seen.get(@); seen.set(@,@)
// 	switch( @.type ){
// 		default: ;
// 		break; case 'lazy': Tfun(@.Î¹) &&( @.Î¹ = @.Î¹(), @.Î¹.resolve(seen) )
// 		break; case 'seq': case 'alt': @.ps.map(Î¹=> Î¹.resolve(seen))
// 		break; case 'times': case 'map': case 'map_js': case 'chain': @.p.resolve(seen)
// 		}
// 	â†© seen.get(@) }
// Parser.prototype.optimize = Î»(seen){ seen ||( seen = new Map() )
// 	if (seen.has(@)) â†© seen.get(@); seen.set(@,@)
// 	switch( @.type ){
// 		default:;
// 		break; case 'lazy': seen.set(@,@.Î¹); @.Î¹ = @.Î¹.optimize(seen); seen.set(@,@.Î¹)
// 		break; case 'seq': case 'alt': @.ps = @.ps.map(Î¹=> Î¹.optimize(seen))
// 		break; case 'times': case 'map': case 'map_js': case 'chain': @.p = @.p.optimize(seen)
// 		}
// 	â†© seen.get(@) }

Parser.prototype.parse = Î»(stream){ Tstr(stream) || â€½
	p â† @//.resolve()
	G_opt.fast = true; r â† p.skip(eof)._(stream,0)
	if (!r.status){ G_opt.fast = false; r â† p.skip(eof)._(stream,0); !!r.status && â€½; â€½({ index:make_line_col_index(stream, r.furthest), expected:r.expected, stream:stream.slice(0,1e3), }) }
	â†© r.value }

// make_win â† (index,value)â‡’ { status:true, index, value, }
make_win â† (index,value)â‡’ { status:true, index, value, furthest:-1, expected:[], }
make_lose â† (index,expected)â‡’ { status:false, index:-1, value:null, furthest:index, expected:[expected], }

P.seq = (â€¦ps)=> __seq(ps.map(P.X))

alt â† P.alt = (â€¦ps)=>{ ps = ps.map(P.X); ps.â€– || â€½; â†© __alt(ps) }

Parser.prototype.many = Î»(){â†© @.times(0,âˆ) }
Parser.prototype.times = Î»(min,max){ if (arguments.length < 2) max = min; Tnum(min) || â€½; Tnum(max) || â€½; â†© __times(@,min,max) }

Parser.prototype.map    = Î»(f){ Tfun(f) || â€½; â†© __map(@,f) }
Parser.prototype.map_js = Î»(f){ Tfun(f) || â€½; â†© __map_js(@,f) }
Parser.prototype.skip = Î»(next){â†© P([@,next]).map(Î¹=> Î¹[0]) }

eof â† P.eof = __eof()

Parser.prototype.chain = Î»(f){â†© __chain(@,f) }

// -------------------------- extra (mostly unused) ------------------------- //

merge_replies â† (r,last)=>{
	if (G_opt.fast) â†© r
	if (!last) â†© r
	if (r.furthest > last.furthest) â†© r
	expected â† r.furthest===last.furthest? unsafe_union(r.expected, last.expected) : last.expected
	â†© { status:r.status, index:r.index, value:r.value, furthest:last.furthest, expected, } }

// Returns the sorted set union of two arrays of strings. Note that if both arrays are empty, it simply returns the first array, and if exactly one array is empty, it returns the other one unsorted. This is safe because expectation arrays always start as [] or [x], so as long as we merge with this function, we know they stay in sorted order.
unsafe_union â† (xs,ys)=>{
	xL â† xs.â€–
	yL â† ys.â€–
	if (xL===0) â†© ys; else if (yL===0) â†© xs
	r â† {,}
	for (i â† 0; i < xL; i++) r[xs[i]] = true
	for (i â† 0; i < yL; i++) r[ys[i]] = true
	â†© _.keys(r).sort() }

P.format_error = (stream,error)=>{
	t â† error.expected; ex â† t.â€–===1? t[0] : 'one of '+t.join(', ')
	index â† error.index; i â† index.offset
	prefix â† (i > 0 ? "'..." : "'")
	suffix â† (stream.â€– - i > 12 ? "...'" : "'")
	if (i===stream.â€–) â†© ', got the end of the stream'
	â†© 'expected '+ex+' at line ' + index.line + ' column ' + index.column +  ', got ' + prefix + stream.slice(i,i+12) + suffix }

seq_map â† P.seq_map = (â€¦a)=>{ f â† a[-1]; a = a.slice(0,-1); Tfun(f) || â€½; â†© P(a).map(Î¹=> f(â€¦Î¹)) }

//X // Allows to add custom primitive parsers
//X P.custom = f=> p_wrap(f(make_win,make_lose))

P.sep_by = (p,sep)=> P.sep_by1(p,sep).or(P.of([]))
P.sep_by1 = (p,sep)=>{ p = P(p); sep = P(sep)
	pairs â† sep.then(p).many()
	â†© p.chain(r=> pairs.map(rs=> [r].concat(rs) ) ) }

Parser.prototype.or = Î»(p){â†© alt(@,p) }
Parser.prototype.then = Î»(next){ next = P(next); â†© P([@,next]).map(Î¹=> Î¹[1]) }

Parser.prototype.result = Î»(Î¹){â†© @.map(()=> Î¹) }
Parser.prototype.at_most = Î»(n){â†© @.times(0,n) }
Parser.prototype.at_least = Î»(n){â†© seq_map(@.times(n), @.many(), (init,r)=> init.concat(r) ) }
Parser.prototype.mark = Î»(){â†© seq_map(index,@,index,(start,value,end)â‡’ { start, value, end } ) }
//X Parser.prototype.desc = Î»(expected){â†© p_wrap((stream,i)=>{ r â† @._(stream,i); if (!r.status) r.expected = [expected]; â†© r }) }

P.of = __of
fail â† P.fail = __fail
//X P.any = p_wrap((stream,i)=> i >= stream.â€–? make_lose(i,'any character') : make_win(i+1, stream[i]) )
//X P.all = p_wrap((stream,i)=> make_win(stream.â€–, stream.slice(i)) )

//X test â† P.test = test=>( Tfun(test) || â€½,
//X   p_wrap((stream,i)=> i < stream.â€– && test(stream[i])? make_win(i+1,stream[i]) : make_lose(i,'a character matching '+test) )
//X   )
//X P.one_of = s=> test(ch=> s.indexOf(ch) >= 0 )
//X P.none_of = s=> test(ch=> s.indexOf(ch) < 0 )
//X P.take_while = test=>( Tfun(test) || â€½,
//X   p_wrap((stream,i)=>{ j â† i; while (j < stream.â€– && test(stream[j])) j++; â†© make_win(j,stream.slice(i,j)) })
//X   )

make_line_col_index â† (stream,i)=>{ lines â† stream.slice(0,i).split('\n'); â†© { offset:i, line:lines.â€–, column:lines[-1].â€–+1, } }

index â† P.index = __index()

// ---------------------------------- final --------------------------------- //

Pretty_Typed â† Î»(T,Î¹){ @.T = T; @.Î¹ = Î¹ }; Pretty_Typed.prototype.inspect = Î»(d,opt){â†© @.T+':'+util.inspect(@.Î¹,opt) }
P.T = (T,Î¹)=> new Pretty_Typed(T,Î¹)
Parser.prototype.T = Î»(ss,â€¦Î¹s){â†© @.map(Î¹=> P.T(ss[0],Î¹) ) }

typeof module !== 'undefined' && ( module.exports = P )

// Î¶_parse â† (Î»(){
// 	word_extra â† re`â™ˆ-â™“ğŸ”…ğŸ”†`.source; word_extra_gu â† re`[â€¦${word_extra}]`.g
// 	word â† re`A-Za-z0-9_$Ê°-Ê¸Ë¡-Ë£Î‘-Î¡Î£-Ï‰á´¬-áµ›áµ¢-áµ¥á¶œá¶ á¶»â°â±â¿â‚-â‚“â‚•-â‚œâ„‚â„•â„šâ„â„¤â±¼â±½â€¦${word_extra}`.source
// 	ident â† P(re`(?![0-9])[â€¦${word}]+|@`)
// 	comment â† re`(//.*|/\*[^]*?(\*/|$))+`
// 	simple_js â† P(()=> P.alt(
// 		P(comment).T`comment`,
// 		P.seq( P('{'), simple_js, P('}') ),
// 		P.seq( P.alt(
// 			P(/(['"])(((?!\1)[^\\]|\\.)*?\1)/).T`string`,
// 			ident,
// 			P.seq( P('`').T`template`, tmpl_Î¹.many(), P('`').T`template` ),
// 			P(/[)\]0-9]/)
// 			), P.alt( P(re`[ \t]*(?!â€¦${comment.source})/`), P.of('') ) ),
// 		P(re`/((?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/([a-z]*)`).T`regex`,
// 		P(re`[^{}/'"â€¦${'`'})@\]â€¦${word}]+|[^}]`)
// 		).many() )
// 	tmpl_Î¹ â† P.alt( P.seq( P('${').T`template`, simple_js, P('}').T`template` ), P(/\\[^]|(?!`|\$\{)[^]/).T`template` )
// 	js_file â† P.seq( P(/(#!.*\n)?/).T`shebang`, simple_js )
// 	global.js_file = js_file
// 	// js_file = js_file.resolve()
// 	// js_file = js_file.optimize()
// 	cn.log('parser:',js_file)
// 	â†© code=>{
// 		Î¹ â† js_file.parse(code)._.flatten()
// 		r â† []; for(var t of Î¹) t.T? r.push(t) : r[-1]&&r[-1].T? r.push(t) : (r[-1]+=t)
// 		â†© r } })()
// test â† ()=>{
// 	cn.log('test parsimmon')
// 	test â† ()=> Î¶_parse(in_); in_ â† Ï†`~/code/scratch/Î¶/index.Î¶`.text
// 	// pass â† JSON.stringify(test())===Ï†`/tmp/aaaa`.text
// 	// cn.log(pass?'pass âœ“':'fail X')
// 	// cn.log('perf',bench(test,{TH:3}))
// 	cn.log('perf',bench(test,{TH:1}))
// 	}
// if (!module.parent) test()
