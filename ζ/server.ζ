#!/usr/bin/env ζ
// APP ← '\x1b[34m[ζ eval pool]\x1b[0m'
log ← (…a)=> φ(__dirname).φ`log.txt`.text = φ(__dirname).φ`log.txt`.text + [Time(),…a].map(ι=> Tstr(ι)? ι : util.inspect(ι)).join(' ')+'\n'

// ------------------------ should be in standard lib ----------------------- //
on_off ← λ(){ ons ← []; ↩{ on(ee,m,f){ ee.on(m,f); ons.push([ee,m,f]) }, off(){ ons.map(λ([ee,m,f]){ ee.removeListener(m,f) }); ons = [] } }}

// ----------------------------------- lib ---------------------------------- //
as_module ← ι=>{ t ← φ`/tmp/node_${simple_hash(ι).slice(0,20)}.js`; t.ι = ι; ↩ t+'' }
eval_in_new_worker ← code=>{ t ← as_module(js`require(${__dirname})(global);`+code); ↩ require('child_process').fork(t,[],{silent:true}) }
eval_in_worker ← (λ(){
	busy ← new Set(); free ← new Set()
	process.once('exit',()=>{ […busy,…free].map(ι=> ι.kill()) })
	make ← ()=>(
		log('new worker',w_id),
		eval_in_new_worker('('+λ(){
			wait ← ()=> process.once('message',ι=>{ ι[0]==='eval' || ‽; try{ (0,eval)(ι[1]) }catch(e){ φ`~/file/what.txt`.text = `shit, got ${e.stack} in ${ι[1]}`; throw e } }) //! todo: make this logging less stupid
			wait()
			process.on('beforeExit',i=>{ process.send(['*',['pseudo_exit',i],['unbusy']]); process.exitCode = 0; wait() })
			process.on('exit',i=>{ process.send(['pseudo_exit',i]) })
			}+')()')
		.on('message',λ(ι){ (ι[0]==='*'? ι.slice(1) : [ι]).map(ι=> @.emit(…ι) ) })
		.on('unbusy',λ(){ busy.delete(@); free.add(@) })
		._.assign({id: w_id++})
		); w_id ← 0
	;(λ(){ t ← free.pop(); free._.map(ι=> ι.kill()); free = new Set(); t && free.add(t) }).every(10*60)
	cleanup ← ()=>{
		busy['filter!'](ι=> ι.connected || (log('lost busy worker',ι.id),0))
		free['filter!'](ι=> ι.connected || (log('lost free worker',ι.id),0))
		free.size || free.add(make()) }
	↩ code=>{ cleanup(); t ← free.pop(); free.delete(t); busy.add(t); t.send(['eval',code]); ↩ t }
	})()
procify ← (a,code)=> ζ_compile( ('a ← '+JSON.stringify(a)+'; on_off ← '+on_off+'; ('+λ Λ(){ ♓ ← process
	err ← e=>( ♓.stderr.write((e.stack||e)+'\n'), ♓.exitCode || (♓.exitCode = 1) )
	{on,off} ← on_off(); on(♓,'uncaughtException',λ(e){ err(e); ♓.exit() }); on(♓,'beforeExit',()=> off())
	♓.argv = [♓.argv[0],…a.argv]; φ.cwd = a.cwd; ♓.env = a.env; [♓.stdin,♓.stdout,♓.stderr]._.zip(a.isTTY).map(([fd,t])=> fd.isTTY = t)
	try{ _code }catch(e){ err(e) }
	}+')()').replace('_code',code) )

// ---------------------------------- main ---------------------------------- //
if (!module.parent){
	on_ready ← ()=>{        log('server ready'  ); shᵥ`ln -sf mimic    ${__dirname}/.bin/ζλ` }
	process.on('exit',()=>{ log('server exiting'); shᵥ`ln -sf index.js ${__dirname}/.bin/ζλ` })
	new net.Server()
		.listen(+φ(__dirname).φ`PORT`.text.re`\d+`[0],'localhost',on_ready)
		.on('connection',λ(socket){t←;
			worker←; ended←;
			c_send ← λ(type,ι){ if (ended) ↩; a ← Buffer(4); b ← Buffer(type); c ← Buffer(ι||''); a.writeInt32BE(c.length,0); socket.write(Buffer.concat([a,b,c])) }
			socket.on('end',t=_.once(λ(){ !ended && worker && worker.kill('SIGINT'); ended = true })).on('error',t)
			socket.on('data',catch_(λ(ι){
				if (buf){ ι = Buffer.concat([buf,ι]); buf = null }
				i←0; get ← n=> i+n <= ι.length || (buf = ι.slice(i), _↩())
				while(i<ι.length){ get(5); L ← ι.readInt32BE(i); type ← String.fromCodePoint(ι[i+4]); get(5+L); on_msg({type, ι:ι.slice(i+=5,i+=L)})}
				})); buf←;
			a ← {argv:[], cwd:'', env:{}, isTTY:[,,,]}
			on_msg ← ι=>{switch(ι.type){default: ‽
				break; case 'A': a.argv.push(ι.ι+'')
				break; case 'E': [,k,v] ← (ι.ι+'').re`^([^=]*)=(.*)`; k.re`^NAILGUN_TTY_\d$`?( a.isTTY[k[-1]] = v!=='0' ):( a.env[k] = v )
				break; case 'D': a.cwd = ι.ι+''
				break; case 'R':
					if (a.argv[1]==='TEST'){ c_send('X',5+''); ended = true; ↩ }
					worker = eval_in_worker(procify(a,'ζ_main()'))
					{on,off} ← on_off()
					;[1,2].map(i=> on(worker.stdio[i],'data',ι=> c_send(i+'',ι)) )
					on(worker,'pseudo_exit',λ(i){ c_send('X',i+''); ended = true; off() })
					// c_send('S')
				break; case 'H': // not sure what this is for
				break; case '0': // c_send('S'); worker.stdin.write(ι.ι)
				break; case '.': // worker.stdin.end()
				}}
			})
}
// old issue: always eats the entire stdin handed to it instead of only eating it on-demand, because i couldn't figure out how to replace stdin in the worker
// new issue: ignores stdin because it's complicated on the node side
// (old code: fs.fstatSync(0).isFIFO()? read_stdin(t) : t() )

// --------------------------------- ‡ todo --------------------------------- //
// #! important features:
// # * hardening against fucking up the pooled process
// # * pool refreshing / management
// # * fast
// # if we go to sleep and the server’s down, then we’ll be waiting, which is why we need server management tools.

//! the right way to solve this: have mimic fallback to calling index.js if it can't connect to the server
//! todo: server.ζ set to keep_alive by index.js at first ζpool call, not on package installation; via factoring out action {REQUIRE_PACKAGE and START} to actions REQUIRE_PACKAGE and START
