// Algebraic JavaScript Specification https://github.com/fantasyland/fantasy-land is cute and might be relevant to further builtin design
// todo: module.exports seems to be calling itself twice on things and this is bad

E ← {} // exports
ˡ ← {} // local
patches ← []
P ← λ(ι){(_.isArray(ι)? ι : _(ι).pairs()).forEach(λ(t){name ← t[0]; ι ← t[1]
	name = name.split('.'); last ← name.pop()
	r ← λ(G){t ← name.reduce(λ(r,ι){↩ r[ι]},G); typeof(ι)==='function'? ((ι.name && (ι.super = t[last])), t[last] = ι) : def(t,last,ι)}
	r(global); patches.push(r)
	})}

def ← λ(o,name,get,set){ι ← typeof(get)==='function'? {get:get, set:set || (set = λ(ι){delete @[name]; @[name] = ι})} : get; Object.defineProperty(o,name,_({configurable:true}).extend(ι)); ↩ o}
lazy ← λ(name,ι){↩ {get:λ(){↩ @[name] = ι()}}} //! def_lazy doesn't use this because def doesn't take this in as a format. but ... bleh?
def_lazy ← λ(o,name,ι){↩ def(o, name, λ(){↩ @[name] = ι()})}
def_pipeable ← λ(o,name,ι){↩ def(o, name, λ(){if (global.__special_pipe_ι === undefined) ↩ ι; else {t ← global.__special_pipe_ι; global.__special_pipe_ι = undefined; ↩ ι(t)}})}

_ ← require('underscore')
;[ ['child_process'],['events','EventEmitter'],['http'],['https'],['module','Module'],['net'],['os'],['path'],['punycode'],['querystring'],['readline'],['repl'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['priorityqueuejs',,ˡ],['rwlock',,ˡ],
].map(λ(ι){def_lazy(ι[2]||E,ι[1]||ι[0],λ(){↩ require(ι[0])})})
global.stream = E.stream

def_pipeable(E,'_',_)
E._require_lazy = λ(require){↩ λ Λ(ι,version){
	if (arguments.length === 1) {try {↩ require(ι)} catch (e) {if (!(e.code === "MODULE_NOT_FOUND")) throw e; ↩ Λ(ι,0,e)}}
	else {
		if (!version) throw arguments[2] //! todo
		cache ← fs('~/.npm/'+ι+'/'+version).path
		fs(cache+'/ι').exists() || (
			print('[lazy require] installing',ι+'@'+version),
			fs(cache).exists() || execᵥ('cd ~; npm cache add '+sh_encode(ι+'@'+version)),
			execᵥ('cd '+sh_encode(cache)+' && npm i '+sh_encode(ι+'@'+version)+' && mv node_modules/'+sh_encode(ι)+' ι && rmdir node_modules'),
			print('[lazy require] done') )
		↩ require(cache+'/ι')}
	}}
Array.from? console.warn('Array.from polyfill is not needed') : (Array.from = λ(ι){r ← []; while (t = ι.next(), !t.done) r.push(t.value); ↩ r})
;(λ(){
write_object ← λ(θ,ι){ι.pipe? ι.pipe(θ) : θ.end(typeof(ι)==='string'? ι : util.inspect(ι,{depth:null}))}
def_pipeable(E,'p',λ(ι){↩ arguments.length === 0? execᵥ('pbpaste') : write_object(child_process.spawn('pbcopy').stdin, ι === undefined? '' : ι)})
def_pipeable(E,'sb',λ(ι){↩ arguments.length === 0? sublimeᵥ('view.substr(sublime.Region(0,view.size()))') : write_object(child_process.spawn('open',['-a','Sublime Text.app','-f']).stdin,ι)})
})()
E.email = λ(){
	sb().split(/\n{3,}/g).map(λ(ι){t ← ι.split('\n'); ↩ ('mailto:'+t[0]+'?subject='+t[1]+'&body='+t.slice(2).join('\n')).replace(/\n/g,'%0A')})
		.map(λ(ι){osa('tell app "chrome" to open location '+osa_encode(ι))})
	osa('tell app "chrome" to activate') }
E.A = λ(ι){↩ Array.prototype.slice.call(ι)}
E.print = λ(){a ← A(arguments); process.stdout.write(a.map(λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{colors:true,depth:2})}).join(' ')+'\n'); ↩ a[-1]}
_(E).extend(_(Math).pick('abs','ceil','exp','floor','log','log10','log2','max','min','PI','pow','round','sqrt')); _(E).extend({ln:E.log, ln2:E.log2, ln10:E.log10})
E.multiline = λ(ι){ι = ι.toString().split('\n').slice(1,-1); t ← _.min(ι.map(λ(ι){↩ ι.match(/^\t*/)[0].length})); ι = ι.map(λ(ι){↩ ι.slice(t)}); ↩ (ι[0]==='' && ι[ι.length-1]===''? ι.slice(1,-1) : ι).join('\n')}
def_lazy(E,'moment',λ(){
	_moment ← require('moment')
	moment ← λ(ι){↩ typeof(ι)==='number' && arguments.length===1? _moment(ι*1000) : _moment.apply(@,arguments)}
	Object.setPrototypeOf(moment,_moment)
	moment.fn.valueOf = λ(){↩ +@._d/1000 + (@._offset||0)*60}
	moment.fn.toString = λ(){↩ @.utc().format('YYYY-MM-DD[T]HH:mm:ss[Z]')}
	moment.fn.inspect = λ(depth,opts){t ← @.toString(); ↩ true/*opts.colors*/? '\x1b[35m'+t+'\x1b[39m' : t}
	↩ moment})
E.λ = λ(ι){r ← λ(m){↩ ι[m]}; r.ι = ι; ↩ r}
P({ 'String.prototype.λ':{get:λ(){m←@; r ← λ(ι){↩ ι[m]}                                         ; r.ι = @; ↩ r}} })
P({ 'Number.prototype.λ':{get:λ(){m←@; r ← λ(ι){↩ ι[m]}                                         ; r.ι = @; ↩ r}} })
P({ 'RegExp.prototype.λ':{get:λ(){θ←@; r ← λ(ι){↩ ι === undefined || ι === null? ι : ι.match(θ)}; r.ι = @; ↩ r}} })
P({ 'RegExp.prototype.λ':{get:λ(){θ←@; r ← λ(ι){↩ ι === undefined || ι === null? ι : ι.match(θ)}; r.ι = @; ↩ r}} })
E.ζ_compile = ζ_compile
E.ζ_compile['⁻¹'] = λ(ι){↩ ι.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$αβγδεζηθικλμνξπρστυφχψω]+)(\s*)(=?)|\.__special_pipe\(\),/g, λ(ι,name,s,eq){↩ {'function':'λ','return':'↩','this':'@','.__special_pipe(),':'⟩'}[ι] || (eq==='='? name+s+'←' : name+s+'←;')})}
E.ζ_repl_start = λ(opts){
	//! aaaaa why does this break if i remove useGlobal:true ?
	repl._builtinLibs = []
	rRpc ← repl.REPLServer.prototype.complete; repl.REPLServer.prototype.complete = λ(line,cb){line.trim()===''? cb([]) : rRpc.call(@,line,cb)}
	self ← repl.start(_({useGlobal:true, ignoreUndefined:true, prompt:{split:λ(){↩ ['ζ ']}, valueOf:λ(){↩ '\x1b[32mζ\x1b[39m '}}}).extend(opts))
	self.removeAllListeners('line')
	self.on('line',λ(cmd){
		err←; ret←;
		for(;;){
			code ← self.bufferedCommand + (cmd||'')
			if (code === '') break
			if (/(^\{[\s\S]*\}$)|(^λ\()/.test(code)) code = '('+code+')'
			if (code.match(/^>/)) code = '__SPECIAL__('+util.inspect(code.slice(1))+')' // hack: for apprentice
			try {t ← vm.createScript(ζ_compile(code)+'\n', {filename:'repl', displayErrors:false})}
			catch (e) {
				if (e.name === 'SyntaxError' && /^(Unexpected end of input|Unexpected token)/.test(e.message)) {self.bufferedCommand += cmd+'\n'; self.outputStream.write('     '); ↩}
				typeof(e.stack)==='string' && (e.stack = e.stack.replace(/(\n    at )[\s\S]*/,'$1<repl>')); err = e; break}
			try {ret ← @.useGlobal? t.runInThisContext({displayErrors:false}) : t.runInContext(self.context,{displayErrors:false})}
			catch (e) {typeof(e.stack)==='string' && (e.stack = e.stack.replace(/^([\s\S]*)at repl:(.*)[\s\S]*?$/,'$1at <repl:$2>')); err = e; break}
		break}
		self.memory(cmd)
		if (err) self._domain.emit('error', err.err || err)
		self.bufferedCommand = ''
		if (!err && ret !== undefined) {self.context.__ = ret; self.outputStream.write(self.writer(ret)+'\n')}
		self.displayPrompt()
		})
	self.context.require = _require_lazy(self.context.require)
	module.exports(self.context)
	↩ self}

E.regex_encode = λ(ι){↩ ι.replace(/([.*+?^=!:${}()\[\]|\/\\])/g, '\\$1')}
E.sh_encode = λ(){↩ A(arguments).map(λ(ι){↩ "'"+ι.replace(/'/g,"'\\''")+"'"}).join(' ')}
E.basename_encode = λ(ι){↩ ι.replace(/\//g,'⟩')}
E.osa_encode = λ(ι){↩ '"'+ι.replace(/["\\]/g,'\\$&')+'"'} // probably incomplete

E.exec = λ(ι,opts){child_process.exec(ι,opts)}
E.execᵥ = λ(ι,opts){↩ (child_process.execSync(ι,opts)+'').replace(/\n$/,'')}

E.osa = λ(ι){exec('osascript -ss -e '+sh_encode(ι))}
E.osaᵥ = λ(ι){
	osa_parse_array ← λ(ι){↩ {'missing value':1,'':1}[ι.trim()]? undefined : JSON.parse(ι.split(/("(?:\\.|.)*?")/g).map(λ(ι){↩ /^"[\s\S]*"$/.λ(ι.replace(/\n$/,''))? ι.replace(/\n$/,'').replace(/\n/g,'\\n') : ι.replace(/\{/g,'[').replace(/\}/g,']')}).join(''))} // based on https://github.com/FWeinb/node-osascript/blob/master/lib/osa-parser.peg
	↩ osa_parse_array(execᵥ('osascript -ss -e '+sh_encode(ι)))}

c_js ← λ(osaₓ,ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ osaₓ('tell app "google chrome" to tell '+tab+' of window 1 to set URL to '+osa_encode('javascript:'+ζ_compile(ι)))}
c_js_sandbox ← λ(ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ JSON.parse(osaᵥ('tell app "google chrome" to execute window 1\'s '+tab+' javascript '+osa_encode(ι))||'""')}
jquery_script ← λ(extra){↩ "t ← document.createElement('script'); t.src = 'https://code.jquery.com/jquery-2.1.4.min.js'; "+(extra||"")+"; document.getElementsByTagName('head')[0].appendChild(t)"}
E.chrome_js = λ(ι,tab){c_js(osa,ι+'; undefined',tab)}
E.chrome_jsᵥ = λ(ι,tab){c_js(osaᵥ,"t ← document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); ι ← eval("+JSON.stringify(ζ_compile(ι))+"); t ← document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(ι); t2 ← document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); undefined",tab); ↩ c_js_sandbox("document.querySelectorAll('#applescript_hack')[0].textContent",tab)}
E.chrome_$ = λ(ι,tab){chrome_js("f ← λ(){"+ι+"}; if (window.jQuery) f(); else {"+jquery_script("t.onload = f")+"}",tab)}
E.chrome_$ᵥ = λ(ι,tab){r←; $null ← '__$null_'+Math.random().toString(36).slice(2); fst ← 1; while ((r=chrome_jsᵥ("if (window.jQuery){"+ι+"} else {"+(fst? (fst=0, jquery_script()) : "")+"; '"+$null+"'}",tab))===$null); ↩ r}

E.sublimeᵥ = λ(ι){fs('/tmp/sublime_external_command').$ = ι; t ← JSON.parse(execᵥ('curl -s -X PUT 127.0.0.1:34289')); if (t !== null) ↩ t}
// sublimeᵥ('window.focus_view(window.views()[-1])')
// T ← 10; i←0; (λ(){sublimeᵥ('view.insert(edit,view.sel()[0].begin(),"\\n")')}).every(T)
// sublime_set_buffer ← λ(ι){sublimeᵥ('view.replace(edit,sublime.Region(0,view.size()),'+util.inspect(ι)+')')}
// braille_table ← _.range(0x100).map(λ(ι){↩ String.fromCharCode('⠀'.charCodeAt(0)+ι)})
// braille_2d ← λ(ι){↩ (Buffer.isBuffer(ι.ι)? ι.ι.partition(ι.X) : ι).partition(4).map(λ(ι){t ← []; for(i←0;i<ι[0].length;i+=2) t.push(braille_table[(ι[0][i]<<0)|(ι[1][i]<<1)|(ι[2][i]<<2)|(ι[0][i+1]<<3)|(ι[1][i+1]<<4)|(ι[2][i+1]<<5)|(ι[3][i]<<6)|(ι[3][i+1]<<7)]); ↩ t.join('')}).join('\n')}
// life ← λ(ι){
// 	if (!ι) {ι ← {X:115*2,Y:46*4}; ι.ι = Buffer(_.range(ι.X*ι.Y).map(λ(){↩ Math.random()<0.5 ?1:0})); ↩ ι} // 115,46
// 	else {X ← +ι.X; Y ← +ι.Y; ι = ι.ι
// 		r ← Buffer(ι)
// 		get ← λ(x,y){↩ 0<=x&&x<X && 0<=y&&y<Y? ι[y*X+x] : 0}
// 		for(y←1;y<Y-1;y++) for(x←1;x<X-1;x++) {
// 			n ← ι[(y-1)*X+x-1] + ι[(y-1)*X+x] + ι[(y-1)*X+x+1] + ι[y*X+x-1] + ι[y*X+x+1] + ι[(y+1)*X+x-1] + ι[(y+1)*X+x] + ι[(y+1)*X+x+1]
// 			r[y*X+x] = (n===2? ι[y*X+x] : n===3? 1 : 0) }
// 		for(y←0;y<Y;y+=Y-1) for(x←0;x<X;x++) {
// 			n ← 0; for(xₒ←-1;xₒ<=1;xₒ++) for(yₒ←-1;yₒ<=1;yₒ++) n += get(x+xₒ,y+yₒ)
// 			r[y*X+x] = (n===2? get(x,y) : n===3? 1 : 0) }
// 		for(x←0;x<X;x+=X-1) for(y←1;y<Y-1;y++) {
// 			n ← 0; for(xₒ←-1;xₒ<=1;xₒ++) for(yₒ←-1;yₒ<=1;yₒ++) n += get(x+xₒ,y+yₒ)
// 			r[y*X+x] = (n===2? get(x,y) : n===3? 1 : 0) }
// 		// for(y←0;y<Y;y++) for(x←0;x<X;x++) {
// 		// 	n ← 0; for(yₒ←-1;yₒ<=1;yₒ++) for(xₒ←-1;xₒ<=1;xₒ++) n += get(x+xₒ,y+yₒ)
// 		// 	r[y*X+x] = (n===3? 1 : n===4 && get(x,y)===1? 1 : 0) }
// 		↩ {X:X,Y:Y,ι:r} } }
// ι←; for(;;) sublime_set_buffer(braille_2d(ι = life(ι)))

P({
'Object.prototype.__special_pipe':{value:λ(){'use strict'; global.__special_pipe_ι = @}},
'Function.prototype.P':λ(){ι←@; a ← A(arguments); ↩ λ(){↩ ι.apply(@,arguments.length === 0? a : a.concat(A(arguments)))}},
'Function.prototype.X':λ(n){ι←@; ↩ λ(){↩ ι.apply(@,A(arguments).slice(0,n))}},
'Array.prototype.mapcat':λ(f){↩ @.map(f)._.flatten(true)},
'String.prototype.repeat':λ(x){↩ x<=0? '' : Array(x+1).join(@)},
'Array.prototype.repeat':λ(x){↩ x<=0? [] : _.range(0,x).map(_.constant(@))._.flatten(true)},
'Function.prototype.inspect':λ(rec,ctx){t ← ζ_compile['⁻¹'](@+'').replace(/^λ \(/,'λ(').match(/^.*?\)/); ↩ ctx.stylize('['+(t?t[0]:'λ ?(?)')+']', 'special')},
'String.prototype._':{get:λ(){↩ _(@)}},
'Array.prototype._':{get:λ(){↩ _(@)}},
// 'String.prototype.::-1':{get:λ(){↩ (@+'').split('').reverse().join('')}},
// 'Array.prototype.::-1':{get:λ(){↩ @._.clone().reverse()}},
'Buffer.prototype.partition':λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r},
'Array.prototype.partition':λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r},
'String.prototype.partition':λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r},
'Buffer.prototype.inspect':λ ρ(){↩ ρ.super.call(@).replace(/(^<\w+)/,'$1['+@.length+']')},
'RegExp.prototype.genex_0':λ(){
	parse ← λ(ι){
		q ← λ(ι){↩ ι.match(/\(.*?\)|\[.*?\]|\\.|./g).map(λ(ι){↩ ι[0]==='('? q(ι.slice(1,-1)) : ι[0]==='['? {or:ι.slice(1,-1).split('')} : ι})}
		w ← λ(ι){if (!_.isArray(ι)) ↩ ι; t←; r ← []; while ((t=_.indexOf(ι,'|')) !== -1) {r.push(ι.slice(0,t)); ι = ι.slice(t+1)}; ↩ r.length? (r.push(ι),{or:r}) : ι.map(w)}
		↩ w(q(ι))}
	q ← λ(ι){↩ ι.or? ι.or.map(q) : _.isArray(ι)? ι.map(q).reduce(λ(a,b){↩ a.mapcat(λ(a){↩ b.map(λ(b){↩ a+b})})}) : [ι]}
	↩ q(parse(@.source)) },
'Function.prototype.in':λ(time){↩ !time || time <= 0? setImmediate(@) : setTimeout(@,time*1000)},
'Function.prototype.every':λ(time){↩ setInterval(@,time*1000)},
'Function.prototype.at':lazy('at',λ(){
	// robust to setTimeout taking extra time
	now ← λ(){↩ Date.now() / 1000}
	λs ← new ˡ.priorityqueuejs(λ(a,b){↩ b.time-a.time}); lock ← new ˡ.rwlock(); p←;
	enq ← λ(ι){lock.writeLock(λ(R){λs.enq(ι); R(); if (!P){P = true; (λ poll(){lock.writeLock(λ λ(R){
		t←; λs.size() === 0? (P = false) : !(λs.peek().time < now())? poll.in(0.1) : (t=λs.deq(), t.canceled || t.ι.in(), λ()); R&&R()
		}) })() } })}
	↩ λ(time){t ← {time:time, ι:@}; ↩ time < now()? (t.ι.in(), {clear:λ(){}}) : (enq(t), {clear:λ(){t.canceled = true}})} }),
'stream.Readable.prototype.read_all':λ(cb){t ← []; @.resume().on('data',λ(ι){t.push(ι)}).on('end',λ(){cb(null,Buffer.concat(t))})},
})
P(/(Array|String|Buffer).prototype.-[01234]/.genex_0().map(λ(ι){i ← parseInt(ι[ι.length-1]); ↩ [ι, {get:λ(){↩ @.length<i? undefined : @[@.length-i]}, set:λ(ι){↩ @.length<i? ι : (@[@.length-i] = ι)}}]}))

def_lazy(E,'fs',λ(){t ← λ(path_){↩ new ˡ.Path(path_)}; Object.setPrototypeOf(t,require('fs')); ↩ t})
def_lazy(ˡ,'Path',λ(){
	// a file is a key-value pair in a sort of fuzzy-keyed dict with many types, but primarily "key array" and "byte array, usually interpreted as string"
	// represented as a Path, it has properties path_ and $/val/value/deref
	// a Path is normally just a fluent wrapper but can become a file descriptor holder or an event manager
	// maybe we can also pass it a type/format/view/mixin! eesh, maybe we need to fit it into the prototype system instead of just using a mixin...
	Path ← λ Path(path_){
		@.path_ = path_ instanceof Path? path_.path : path_.replace(/^~(?=\/)/,process.env.HOME)
		@.path = path_ instanceof Path? path_.path : path.normalize(@.path_+'/.')
		}
	def(Path.prototype,'$',λ(){↩ @._$()}, λ(ι){↩ @['='](ι)})
	// path_ manipulation
	Path.prototype.dir = λ(){↩ fs.statSync(@.path).isDirectory()}
	Path.prototype.exists = λ(){↩ fs.existsSync(@.path)}
	Path.prototype.resolve = λ(){↩ path.resolve(@.path)}
	Path.prototype.name = λ(ext){↩ path.basename(@.path,ext)}
	// find
		// it's really weird how this returns a thing that you can't actually pass to fs()
		// maybe we'll fix this by returning a more magical, jquery-like thing?
	Path.prototype.find = λ(sel){↩ Array.from(@.findˢ(sel))}
	Path.prototype.findˢ = λ*(sel){
		// does not handle uniqueness in selections
		// wtf is up with selectors only being a .find() thing and not a fs() thing? and not returning selections so they're not chainable?
		// doesn't normalize everything properly or reliably
		// doesn't follow symlinks (note: when you do follow symlinks, know that not all symlinks lead places)

		seq ← λ*(ι){for (i←0;i<ι.length;i++) yield ι[i]}
		WALK ← λ*(t,mode){
			switch (mode) {
				default: throw '↯'
				break; case '>': yield* seq(fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι}))
				break; case '*':
					root ← t+'/'
					//! bad - should use directed Dijkstra's from all roots with edge length equal to the number of files in a dir
					// sample impl:
						// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}
						// root ← '.'
						// dist ← {}; dist[root] = 0
						// next ← [root] // should be pqueue
						// out ← []
						// while (next.length) {t ← next._.min(λ(ι){↩ dist[ι]}); next = next._.without(t); out.push(t); at←; (at=all(t)).map(λ(ι){dist[ι] = dist[t] + at.length; next.push(ι)}) }
					// or just:
						// all ← λ(ι){try {↩ fs.readdirSync(ι).map(λ(t){↩ ι+'/'+t}) } catch (e) {↩ []}}; root ← '.'; out ← []
						// (λ λ(ι,dist){out.push([dist,ι]); at←;(at=all(ι)).forEach(λ(t){λ(t,dist + at.length)})})(root,0)
						// q ← out._.sortBy(0)._.map(1)
					// note: as is will inf-loop on scary things
					walk_ ← λ*(ι){try {l ← fs.readdirSync(root+ι); for (i←0;i<l.length;i++){t ← ι+l[i]; try {fs.lstatSync(fs(root+t).path).isDirectory()? (yield root+t, yield* walk_(t+'/')) : yield root+t} catch (e) {}}} catch (e) {}}
					yield* walk_('')
				} }

		sel = sel.trim()
		if (sel === '') ↩;

		ERR ← λ(){throw Error('[ζ] selector is not supported: '+sel)}

		sel_a ← (' '+sel).replace(/(^|[^>* ])( +(?![>* ]))/g,'$1 * ').trim().split(/ +/)
		if (!sel_a.every(λ(ι){↩ ι.match(/^>|\*|\.\S+|#\S+$/)})) ERR()
		//! should be: if (!sel_a.every(λ(ι){↩ ι.match(/^(>|\*|\.\S+|#\S+)$/)})) ERR()

		r ← seq([@.path_])
		sel_a.forEach(λ(ι){
			r_ ← r
			temp ← (λ*(){t←; //r_ ← r
				sw←; switch (sw=ι[0], ι=ι.slice(1), sw) {
					default: ERR()
					break; case '>': case '*': while (t=r_.next(),!t.done) {t=t.value; yield* WALK(t, sw)}
					break; case '.': while (t=r_.next(),!t.done) {t=t.value; if (t.match(RegExp(regex_encode('.'+ι)+'$'))) yield t}
					break; case '#': while (t=r_.next(),!t.done) {t=t.value; if (t.match(RegExp(regex_encode(ι)+'$'))) {yield t; break}}
					} })()
			r = temp
			})

		yield* r}
	// misc
	Path.prototype.toString = λ(){↩ path.resolve(@.path).replace(RegExp('^'+regex_encode(process.env.HOME)+'(?=/)'),'~')}
	// content manipulation
	Path.prototype._$ = λ(){t ← @.path; ↩ !@.exists()? '' : @.dir()? (console.trace('[ζ] DEPRECATED dir_$'), fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι})) : fs.readFileSync(t)+''}
	Path.prototype['='] = λ(ι){
		// string: text file, Array: directory, etc
		// async should use like fs.createReadStream(ι.path).pipe(fs.createWriteStream(@.path))
		if (@.exists() && @.dir()) throw Error('writing to directories not implemented')
		mkdir_p ← λ ρ(ι){try {fs.statSync(ι).isDirectory() || fs.mkdirSync(ι)} catch (e) {if (e.code !== 'ENOENT') throw e; ρ(path.dirname(ι)); fs.mkdirSync(ι)}}
		mkdir_p(path.resolve(path.dirname(@.path)))
		fs.writeFileSync(@.path,ι) }
	↩ Path })

require.extensions['.ζ'] = λ(module,ι){module._compile(ζ_compile(fs.readFileSync(ι,'utf8').replace(/^((?:#!.*\n)?)/,'$1require = _require_lazy(require);')),ι)}

E.ζtoken = {}
λ prop_extend(from,to){Object.getOwnPropertyNames(from).forEach(λ(ι){Object.defineProperty(to,ι,Object.getOwnPropertyDescriptor(from,ι))})}
prop_extend(E,global)
module.exports = λ(to){to.ζtoken === E.ζtoken || (prop_extend(E,to), patches.forEach(λ(ι){ι(to)}))}

// -------------------------------- discarded ------------------------------- //

// String.prototype.replace_all = λ(find,replace){↩ @.replace(RegExp(regex_encode(find),'g'),replace)}
// create_getattr ← (λ(){
// 	proxy_boiler ← {getOwnPropertyDescriptor:λ(){}, getPropertyDescriptor:λ(){}, getOwnPropertyNames:λ(){↩[]}, getPropertyNames:λ(){↩[]}, defineProperty:λ(){}, delete:λ(){↩false}, fix:λ(){}, inspect:λ(){↩'[MAGIC-GET-ATTR]'}}
// 	↩ λ(get,set){↩ Proxy.create({get:λ(self,name){↩ proxy_boiler[name] || get(name)}, set:λ(self,name,ι){set(name,ι)}})} })()
// create_getattr(λ(n){@.$[n]},λ(n,ι){
// 			magic magic
// 			}),
// E.ζ_bit_reverse_i = λ(length,ι){r ← 0; for (i←0;i<length;i++){r = (r << 1) | (ι & 1); ι = ι >> 1}; ↩ r}
// Path.prototype.parent = λ(){↩ fs(path.dirname(@.path))}
// // Path.prototype.slice = λ(i){↩ ζ_def({},'$',λ(){},λ(ι){path_open(@,λ(){t ← Buffer(ι); fs.writeSync(@.fd,t,0,t.length,i); fs.ftruncateSync(@.fd,i + Buffer.byteLength(ι))})})}
// Path.prototype.splice = λ(idx,rm,ι){path_open(@,λ(fd){t←;
// 	ι = Buffer(ι)
// 	rm === ι.length || (t = Buffer(fs.statSync(@.path).size - (idx+rm)), fs.readSync(fd,t,0,t.length,idx+rm))
// 	fs.writeSync(fd,ι,0,ι.length,idx)
// 	rm === ι.length || fs.writeSync(fd,t,0,t.length,idx+ι.length)
// 	rm > ι.length && fs.ftruncateSync(fd,idx+ι.length+t.length)
// 	})}
