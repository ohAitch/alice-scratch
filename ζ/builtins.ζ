// todo:
// http://es6-features.org/#MethodProperties
// http://es6-features.org/#ObjectMatchingDeepMatching
// http://es6-features.org/#GetterSetter
// http://es6-features.org/#IteratorForOfOperator
// http://es6-features.org/#GeneratorFunctionIteratorProtocol
// http://es6-features.org/#GeneratorFunctionDirectUse
// http://es6-features.org/#GeneratorMatching
// http://es6-features.org/#GeneratorControlFlow
// http://es6-features.org/#SetDataStructure    http://es6-features.org/#MapDataStructure
// http://es6-features.org/#PromiseUsage
// http://es6-features.org/#PromiseCombination
// not in node yet:
// http://es6-features.org/#BlockScopedVariables (not yet supported outside of strict mode)
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive and more
// eh:
// (new Proxy({}, {get:λ(ˣ,ι){↩ ι}})).foo === 'foo'
// http://es6-features.org/#WeakLinkDataStructures

// Algebraic JavaScript Specification https://github.com/fantasyland/fantasy-land is cute and might be relevant to further builtin design
// todo: module.exports seems to be calling itself twice on things and this is bad

E ← {} // exports
ˡ ← {} // local
patches ← []
P ← λ(ι){(_.isArray(ι)? ι : _(ι).pairs()).forEach(λ([name,ι]){
	name = name.split('.'); last ← name.pop()
	r ← λ(G){t ← name.reduce((r,ι) => r[ι], G); typeof(ι)==='function'? ((ι.name && (ι.super = t[last])), t[last] = ι) : def(t,last,ι)}
	r(global); patches.push(r)
	})}

def ← λ(o,name,get,set){Object.defineProperty(o,name,_({configurable:true}).assign(typeof(get)==='function'? {get:get, set:set || λ(ι){Object.defineProperty(@,name,{value:ι, writable:true, enumerable:true, configurable:true})}} : get)); ↩ o}
lazy ← λ(name,ι){↩ {get:λ(){↩ @[name] = ι()}}} //! def_lazy doesn't use this because def doesn't take this in as a format. but ... bleh?
def_lazy ← λ(o,name,ι){↩ def(o, name, λ(){↩ @[name] = ι()})}

_ ← require('underscore')
;[ ['child_process'],['events','EventEmitter'],['http'],['https'],['module','Module'],['net'],['os'],['path'],['punycode'],['querystring'],['readline'],['repl'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['priorityqueuejs',,ˡ],['urijs',,ˡ],
].map(λ(ι){def_lazy(ι[2]||E,ι[1]||ι[0],λ(){↩ require(ι[0])})})
global.stream = E.stream
E.Reflect = require('harmony-reflect') // ought to hook into both Proxy and Reflect and be lazy, but that's too hard, and it's a temporary hack

simple_template ← λ(ss,ιs){↩ _.zip( ss.raw.map(ι => ι.replace(/\\(?=\$\{|`)/g,'')), ιs.map(ι=>({raw:ι})) )._.flatten(true).slice(0,-1).filter(ι => ι!=='')}

E.hook_stdout = λ(){o ← process.stdout.write; r ← []; process.stdout.write = λ(ι){r.push(ι)}; ↩ λ(){process.stdout.write = o; ↩ r.join('')}}
E._require_lazy = λ(require){
	↩ _(λ Λ(ι,version){
		if (arguments.length === 1) {try {↩ require(ι)} catch (e) {if (!(e.code === "MODULE_NOT_FOUND")) throw e; ↩ Λ(ι,undefined)}}
		else {
			if (!version) ↩ require(ι) //! todo
			cache ← fs('~/.npm/'+ι+'/'+version).path
			try {↩ require(cache+'/node_modules/'+ι)}
			catch (e) {if (!(e.code === "MODULE_NOT_FOUND")) throw e
				print('[lazy require] installing',ι+'@'+version)
				fs(cache).exists() || execᵥ('cd ~; npm cache add '+sh_encode(ι+'@'+version))
				fs(cache+'/package.json').$ = JSON.stringify({description:"-",repository:1,license:"ISC"}); fs(cache+'/README').$ = ''; execᵥ('cd '+sh_encode(cache)+' && npm i '+sh_encode(ι+'@'+version)); fs(cache+'/package.json').$ = fs(cache+'/README').$ = null
				print('[lazy require] done')
				↩ require(cache+'/node_modules/'+ι)} }
		}).assign(require) }
;(λ(){
write_object ← λ(θ,ι){ι.pipe? ι.pipe(θ) : θ.end(typeof(ι)==='string'? ι : util.inspect(ι,{depth:null}))}
E.p = λ(ι){↩ arguments.length === 0? execᵥ('pbpaste') : write_object(child_process.spawn('pbcopy').stdin, ι === undefined? '' : ι)}
E.sb = λ(ι){↩ arguments.length === 0? sublimeᵥ('view.substr(sublime.Region(0,view.size()))') : write_object(child_process.spawn('open',['-a','Sublime Text.app','-f']).stdin,ι)}
// E.sb = λ(ι){↩ arguments.length === 0? sublᵥ`view.substr(sublime.Region(0,view.size()))` : write_object(child_process.spawn('open',['-a','Sublime Text.app','-f']).stdin,ι)}
})()
E.print = λ(…a){process.stdout.write(a.map(λ(ι){↩ typeof(ι)==='string'? ι : util.inspect(ι,{colors:true,depth:2})}).join(' ')+'\n'); ↩ a[-1]}
_(E).assign(_(Math).pick('abs','ceil','exp','floor','log','log10','log2','max','min','PI','pow','round','sqrt')); _(E).assign({ln:E.log, ln2:E.log2, ln10:E.log10})
E.multiline = λ(ι){ι = ι.toString().split('\n').slice(1,-1); t ← ι.map(ι => ι.match(/^\t*/)[0].length)._.min(); ι = ι.map(ι => ι.slice(t)); ↩ (ι[0]==='' && ι[ι.length-1]===''? ι.slice(1,-1) : ι).join('\n')}
def_lazy(E,'moment',λ(){
	_moment ← require('moment')
	moment ← λ(ι){↩ typeof(ι)==='number' && arguments.length===1? _moment(ι*1000) : _moment(…arguments)}
	Object.setPrototypeOf(moment,_moment)
	moment.fn.valueOf = λ(){↩ +@._d/1000 - (@._offset||0)*60}
	moment.fn.toString = λ(){↩ @.utc().format('YYYY-MM-DD[T]HH:mm:ss[Z]')}
	moment.fn.inspect = λ(depth,opts){↩ opts.stylize(@.toString(),'date')}
	↩ moment})
E.λ = λ(ι){r ← λ(m){↩ ι[m]}; r.ι = ι; ↩ r}
P({ 'String.prototype.λ':{get:λ(){m←@; r ← ι => ι[m]                                         ; r.ι = @; ↩ r}} })
P({ 'Number.prototype.λ':{get:λ(){m←@; r ← ι => ι[m]                                         ; r.ι = @; ↩ r}} })
P({ 'RegExp.prototype.λ':{get:λ(){θ←@; r ← ι => ι === undefined || ι === null? ι : ι.match(θ); r.ι = @; ↩ r}} })
P({ 'RegExp.prototype.λ':{get:λ(){θ←@; r ← ι => ι === undefined || ι === null? ι : ι.match(θ); r.ι = @; ↩ r}} })
E.hrtime = λ(ι){t ← arguments.length===0? process.hrtime() : process.hrtime([~~ι,(ι-~~ι)*1e9]); ↩ t[0] + t[1]*1e-9}
E.bench = λ(f,l){TH←0.4; r←0; I←1; for(hr←hrtime(); hrtime(hr) < TH;) {if (l) for(i←0;i<I;i++) l.push(f()); else for(i←0;i<I;i++) f(); r += I; I = ceil(I*1.5)}; ↩ hrtime(hr) / r}
memo_frp ← λ(name,f){a ← moment().toISOString(); ι ← f(); b ← moment().toISOString(); fs('~/.memo_frp/'+basename_encode(name)+'/'+basename_encode(a+' '+Buffer(15..map(()=> rand(0x100))).toString('base64'))).$ = JSON.stringify({name, date:[a,b], ι}); ↩ ι}
E.curl_s = λ(ι){↩ memo_frp('curl -s', ()=> execᵥ('curl -s '+sh_encode(ι)))} // some requests have short responses; will need more intelligent caching for those 'cause the filesystem can't take too much
E.rand = λ(a,b){switch(arguments.length){default: throw '‽'; case 0: ↩ Math.random(); case 1: ↩ Array.isArray(a)? _.sample(a) : (Math.random()*a)|0; case 2: ↩ (Math.random()*(b-a) + a)|0}}

E.ζ_compile = ζ_compile
E.ζ_compile['⁻¹'] = λ(ι){↩ ι.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$Α-ΡΣ-Ωα-ω]+)(\s*)(=?)|\.\.\./g, λ(ι,name,s,eq){↩ {'function':'λ','return':'↩','this':'@','...':'…'}[ι] || (eq==='='? name+s+'←' : name+s+'←;')})}
E.ζ_repl_start = λ(opts){
	//! aaaaa why does this break if i remove useGlobal:true ?
	repl._builtinLibs = []
	rRpc ← repl.REPLServer.prototype.complete; repl.REPLServer.prototype.complete = λ(line,cb){line.trim()===''? cb([]) : rRpc.call(@,line,cb)}
	self ← repl.start({useGlobal:true, ignoreUndefined:true, prompt:{split:ˣ=>['ζ '], valueOf:ˣ=>'\x1b[32mζ\x1b[39m '}}._.assign(opts))
	self.removeAllListeners('line')
	self.on('line',λ(cmd){
		err←; ret←;
		for(;;){
			code ← self.bufferedCommand + (cmd||'')
			if (code === '') break
			if (/(^\{[\s\S]*\}$)|(^λ\()/.test(code)) code = '('+code+')'
			if (code.match(/^>/)) code = '__SPECIAL__('+util.inspect(code.slice(1))+')' // hack: for apprentice
			try {t ← vm.createScript(ζ_compile(code)+'\n', {filename:'repl', displayErrors:false})}
			catch (e) {if (e.name === 'SyntaxError' && /^(Unexpected (end of input|token)|Unterminated template literal)/.test(e.message)) {self.bufferedCommand += cmd+'\n'; self.outputStream.write('    '); ↩}; e.stack = e.name+': '+e.message+'\n    at <repl>'; err = e; break}
			try {ret ← @.useGlobal? t.runInThisContext({displayErrors:false}) : t.runInContext(self.context,{displayErrors:false})}
			catch (e) {e && typeof(e.stack)==='string' && (e.stack = e.stack.replace(/^([\s\S]*)at repl:(.*)[\s\S]*?$/,'$1at <repl:$2>')); err = e; break}
		break}
		self.memory(cmd)
		if (err) self._domain.emit('error', err.err || err)
		self.bufferedCommand = ''
		if (!err && ret !== undefined) {
			self.context.__ = ret
			try {t ← Array.isArray(ret) && ret.length > 1 && ret.every(ι => ι===ret[0])? self.writer([ret[0]])+' * '+self.writer(ret.length) : self.writer(ret)}
			catch(e){t ← '<repl inspect failed>:\n'+(e&&e.stack)}
			self.outputStream.write(t+'\n') }
		self.displayPrompt()
		})
	self.context.require = _require_lazy(self.context.require)
	module.exports(self.context)
	↩ self}

E.regex_encode = ι => ι.replace(/([.*+?^=!:${}()\[\]|\\])/g, '\\$1')
E.sh_encode = ι => "'"+(ι+'').replace(/'/g,"'\\''")+"'"
E.basename_encode = ι => ι.replace(/[\/ǂ⟩]/g,ι => ι==='/'? '⟩' : 'ǂ'+ι)
E.basename_decode = ι => ι.replace(/(ǂ.|⟩)/g,ι => ι==='⟩'? '/' : ι[1])
E.osa_encode = ι => typeof(ι)==='number'? ι+'' : '"'+ι.replace(/["\\]/g,'\\$&')+'"' // probably incomplete // s/osa/apple/ ?

E.exec = λ(ι,opts){child_process.exec(ι,opts)}
E.execᵥ = λ(ι,opts){↩ (child_process.execSync(ι,opts)+'').replace(/\n$/,'')}

E.fs_ipc = {
	emit: λ(port,ι){fs('/tmp/fs_ipc_'+port).$ = ι; ↩ execᵥ('curl -s -X PUT 127.0.0.1:'+port)},
	on: λ(port,cbₐ){http.createServer(λ(ˣ,res){
		t ← fs('/tmp/fs_ipc_'+port).$; fs('/tmp/fs_ipc_'+port).$ = null; global.ι = fs('/tmp/fs_ipc_'+port+'_stdin').$.replace(/\n$/,''); fs('/tmp/fs_ipc_'+port+'_stdin').$ = null
		end ← ι => res.end(ι === undefined? '' : ι+''); r ← hook_stdout(); try {cbₐ(t); end(r())} catch(e){end(r()+''+(e.stack||e)+"\n")}
		}).listen(port)},
	}

E.osa = λ(ι){exec('osascript -ss -e '+sh_encode(ι))}
E.osaᵥ = λ(ι){
	osa_parse_array ← λ(ι){try {↩ {'missing value':1,'':1}[ι.trim()]? undefined : JSON.parse(ι.split(/("(?:\\.|.)*?")/g).map(λ(ι){↩ /^"[\s\S]*"$/.λ(ι.replace(/\n$/,''))? ι.replace(/\n$/,'').replace(/\n/g,'\\n') : ι.replace(/\{/g,'[').replace(/\}/g,']')}).join(''))} catch (e) {↩ {error:ι}}} // based on https://github.com/FWeinb/node-osascript/blob/master/lib/osa-parser.peg
	↩ osa_parse_array(execᵥ('osascript -ss -e '+sh_encode(ι)))}

c_js ← λ(osaₓ,ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ osaₓ('tell app "google chrome" to tell '+tab+' of window 1 to set URL to '+osa_encode('javascript:'+ζ_compile(ι)))}
c_js_sandbox ← λ(ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ JSON.parse(osaᵥ('tell app "google chrome" to execute window 1\'s '+tab+' javascript '+osa_encode(ι))||'""')}
jquery_script ← λ(extra){↩ "t ← document.createElement('script'); t.src = 'https://code.jquery.com/jquery-2.1.4.min.js'; "+(extra||"")+"; document.getElementsByTagName('head')[0].appendChild(t)"}
// E.chrome_js_sandboxᵥ = λ(ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'; ↩ osaᵥ('tell app "google chrome" to execute window 1\'s '+tab+' javascript '+osa_encode(ζ_compile(ι)))}
E.chrome_js = λ(ι,tab){c_js(osa,ι+'; undefined',tab)}
E.chrome_jsᵥ = λ(ι,tab){c_js(osaᵥ,"t ← document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); ι ← eval("+JSON.stringify(ζ_compile(ι))+"); t ← document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(ι); t2 ← document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); undefined",tab); ↩ c_js_sandbox("document.querySelectorAll('#applescript_hack')[0].textContent",tab)}
E.chrome_$ = λ(ι,tab){chrome_js("f ← λ(){"+ι+"}; if (window.jQuery) f(); else {"+jquery_script("t.onload = f")+"}",tab)}
E.chrome_$ᵥ = λ(ι,tab){r←; $null ← '__$null_'+10..map(ι => rand(/[0-9a-z]/.genex_0())).join(''); fst ← 1; while ((r=chrome_jsᵥ("if (window.jQuery){"+ι+"} else {"+(fst? (fst=0, jquery_script()) : "")+"; '"+$null+"'}",tab))===$null); ↩ r}

E.sublimeᵥ = λ(ι){t ← JSON.parse(fs_ipc.emit(JSON.parse(fs('~/Library/Application Support/Sublime Text 3/Packages/User/external_command.py').$.match(/#↩(.*)/)[1]).PORT,ι)); if (t !== null) ↩ t}

P({
'Function.prototype.P':λ(…a1){ι←@; ↩ λ(…a2){↩ ι.apply(@, a1.concat(a2))}},
'Function.prototype.X' :{get:λ(){ι←@; ↩ λ(a  ){↩ ι.call(@,a  )}}},
'Function.prototype.XX':{get:λ(){ι←@; ↩ λ(a,b){↩ ι.call(@,a,b)}}},
'Number.prototype.map':λ(f){'use strict'; ι←+@; r ← Array(ι); for(i←0;i<ι;i++) r[i] = f(i,i,ι); ↩ r},
'Number.prototype.mapcat':λ(f){↩ @.map(f)._.flatten(true)},
'Array.prototype.mapcat':λ(f){r ← []; for(i←0;i<@.length;i++) {t ← f(@[i],i,@); for (j←0;j<t.length;j++) r.push(t[j])}; ↩ r}, // λ(f){↩ @.map(f)._.flatten(true)}
'Array.prototype.repeat':λ(x){↩ x<=0? [] : x.mapcat(ˣ=> @)},
// 'Function.prototype.inspect':λ(rec,ctx){t ← ζ_compile['⁻¹'](@+'').replace(/^λ \(/,'λ(').match(/^.*?\)/); ↩ ctx.stylize('['+(t?t[0]:'λ ?(?)')+']', 'special')},
'Object.prototype._':{get:λ(){↩ _(@)}},
// 'String.prototype.::-1':{get:λ(){↩ (@+'').split('').reverse().join('')}},
// 'Array.prototype.::-1':{get:λ(){↩ @._.clone().reverse()}},
'Buffer.prototype.partition':λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r},
'Array.prototype.partition': λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r},
'String.prototype.partition':λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r},
// 'Buffer.prototype.inspect':λ ρ(){↩ ρ.super.call(@).replace(/(^<\w+)/,'$1['+@.length+']')},
'RegExp.prototype.genex_0':λ(){
	parse ← λ(ι){
		q ← λ(ι){↩ ι.match(/\(.*?\)|\[.*?\]|\\.|./g).map(λ(ι){↩ ι[0]==='('? q(ι.slice(1,-1)) : ι[0]==='['? {or:ι.slice(1,-1).match(/.-.|./g).mapcat(ι => ι.length === 1? [ι] : _.range(ι[0].charCodeAt(0),ι[2].charCodeAt(0)+1).map(String.fromCharCode.X))} : ι})}
		w ← λ(ι){if (!_.isArray(ι)) ↩ ι; t←; r ← []; while ((t=ι._.indexOf('|')) !== -1) {r.push(ι.slice(0,t)); ι = ι.slice(t+1)}; ↩ r.length? (r.push(ι),{or:r}) : ι.map(w)}
		↩ w(q(ι))}
	q ← ι => ι.or? ι.or.map(q) : _.isArray(ι)? ι.map(q).reduce((a,b) => a.mapcat(a => b.map(b => a+b)),['']) : [ι]
	↩ q(parse(@.source)) },
'Function.prototype.in':λ(time){↩ !time || time <= 0? setImmediate(@) : setTimeout(@,time*1000)},
'Function.prototype.every':λ(time){↩ setInterval(@,time*1000)},
'Function.prototype.at':lazy('at',λ(){
	// https://github.com/Automattic/kue
	// https://github.com/rschmukler/agenda
	// robust to setTimeout taking extra time
	qu ← new ˡ.priorityqueuejs(λ(a,b){↩ b.time-a.time}); P←;
	ensure ← λ(){if (P) ↩; P = true; (λ poll(){
		t←; qu.size() === 0? (P = false) : qu.peek().time < hrtime()? (t=qu.deq(), t.ι&&t.ι.in(), poll()) : poll.in(0.1)
		})() }
	↩ λ(time){t ← {time, ι:@}; ↩ time < hrtime()? (t.ι.in(), {clear:λ(){}}) : (qu.enq(t), ensure(), {clear:λ(){t.ι = null}})} }),
'stream.Readable.prototype.read_all':λ(cb){t ← []; @.resume().on('data',λ(ι){t.push(ι)}).on('end',λ(){cb(null,Buffer.concat(t))})},
})
P(/(Array|String|Buffer).prototype.-[01234]/.genex_0().map(λ(ι){i ← parseInt(ι[ι.length-1]); ↩ [ι, {get:λ(){↩ @.length<i? undefined : @[@.length-i]}, set:λ(ι){↩ @.length<i? ι : (@[@.length-i] = ι)}}]}))

def_lazy(E,'fs',λ(){t ← λ(path_){↩ new ˡ.Path(path_)}; Object.setPrototypeOf(t,require('fs')); ↩ t})
def_lazy(ˡ,'Path',λ(){
	// a file is a key-value pair in a sort of fuzzy-keyed dict with many types, but primarily "key array" and "byte array, usually interpreted as string"
	// represented as a Path, it has properties path_ and $/val/value/deref
	// a Path is normally just a fluent wrapper but can become a file descriptor holder or an event manager
	// maybe we can also pass it a type/format/view/mixin! eesh, maybe we need to fit it into the prototype system instead of just using a mixin...
	Path ← λ Path(path_){
		@.path_ = path_ instanceof Path? path_.path : path_.replace(/^~(?=\/|$)/,process.env.HOME)
		@.path = path_ instanceof Path? path_.path : path.normalize(@.path_+'/.')
		}
	def(Path.prototype,'$',λ(){↩ @._$()}, λ(ι){↩ @['='](ι)})
	// path_ manipulation
	Path.prototype.dir = λ(){try{↩ fs.statSync(@.path).isDirectory()} catch(e){if (!(e.code==='ENOENT')) throw e; ↩ false}}
	Path.prototype.exists = λ(){try {fs.statSync(@.path); ↩ true} catch(e){↩ false}}
	Path.prototype.resolve = λ(){↩ path.resolve(@.path)}
	Path.prototype.name = λ(ext){↩ path.basename(@.path,ext)}
	Path.prototype.parent = λ(){↩ path.dirname(@.path)}
	// find
		// it's really weird how this returns a thing that you can't actually pass to fs()
		// maybe we'll fix this by returning a more magical, jquery-like thing?
	// misc
	Path.prototype.toString = λ(){↩ path.resolve(@.path).replace(RegExp('^'+regex_encode(process.env.HOME)+'(?=/|$)'),'~')}
	// content manipulation
	Path.prototype._$ = λ(){t ← @.path; ↩ !@.exists()? '' : @.dir()? (console.trace('[ζ] DEPRECATED dir_$'), fs.readdirSync(t).map(λ(ι){↩ t+'/'+ι})) : fs.readFileSync(t)+''}
	Path.prototype['='] = λ(ι){
		// string: text file, Array: directory, etc
		// async should use like fs.createReadStream(ι.path).pipe(fs.createWriteStream(@.path))
		if (@.exists() && @.dir()) throw Error('writing to directories not implemented')
		if (ι == null) {@.exists() && fs.unlinkSync(@.path); ↩}
		mkdir_p ← λ ρ(ι){try {fs.statSync(ι).isDirectory() || fs.mkdirSync(ι)} catch (e) {if (e.code !== 'ENOENT') throw e; ρ(path.dirname(ι)); fs.mkdirSync(ι)}}
		mkdir_p(path.resolve(path.dirname(@.path)))
		fs.writeFileSync(@.path,ι) }
	↩ Path })
def_lazy(E,'φ',λ(){
	//! needs to handle things like ${child}*
	//! needs to handle things like {,foo,bar}
	//! dedup all globs, existence_matching or no (including parent-ness (slightly weird with symlinking))
	//! make it more jquery-like, so that when it returns an array the elements of the array are literally just strings

	walk ← λ*(root,files){root += '/'
		walk_ ← λ*(ι){try {l ← fs.readdirSync(root+ι); for (i←0;i<l.length;i++){t ← ι+l[i]; try {fs.lstatSync(fs(root+t).path).isDirectory()? (yield root+t, yield* walk_(t+'/')) : (files && (yield root+t))} catch (e) {}}} catch (e) {}}
		yield* walk_('') }
	existsSync ← λ(ι){try {fs.statSync(ι); ↩ true} catch(e){↩ false}}
	mkdir_p ← λ Λ(ι){try {fs.statSync(ι).isDirectory() || fs.mkdirSync(ι)} catch (e) {t ← path.dirname(ι); if (e.code !== 'ENOENT' || ι===t) throw e; Λ(t); fs.mkdirSync(ι)}}
	Φ ← λ(ι){↩ new _Φ(ι)}; _Φ ← λ Φ(ι){@.ι = ι}; _Φ.prototype = {
		exists:λ(){try {fs.statSync(@.ι); ↩ true} catch(e){↩ false}},
		dir:λ(){try{↩ fs.statSync(@.ι).isDirectory()} catch(e){↩ false}},
		resolve:λ(){↩ path.resolve(@.ι)},
		name:λ(ext){↩ path.basename(@.ι,ext)},
		parent:λ(){↩ path.dirname(@.ι)},
		get:λ(){↩ fs.readFileSync(@.ι)+''},
		set:λ(){if (@.dir()) throw Error(); if (ι == null) @.exists() && fs.unlinkSync(@.ι); else {mkdir_p(path.resolve(path.dirname(@.ι))); fs.writeFileSync(@.ι,ι)}},
		toString:λ(){↩ @.ι},
		pretty:λ(){↩ @.ι.replace(RegExp('^'+regex_encode(process.env.HOME)+'(?=/|$)'),'~')},
		inspect:λ(ˣ,opts){↩ opts.stylize('φ','special')+util.inspect(@.ι,opts)},
		get url(){↩ encodeURI('file:'+@.resolve())},
		}

	↩ λ(ss,…ιs){
	if (ιs.length===0 && ss instanceof _Φ) ↩ ss
	if (ιs.length===0 && typeof(ss)==='string') ↩ Φ(ss)
	existence_matching ← /\*/.test(ss.join(''))
	option_globbing ← /\{[^}]*?,/.test(ss.join(''))

	ι ← simple_template(ss,ιs)
	if (ι._.isEqual(['~'])) ι = [process.env.HOME]; else {t ← (ι[0].raw||ι[0]).replace(/^~(?=\/)/,process.env.HOME); ι[0].raw? (ι[0].raw = t) : (ι[0] = t)}
	if (existence_matching || option_globbing) {
		ι = ι.mapcat(ι => ι.raw? [ι] : ι.match(/\/|\*\*(?:\/|$)|[^\/]+/g)||[])
		r ← ['']; ι.forEach(λ(ι){
			if (ι==='..*') r = r.mapcat(ι => […(λ*(){if (!path.isAbsolute(ι)) {for(;;){yield ι; if (ι==='.') break; ι = path.dirname(ι)}; ι = path.resolve(ι); if (ι==='/') ↩}; for(;;){yield ι; if (ι==='/') break; ι = path.dirname(ι)}})()])
			else if (ι==='**') r = r.mapcat(ι => […walk(ι, true)])
			else if (ι==='**/') r = r.mapcat(ι => […walk(ι, false)].map(ι => ι+'/'))
			else if (!ι.raw && ι.includes('*')) r = r.mapcat(r => fs.readdirSync(r).filter(RegExp('^'+ι.replace(/\*|[^*]+/g, ι => ι==='*'? '[\\s\\S]*' : regex_encode(ι))+'$').λ).map(ι => r+'/'+ι))
			else r = r.map(ι.raw? (t => t+ι.raw) : (t => t+ι))
			})
		r = r.map(path.normalize.X)
		if (existence_matching) r = r.filter(existsSync)
		↩ r.map(Φ)}
	else ↩ Φ(ι.map(ι => ι.raw || ι).join(''))
	} })


require.extensions['.ζ'] = λ(module,ι){module._compile(ζ_compile(fs.readFileSync(ι,'utf8').replace(/^((?:#!.*\n)?)/,'$1require = _require_lazy(require);')),ι)}

// ---- things that are more “dotfile” or “library of their own” than “ζ” --- //
E.email = λ(){
	sb().split(/\n{3,}/g).map(λ(ι){var [a,b,…c] = ι.split('\n'); c = c.join('\n'); ↩ ('mailto:'+a+'?subject='+b+'&body='+c).replace(/\n/g,'%0A')})
		.map(ι => osaᵥ('tell app "chrome" to open location '+osa_encode(ι)))
	osaᵥ('tell app "chrome" to activate') }
E.urijs = ˡ.urijs
E.nice_url = λ(ι){t←; urijs ← ˡ.urijs; var {sourcemap} = ι; ι=ι+''
	if (t=/^"(.*)"$/.λ(ι)) ↩ '“'+t[1]+'”' //! bad hack

	apply_regexes ← regs => multiline(regs).split(/\n/g).map(λ(t){var [a,b] = t.split(/  +/g); ι = ι.replace(RegExp(a),b)})
	URL ← /\b(?:https?:\/\/|(?:file|mailto):)(?:[^\s“”"<>]*\([^\s“”"<>]*\))?(?:[^\s“”"<>]*[^\s“”"<>)\]}⟩?!,.:;])?/g
	parse_alicetext ← ι => _.zip(ι.split(URL).map(ι => ({type:'text', ι})), (ι.match(URL)||[]).map(ι => ({type:'url', ι})))._.flatten(true).filter(ι => !(ι === undefined || (ι.type === 'text' && ι.ι === '')))

	// ι = parse_alicetext(ι).map(λ(ι){t←; ι.type==='url' && (t=urijs(ι.ι)).domain()+t.path()==='google.com/webhp' && t.path('/search') && (ι.ι = t+''); ↩ ι})._.map('ι').join('')

	if (sourcemap && sourcemap.title && sourcemap.url && (t=urijs(ι.slice(…sourcemap.url)),
		t.domain() in {'github.com':0} ||
		t.domain()+t.path()==='google.com/search'
		)) ι = ι.slice(…sourcemap.url)
	
	ι = ι.replace(/%CE%B6/g,'ζ')
	apply_regexes(λ(){/*
	\bhttps://         http://
	\b(http://)www\.   $1
	\b(http://)(?:mail\.)?(google\.com/mail/)u/0/[?&]?#(?:(?:label|search)/[\w%+]+|\w+)/(\w+)        $1$2#all/$3
	 - Gmail( http://google\.com/mail/)                $1
	 - [\w.]+@gmail\.com( http://google\.com/mail/)    $1
	Fwd: (.* http://google\.com/mail/)                 $1
	\b(http://)en\.(?:m\.)?(wikipedia\.org/)           $1$2
	\b(http://)youtube\.com/watch[?&]v=([\w-_]+)       $1youtu.be/$2
	\b(http://youtu\.be/[\w-_]+)[?&]feature=youtu\.be  $1
	\b(http://youtu\.be/[\w-_]+)&(\S*)$                $1?$2
	 - YouTube( http://youtu\.be/)                     $1
	\b(http://)smile\.(amazon\.com/)                   $1$2
	\b(http://docs\.google\.com/document/d/[\w_-]+)/edit(?:[?&]ts=\w+)?$  $1
	\b(http://docs\.google\.com/spreadsheets/d/[\w_-]+)/edit(?:#gid=0)?$  $1
	 - Google Docs( http://docs\.google\.com/)         $1
	\b(http://dropbox\.com/\S*)[?&]dl=0$               $1
	\b(http://)facebook(\.com/)                        $1fb$2
	\b(http://fb\.com/)profile\.php\?id=               $1
	\(\d+\) (.* http://fb\.com/)                       $1
	 - Wikipedia, the free encyclopedia( http://wikipedia\.org/)  $1
	 - Album on Imgur( http://imgur\.com/)             $1
	 - Google Maps( http://google\.com/maps/)          $1
	*/})

	ι = parse_alicetext(ι).map(λ(ι){t←;
		if (ι.type === 'url') {
			uri ← urijs(ι.ι)
			switch (uri.domain()) { default: ↩ ι
				break; case 'amazon.com':
					uri.removeSearch(['sa-no-redirect','keywords','qid','ie','s','sr','tag','linkCode','camp','creative','creativeASIN'])
					uri.filename().match(/^ref=[\w_]+$/) && uri.filename('')
					if (t=/^\/(?:[\w-]+\/)?(?:dp|gp)\/(?:product\/)?(\w+)\/?$/.λ(uri.resource())) {ι.ι = 'http://amzn.com/'+t[1]; ↩ ι}
				break; case 'fb.com': uri.removeSearch(['fref','hc_location','_rdr','pnref'])
				break; case 'google.com': if (uri.segment()._.isEqual(['search'])) {uri.removeSearch(['gws_rd','aqs','sourceid','es_sm','ie']); uri.hasSearch('q') && uri.removeSearch('oq')}
				}; ι.ι = uri+'' }
		↩ ι})._.map('ι').join('')

	apply_regexes(λ(){/*
	: \d{5,}: Amazon(?:Smile)?: Books( http://amzn.com/)        $1
	*/})

	// --------- todo --------- //
	// http://smile.amazon.com/gp/product/0300078153
	// Seeing like a State http://amzn.com/0300078153

	// https://docs.google.com/spreadsheets/d/1wfFMPo8n_mpcoBCFdsIUUIt7oSm7d__Duex51yejbBQ/edit#gid=0
	// http://goo.gl/0nrUfP

	// generalize the “fix & to ?” to many different things

	// http://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	// A Big Little Idea Called Legibility http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	// http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility
	// http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility (3K words)

	↩ ι}
// sublimeᵥ('window.focus_view(window.views()[-1])')
// T ← 10; i←0; (λ(){sublimeᵥ('view.insert(edit,view.sel()[0].begin(),"\\n")')}).every(T)
// sublime_set_buffer ← λ(ι){sublimeᵥ('view.replace(edit,sublime.Region(0,view.size()),'+util.inspect(ι)+')')}
// braille_table ← 0x100.map(ι => String.fromCharCode('⠀'.charCodeAt(0)+ι))
// braille_2d ← λ(ι){↩ (Buffer.isBuffer(ι.ι)? ι.ι.partition(ι.X) : ι).partition(4).map(λ(ι){t ← []; for(i←0;i<ι[0].length;i+=2) t.push(braille_table[(ι[0][i]<<0)|(ι[1][i]<<1)|(ι[2][i]<<2)|(ι[0][i+1]<<3)|(ι[1][i+1]<<4)|(ι[2][i+1]<<5)|(ι[3][i]<<6)|(ι[3][i+1]<<7)]); ↩ t.join('')}).join('\n')}
// life ← λ(ι){
// 	if (!ι) {ι ← {X:115*2,Y:46*4}; ι.ι = Buffer((ι.X*ι.Y).map(λ(){↩ rand()<0.5 ?1:0})); ↩ ι} // 115,46
// 	else {X ← +ι.X; Y ← +ι.Y; ι = ι.ι
// 		r ← Buffer(ι)
// 		get ← λ(x,y){↩ 0<=x&&x<X && 0<=y&&y<Y? ι[y*X+x] : 0}
// 		for(y←1;y<Y-1;y++) for(x←1;x<X-1;x++) {
// 			n ← ι[(y-1)*X+x-1] + ι[(y-1)*X+x] + ι[(y-1)*X+x+1] + ι[y*X+x-1] + ι[y*X+x+1] + ι[(y+1)*X+x-1] + ι[(y+1)*X+x] + ι[(y+1)*X+x+1]
// 			r[y*X+x] = (n===2? ι[y*X+x] : n===3? 1 : 0) }
// 		for(y←0;y<Y;y+=Y-1) for(x←0;x<X;x++) {
// 			n ← 0; for(xₒ←-1;xₒ<=1;xₒ++) for(yₒ←-1;yₒ<=1;yₒ++) n += get(x+xₒ,y+yₒ)
// 			r[y*X+x] = (n===2? get(x,y) : n===3? 1 : 0) }
// 		for(x←0;x<X;x+=X-1) for(y←1;y<Y-1;y++) {
// 			n ← 0; for(xₒ←-1;xₒ<=1;xₒ++) for(yₒ←-1;yₒ<=1;yₒ++) n += get(x+xₒ,y+yₒ)
// 			r[y*X+x] = (n===2? get(x,y) : n===3? 1 : 0) }
// 		// for(y←0;y<Y;y++) for(x←0;x<X;x++) {
// 		// 	n ← 0; for(yₒ←-1;yₒ<=1;yₒ++) for(xₒ←-1;xₒ<=1;xₒ++) n += get(x+xₒ,y+yₒ)
// 		// 	r[y*X+x] = (n===3? 1 : n===4 && get(x,y)===1? 1 : 0) }
// 		↩ {X,Y,ι:r} } }
// ι←; for(;;) sublime_set_buffer(braille_2d(ι = life(ι)))

;(λ(){t ← require; (λ(){require ← E._require_lazy(t)

def_lazy(E,'async',()=> require('async','1.5.0'))

E.pixels = {}
E.pixels.read = λ(ι,type='rgb',cb){require('get-pixels','3.2.3')(fs(ι).path,λ(e,{data:D,shape:[X,Y,depth],stride}){X|=0;Y|=0
	// maybe just use Symbol.iterator ?
	;(depth === 4 && stride._.isEqual([4,X*4,1])) || (λ(){throw Error()})()
	if      (type==='rgba') ι ← D
	else if (type==='rgb' ) {ι ← Buffer(X*Y*3); pˡ←0; pᵈ←0; for(i←0;i<X*Y;i++) {ι[pˡ++]=D[pᵈ++]; ι[pˡ++]=D[pᵈ++]; ι[pˡ++]=D[pᵈ++]; pᵈ++}}
	else if (type==='grey') {ι ← Buffer(X*Y); for(i←0;i<X*Y;i++) ι[i] = D[i*4]}
	else throw Error()
	cb(e,{X,Y,ι}) }) }
E.pixels.show = λ({ι,X,Y},type='rgb',to){
	t ← new (require('pngjs','2.2.0').PNG)({width:X, height:Y}); D ← t.data; p←0
	if      (type==='rgba') (Buffer.isBuffer(ι)? ι : Buffer(ι)).copy(t.data)
	else if (type==='rgb' ) for(i←0;i<ι.length;) {D[p++] = ι[i++]; D[p++] = ι[i++]; D[p++] = ι[i++]; D[p++] = 0xff}
	else if (type==='grey') for(i←0;i<ι.length;) {D[p++] =         D[p++] =         D[p++] = ι[i++]; D[p++] = 0xff}
	else throw Error()
	t.pack().pipe(fs.createWriteStream(fs(to).path)) }

})()})()

// ----------------------------------- end ---------------------------------- //
E.ζtoken = {}
prop_assign ← λ(from,to){Object.getOwnPropertyNames(from).forEach(ι => Object.defineProperty(to,ι,Object.getOwnPropertyDescriptor(from,ι)))}
prop_assign(E,global)
module.exports = λ(to){to.ζtoken === E.ζtoken || (prop_assign(E,to), patches.forEach(ι => ι(to)))}

// -------------------------------- discarded ------------------------------- //
// E.bit_reverse = λ(length,ι){r ← 0; for (i←0;i<length;i++){r = (r << 1) | (ι & 1); ι = ι >> 1}; ↩ r}
// catch_ ← λ(f){↩ λ(){try {↩ f.apply(@,arguments)} catch (ι) {if (ι.__catchable) ↩ ι.__catchable; else throw ι}}}
// _return ← λ(ι){throw {__catchable:ι}}

// _re ← λ(flags,ι){
// 	mode ← ''; typeof(ι[0])==='string' && (ι[0] = ι[0].replace(/^([s0+*])\//,λ(ˣ,ι){mode = ι; ↩ ''}))
// 	if (mode==='s'){
// 		if (typeof(ι[-1])==='string') {t ← ι[-1].match(/^([\s\S]*)\/([^\/]*)$/); if (!t) throw Error(); ι[-1] = t[1]; to ← t[2] }
// 		else {if (!ι[-2].match(/\/$/)) throw Error(); ι[-2] = ι[-2].slice(0,-1); to ← ι.pop() }
// 		to = typeof(to)==='string'? to : typeof(to.ι)==='function'? to.ι : (()=>to.ι) }
// 	ι = RegExp(ι.map(ι => typeof(ι)==='string'? ι : regex_encode(ι.raw)).join(''), 'u'+(mode===''?'':'g')+flags)
// 	switch(mode){default: throw Error()
// 		case '': case '+': r ← t => t.match(ι)
// 		case '0': r ← t => t===''? [] : t.split(ι)
// 		// case '*': r ← t => _.zip(t.split(ι).map(ι => [ι]), (t.match(ι)||[]))._.flatten(true).filter(ι => !(ι[0]===''))
// 		case 's': r ← t => t.replace(ι,to)
// 		}; r.ι = ι; ↩ r}
// E.re   = simple_template(λ(ι){↩ _re(''  ,ι)})
// E.reᵢ  = simple_template(λ(ι){↩ _re('i' ,ι)})
// E.reₘ  = simple_template(λ(ι){↩ _re('m' ,ι)})
// E.reᵢₘ = simple_template(λ(ι){↩ _re('im',ι)})
// P({ 'String.prototype.re'  : simple_template(λ(ι){↩ _re(''  ,ι)(@)}) })
// P({ 'String.prototype.reᵢ' : simple_template(λ(ι){↩ _re('i' ,ι)(@)}) })
// P({ 'String.prototype.reₘ' : simple_template(λ(ι){↩ _re('m' ,ι)(@)}) })
// P({ 'String.prototype.reᵢₘ': simple_template(λ(ι){↩ _re('im',ι)(@)}) })
