#!/usr/bin/env ζ
// ------------------------ should be in standard lib ----------------------- //
on_off ← λ(){ ons ← []; ↩{ on(ee,m,f){ ee.on(m,f); ons.push([ee,m,f]) }, off(){ ons.map(λ([ee,m,f]){ ee.removeListener(m,f) }); ons = [] } }}

// ----------------------------------- lib ---------------------------------- //
hash ← λ(ι){t ← require('crypto').createHash('sha256'); t.update(ι); ↩ t.digest().toString('hex')}
as_module ← λ(ι){ t ← φ`/tmp/node_${hash(ι)}.js`; t.ι = ι; ↩ t+'' }
eval_in_new_worker ← λ(code){ t ← as_module('require("/usr/local/lib/node_modules/zeta-lang")(global);'+code); ↩ require('child_process').fork(t,[],{silent:true}) }
eval_in_worker ← (λ(){
	busy ← new Set(); free ← new Set()
	process.once('exit',λ(){ […busy,…free].map(ι=> ι.kill()) })
	make ← ()=>(
		cn.log('new worker',Time()),
		eval_in_new_worker('('+λ(){
			wait ← ()=> process.once('message',λ(ι){ ι[0]==='eval' || ‽; (0,eval)(ι[1]) })
			wait()
			process.on('beforeExit',λ(i){ process.send(['*',['pseudo_exit',i],['unbusy']]); process.exitCode = 0; wait() })
			process.on('exit',λ(i){ process.send(['pseudo_exit',i]) })
			}+')()')
		.on('message',λ(ι){ (ι[0]==='*'? ι.slice(1) : [ι]).map(ι=> @.emit(…ι) ) })
		.on('unbusy',λ(){ busy.delete(@); free.add(@) })
		)
	;(λ(){ t ← free.pop(); free._.map(ι => ι.kill()); free = new Set(); t && free.add(t) }).every(10*60)
	cleanup ← λ(){ busy['filter!'](ι=> ι.connected); free['filter!'](ι=> ι.connected); free.size || free.add(make()) }
	↩ λ(code){ cleanup(); t ← free.pop(); free.delete(t); busy.add(t); t.send(['eval',code]); ↩ t }
	})()
procify ← (a,code) => ('a ← '+JSON.stringify(a)+'; on_off ← '+on_off+'; ('+λ(){
	err ← e => (process.stderr.write((e.stack||e)+'\n'), process.exitCode || (process.exitCode = 1))
	var {on,off} = on_off(); on(process,'uncaughtException',λ(e){ err(e); process.exit() }); on(process,'beforeExit',()=> off())
	process.argv = [process.argv[0],…a.argv]; φ.cwd = a.cwd; process.env = a.env; try{ _code }catch(e){ err(e) }
	}+')()').replace('_code',code)

// -------------------------------------------------------------------------- //
new net.Server()
	.listen(+φ`PORT`.text.re`\d+`[0],'localhost',λ(){})
	.on('connection',λ(socket){t←;
		worker←; ended←;
		c_send ← λ(type,ι){ if (ended) ↩; a ← Buffer(4); b ← Buffer(type); c ← Buffer(ι||''); a.writeInt32BE(c.length,0); socket.write(Buffer.concat([a,b,c])) }
		socket.on('end',t=_.once(λ(){ !ended && worker && worker.kill('SIGINT'); ended = true })).on('error',t)
		socket.on('data',catch_(λ(ι){
			if (buf){ ι = Buffer.concat([buf,ι]); buf = null }
			i←0; get ← n => i+n <= ι.length || (buf = ι.slice(i), _↩())
			while(i<ι.length){ get(5); L ← ι.readInt32BE(i); type ← String.fromCharCode(ι[i+4]); get(5+L); on_msg({type, ι:ι.slice(i+=5,i+=L)})}
			})); buf←;
		a ← {argv:[], cwd:'', env:{}}
		on_msg ← λ(ι){switch(ι.type){default: ‽
			break; case 'A': a.argv.push(ι.ι+'')
			break; case 'E': t ← (ι.ι+'').match(/^([^=]*)=(.*)/); a.env[t[1]] = t[2]
			break; case 'D': a.cwd = ι.ι+''
			break; case 'R':
				worker = eval_in_worker(procify(a,'ζ_main()'))
				var {on,off} = on_off()
				;[1,2].map(i=> on(worker.stdio[i],'data',ι=> c_send(i+'',ι)) )
				on(worker,'pseudo_exit',λ(i){ c_send('X',i+''); ended = true; off() })
				// c_send('S')
			break; case 'H': // not sure what this is for
			break; case '0': // c_send('S'); worker.stdin.write(ι.ι)
			break; case '.': // worker.stdin.end()
			}}
		})

// old issue: always eats the entire stdin handed to it instead of only eating it on-demand, because i couldn't figure out how to replace stdin in the worker
// new issue: ignores stdin because it's complicated on the node side
// (old code: fs.fstatSync(0).isFIFO()? read_stdin(t) : t() )

// perf: excellent except mimic.c makes too many calls to `send\(`; to fix, batch the A,E,D,R messages together into an I init message

// --------------------------------- ⋈ todo --------------------------------- //

// #! important features:
// # * hardening against fucking up the pooled process
// # * pool refreshing / management
// # * fast
// # if we go to sleep and the server’s down, then we’ll be waiting, which is why we need server management tools.

// gotta launch the server if it's not launched already; how?
// can we avoid this by keeping the server up forever?

// `ζ` and `kp` are the only uses for stdin; reconsider not having stdin?
