#!/usr/bin/env node

# hey, if you're gonna break this, keep a previous stable version ready this time. weve spent entirely too much time rescuing our configurations.

# odd synonym: k, name(, id)(, i?)

#################################### prelude ###################################
'use strict'; require('module').wrapper[0] += `'use strict';` # enable strict mode everywhere
_ ‚Üê require('underscore') # lodash is better than underscore except for _()
_.mixin({ '<-':Œª(‚Ä¶a){‚Ü© @ .assign (‚Ä¶a) } })
Reflect_ownEntries ‚Üê Œπ=> Reflect.ownKeys(Œπ).map(k=> [k,Œπ[k]])

Œª Descriptor(Œπ){ _(@) <- (Œπ) }
define_properties_in ‚Üê (o,names,Œπ)=>{ t ‚Üê o; for(var k of names.slice(0,-1)) t = (t[k] ||( t[k] = {} )); t[names[names.length-1]] = Œπ ;‚Ü© o }
assign_properties_in ‚Üê (o,Œπ)=>{ Reflect_ownEntries(Object.getOwnPropertyDescriptors(Œπ)).forEach(([k,{value:Œπ}])=> Œπ instanceof Descriptor? def(o,k,Œπ) : assign_properties_in(o[k] ||( o[k] = {} ),Œπ) ) ;‚Ü© o }
# ! does that need Object.getOwnPropertyDescriptors at all?

########################## local metaprogramming utils #########################
properties_tree_formalify ‚Üê Œπ=>
	_(_(Œπ).map((Œπ,names)=> genex_simple(names).map(k=> [k,Œπ]))).flatten(‚úì)
		.reduce((r,[name,Œπ])=> define_properties_in(r,
			name.split('.').map(Œπ=>{t‚Üê; ‚Ü© (t=Œπ.match(/^@@(.*)/))? Symbol[t[1]] : Œπ }),
			new Descriptor( Tfun(Œπ)? { value:Œπ, enumerable:‚úì } : Œπ )
			), {})

# mixin_forever ‚Üê (to,from)=>{}
# mixin_forever_informal ‚Üê (to,from)=>{}
E_ ‚Üê {}
patched ‚Üê new Set([E_,global])
E ‚Üê new Proxy({},{ # exports
	# get(           self,k){  },
	# getOwnPropertyDescriptor()
	set(           self,k,Œπ){ [‚Ä¶patched].forEach(o=> o[k] = Œπ ) ;‚Ü© ‚úì },
  defineProperty(self,k,Œπ){ [‚Ä¶patched].forEach(o=> def(o,k,Œπ) ) ;‚Ü© ‚úì },
	})
assign_properties_in_E_informal ‚Üê Œπ=>{ Œπ = properties_tree_formalify(Œπ); [‚Ä¶patched].forEach(o=> assign_properties_in(o,Œπ)) }
module.exports = to=>{ patched.has(to) || ( cn.log('\x1b[34m[Œ∂]\x1b[0m patching'), cn.log(Error('<stack>').stack), patched.add(to), assign_properties_in(to,E_) ) }

#################################### prelude ###################################
E.O1 = _(Œª(){}) <- ({ prototype:Object.freeze(Object.create(null)) })

E.catch_union = f=>{ try{ r ‚Üê f(); bad ‚Üê T.Error(r); if (!bad) ‚Ü© r }catch(e){ r ‚Üê e; T.Error(r) || ‚ÄΩ ;‚Ü© r }; bad && ‚ÄΩ }
E.catch_Œπ = f=>{ try{ r ‚Üê f(); bad ‚Üê r===‚àÖ; if (!bad) ‚Ü© r }catch(e){}; bad && ‚ÄΩ }
E.catch_ = f=> Œª(){ try{ ‚Ü© f.apply(@,arguments) }catch(e){ if ('__catchable' in e) ‚Ü© e.__catchable; else throw e } }
E.return_ = Œπ=>{ throw {__catchable:Œπ} }

E.T = Œπ=>{ 
	ty ‚Üê typeof Œπ; if (ty!=='object') ‚Ü© ty; if (Œπ===null) ‚Ü© 'null'
	p ‚Üê Object.getPrototypeOf(Œπ); if (p===Object.prototype || p===null) ‚Ü© 'object'
	for (var t of is_l) if (t[1](Œπ)) ‚Ü© t[0]
	‚Ü© 'object' }
b_util ‚Üê catch_Œπ(=> process.binding('util') )
is_l ‚Üê [
	, ['Array',Array.isArray]
	# , ['Error',Œπ=> Object.prototype.toString.call(Œπ)==='[object Error]' || Œπ instanceof Error]
	,‚Ä¶ ['Error','String','Boolean','Number'].map(ty=> [ty,Œπ=> Object.prototype.toString.call(Œπ)==='[object '+ty+']'])
	,‚Ä¶ (!b_util? [] : ['ArrayBuffer','DataView','Date','Map','MapIterator','Promise','RegExp','Set','SetIterator','TypedArray'].map(Œπ=> [Œπ,x=> b_util['is'+Œπ](x)]) )
	]
# would like to be using ‚àà instead
_(T) <- (_(is_l).object(),{
	,symbol: Œπ=> typeof Œπ === 'symbol'
	,boolean: Œπ=> typeof Œπ === 'boolean'
	,string: Œπ=> typeof Œπ === 'string'
	,number: Œπ=> typeof Œπ === 'number'
	,function: Œπ=> typeof Œπ === 'function'
	,primitive: Œπ=>{ switch(typeof(Œπ)){case 'undefined': case 'boolean': case 'number': case 'string': case 'symbol': ‚Ü© ‚úì; case 'object': ‚Ü© Œπ===null; default: ‚Ü© ‚úó} }
	,boxed: Œπ=>{ if (Œπ===null || typeof Œπ!=='object') ‚Ü© ‚úó; t ‚Üê Object.getPrototypeOf(Œπ); t = t.constructor&&t.constructor.name ;‚Ü© (t==='Boolean'||t==='String'||t==='Number') && /^\[object (Boolean|String|Number)\]$/.test(Object.prototype.toString.call(Œπ)) }
	,‚Ñ§: Number.isInteger
	,'-0': Œπ=> Œπ===0 && 1/Œπ < 0
	,NaN: Number.isNaN
	})
_(E) <- ({ Tstr:T.string, Tnum:T.number, Tfun:T.function, Tarr:T.Array, Tprim:T.primitive, Tbox:T.boxed, })
T.primitive.Œπ = new Set(['undefined','boolean','number','string','symbol','null'])
T.boxed.Œπ = new Set(['Boolean','String','Number'])

E.def = (o,name,Œπ)=>{
	Tfun(Œπ) &&( Œπ = lazy(name,Œπ) )
	'configurable' in Œπ ||( Œπ.configurable = ‚úì )
	if( !Œπ.configurable ){ if( 'value' in Œπ ) Œπ.writable = ‚úó }
	else{
		if( 'value' in Œπ ) 'writable' in Œπ ||( Œπ.writable = ‚úì )
		else if( Œπ.writable ){ delete Œπ.writable; Œπ.set && ‚ÄΩ; Œπ.set = Œª(Œπ){ def(@,name,{ value:Œπ, enumerable:‚úì, }) } }
		}
	‚Ü© Object.defineProperty(o,name,Œπ) } # = ‚Ü© o
lazy ‚Üê (name,Œπ)‚áí { writable:‚úì, get(){‚Ü© @[name] = Œπ() } }

/* prefix hook*/ E.êÖ´êÖÆêÖ™êÖ∞êÖÉ = (=>{ anon ‚Üê def({ f:‚àÖ },'Œπ',{ set(Œπ){ @.f(Œπ) } }); ‚Ü© f=>{ anon.f = f; ‚Ü© anon } })()
/*postfix pipe*/ def(Object.prototype,'êÖ≠êÖãêÖÆêÖúêÖã',{ ,enumerable:‚úó ,value:Œª(‚Ä¶f){‚Ü© f.reduce((Œπ,f)=> f(Œπ),@) } })

################################### requires ###################################
;[ ,['events','EventEmitter'],['fs'],['http'],['https'],['module','Module'],['net'],['os'],['querystring'],['readline'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['lodash','lo'],['highland','h']
	].map(([Œπ,n])=> def(E, n||Œπ, => require(Œπ)) )
E._ = _
path ‚Üê require('path')
fs ‚Üê require('fs')
def(E,'robot',lazy('robot',=> npm`robotjs@0.4.5` ))
def(E,'require_new',lazy('require_new',=>{ t ‚Üê npm`require-uncached@1.0.3` ;‚Ü© Œπ=> t((Œπ+'').replace(/^\.(?=\/)/,œÜ.cwd)) }))
_.mixin({ isEqual:lo.isEqual })

#################################### Œ∂ infra ###################################
E.Property = Œª(o,name){ ;this.o = o ;this.name = name }
def(Property.prototype,'Œπ',{ get(){‚Ü© @.o[@.name] }, set(Œπ){ @.o[@.name] = Œπ } })
Property.prototype.def = Œª(Œπ){ def(@.o,@.name,Œπ) ;‚Ü© @ }
Property.prototype.delete = Œª(){ delete @.o[@.name] ;‚Ü© @ }
Property.prototype.map! = Œª(f){ @.Œπ = f(@.Œπ,@.name,@.o) ;‚Ü© @ }
def(Property.prototype,'bind',{get(){‚Ü© @.o[@.name].bind(@.o) }})
def(Property.prototype,'‚àÉ',{get(){‚Ü© @.name in @.o }})
# Property.prototype‚Äò.bind <- { ,get(){‚Ü© @.o[@.name].bind(@.o) } }
# ‚Äò. = Property

new Property(eval,'¬∑').def({ enumerable:‚úì, get(){ @(Œ∂_compile(œÜ`/tmp/__¬∑`.text).replace(/^#!.*/,'')) }, })
lazy_fn ‚Üê f=>{t‚Üê; ‚Ü© Œª(){‚Ü© (t||(t=f())).apply(@,arguments) } } # ! slotify and then detect and merge slots

;[#persist_here ~/code/declare/npm]
E.npm = Œπ=>{ Tarr(Œπ) && (Œπ = Œπ[0]); APP ‚Üê '\x1b[34m[npm]\x1b[0m'
	[À£,name,version,sub] ‚Üê Œπ.re`^(.*?)(?:@(.*?))?(/.*)?$`
	abs_name ‚Üê => name+'@'+version
	if (version){
		cache ‚Üê œÜ`~/.npm/${name}/${version}`; final ‚Üê cache.œÜ`/node_modules/${name}`+(sub||'')
		try{ ‚Ü© require(final) }catch(e){ if (!(e.code==="MODULE_NOT_FOUND")) throw e }
		cache.BAD_exists() || sh·µ•`cd ~; npm cache add ${abs_name()}`
		a‚Üê;b‚Üê; (a=cache.œÜ`package.json`).Œπ = {description:'-',repository:1,license:'ISC'}; (b=cache.œÜ`README`).Œπ = ''; sh·µ•`cd ${cache} && npm --cache-min=Infinity i ${abs_name()}`; a.Œπ = b.Œπ = ‚àÖ
		‚Ü© require(final) }
	else {
		sfx`ack`
		version = sh·µ•`npm show ${Œπ} version`+''
		process.stderr.write(APP+' latest: '); process.stdout.write(Œπ.replace(/-/g,'_')+' ‚Üê npm`'+abs_name()+'`'); process.stderr.write('\n')
		} }
E.js_tokenize = code=>{
	tok ‚Üê npm`babylon@6.14.1`.parse(code,{allowReturnOutsideFunction:‚úì}).tokens
	‚Ü© _.zip( tok.map(Œπ=> code.slice(Œπ.start,Œπ.end)), tok.windows(2).map(([a,b])=> code.slice(a.end,b.start) ) )._.flatten(‚úì).filter(Œπ=>Œπ) }
E.uses_this = f=> (f+'').match(/\bthis\b/) && js_tokenize('('+f+')').includes('this')? 'maybe' : ‚úó
E.Œ∂_compile = lazy_fn(=>{ anon_pmcr3‚Üê; anon_x818h‚Üê; anon_t4nzb‚Üê; anon_oenor‚Üê; anon_7cy2u‚Üê; anon_8jlo1‚Üê; anon_cbbhj‚Üê; anon_wg4h5‚Üê; anon_pxt5h‚Üê; anon_xq7qg‚Üê; anon_xzihh‚Üê; anon_q3sot‚Üê; anon_52y2m‚Üê;
	word_extra ‚Üê re`‚ôà-‚ôìüîÖüîÜüîí‚Ä°‚ß´¬ß`
	word ‚Üê re`A-Za-z0-9_$ ∞- ∏À°-À£Œë-Œ°Œ£-œâ·¥¨-·µõ·µ¢-·µ•·∂ú·∂†·∂ª‚Å∞‚Å±‚Åø‚Çê-‚Çì‚Çï-‚Çú‚ÑÇ‚Ñï‚Ñö‚Ñù‚Ñ§‚±º‚±Ω‚öì${word_extra}`
	Œ∂_parse ‚Üê E.Œ∂_parse = (=>{
		P ‚Üê require('./parsimmon2.js')
		ident ‚Üê P(re`(?![0-9])[${word}]+|@`)
		comment ‚Üê re`(//.*|/\*[^]*?(\*/|$)|#[\s#].*)+`
		simple_js ‚Üê P(=> P.alt(
			P(comment).T`comment`,
			P.seq( P('{'), simple_js, P('}') ),
			P.seq( P.alt(
				P(/(['"])(((?!\1)[^\\]|\\.)*?\1)/).T`string`,
				ident,
				P.seq( P('`').T`template`, tmpl_Œπ.many(), P('`').T`template` ),
				P(/[)\]0-9]/)
				), P.alt( P(re`[ \t]*(?!${comment})/`), P.of('') ) ),
			P(/\[#persist_here .*?\]/),
			P(re`/((?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/([a-z]*)`).T`regex`,
			P(re`[^{}/#'"‚Ä¶${'`'})@\[\]${word}]+|[^}]`)
			).many() )
		tmpl_Œπ ‚Üê P.alt( P.seq( P('${').T`template`, simple_js, P('}').T`template` ), P(/(?:\\[^]|(?!`|\$\{)[^])+/).T`template` )
		js_file ‚Üê P.seq( P(/(#!.*\n)?/).T`shebang`, simple_js )
		‚Ü© code=>{
			Œπ ‚Üê js_file.parse(code)._.flatten()
			r ‚Üê []; for(var t of Œπ) t.T? r.push(t) : r[-1]&&r[-1].T? r.push(t) : (r[-1]+=t)
			‚Ü© r } })()
	s_or ‚Üê Œπ=> re`(?:‚Ä¶${Œπ.split(' ').map(Œπ=> re`${Œπ}`.source).join('|')})`
	id_g ‚Üê '|>'
	id_c ‚Üê'filter! map‚Ä¶ map! ‚Åª¬πdeclare_uniq then‚öì ‚Åª¬π ‚à™! ‚à©! -! ?? *? +? ‚à™ ‚à© ‚äï ‚âà ‚Äñ ‚öì -= += Œ†& Œ†| ? * + - & | ‚àÉ ‚àã'
	id_d ‚Üê¬†[ '-0',id_g,id_c ].join(' ')
	Œ∂_compile_nonliteral ‚Üê Œπ=> Œπ
		.replace(/‚úì/g,'true')
		.replace(/‚úó/g,'false')
		.replace(/‚àÖ/g,'undefined')
		.replace(anon_wg4h5||(anon_wg4h5= re`üè∑([${word}]+)(\s*)‚Üê`.g ),(À£,Œπ,s)=> js`‚Ä¶${Œπ+s}‚Üê __name(${Œπ}).Œπ=`) # an initial try; probably .name inference needs another form
		.replace(/‚ÄΩ(?=(\(|`)?)/g,(À£,callp)=> `!Œª(‚Ä¶a){throw Error(__err_format(‚Ä¶a))}${callp? `` : `('‚ÄΩ')`}` )
		.replace(anon_x818h||(anon_x818h= re`(\[[${word},‚Ä¶]+\]|\{[${word},:‚Ä¶]+\}|[${word}]+)(\s*)‚Üê(;?)`.g ),(À£,name,ws,end)=> 'var '+name+ws+(end?';':'=') )
		.replace(/Œª(?=\*?(?:[ \t][^\(=‚Üê]*)?\([^\)]*\)[ \t]*\{)/g,'function')
		.replace(anon_oenor||(anon_oenor= re`\.?@@([${word}]+)`.g ),'[Symbol.$1]')
		.replace(anon_t4nzb||(anon_t4nzb= re`\.(${s_or(id_d)})`.g ),(À£,Œπ)=> js`[${Œπ}]`)
		.replace(anon_xzihh||(anon_xzihh= re`(${s_or(id_g)}(?!["']))`.g ),(À£,Œπ)=> js`global[${Œπ}]`)
		.replace(anon_xq7qg||(anon_xq7qg= re`(${s_or(id_c)}):`.g ),(À£,Œπ)=> js`${Œπ}:`)
		.replace(/‚Ä¶/g,'...')
		.replace(/\[(['"])map\.\.\.\1\]/g,'["map‚Ä¶"]') # ! this is going to be really hard to take out
		.replace(/@/g,'this')
		.replace(/‚àû/g,'Infinity')
		.replace(/‚áí(\s*([:{]))?/g,(À£,x,Œπ)=> '=>'+({ ':':'0?0', '{':'0?0:', }[Œπ]||‚ÄΩ)+x )
		.replace(anon_52y2m||(anon_52y2m= re`(^|[^\s\)${word}]\s*)=>`.g ),(À£,t)=> t+'()=>' )
		.replace(/‚Ü© ?/g,'return ')
		.replace(anon_8jlo1||(anon_8jlo1= re`(‚Ä¶${'<-'.split(' ').map(Œπ=> re`${Œπ}`.source).join('|')})`.g ),(À£,Œπ)=> '['+util_inspect_autodepth(Œπ)+']')
		.replace(anon_7cy2u||(anon_7cy2u= re`#swap ([${word}]+) ([${word}]+)`.g ),(À£,a,b)=>{ t ‚Üê 't_'+random_id(9) ;‚Ü© Œ∂_compile_nonliteral(`for(;;){ ${t} ‚Üê ${a}; ${a} = ${b}; ${b} = ${t} ;break}`) }) # why not just [a,b] = [b,a]?
		.replace(/\[#persist_here (.*?)\]/g,(À£,Œπ)=> '('+json2_read+js`)(${json2_show(œÜ(Œπ).buf)})`)
		.replace(/\[#Q/g,'new Property(') # Quote
		.replace(anon_cbbhj||(anon_cbbhj= re`\.(\s*)([${word}]+)(\s*)#Q\]`.g ), `,$1'$2'$3)`)
		.replace(anon_pmcr3||(anon_pmcr3= re`[${word_extra}]+`.g ), unicode_names.X) # ! eventually, remove the thing with two underscores next to each other __
		.replace(/\{,\}/g,'new O1()')
		.replace(/([{([]\s*),/g,'$1')
		.replace(anon_q3sot||(anon_q3sot= re`return\s+var\s+([${word}]+)`.g ), (À£,Œπ)=> `var ${Œπ}; return ${Œπ}`)
	# Œ∂_compile_nonliteral_tree ‚Üê Œπ=>{
	# 	Œπ = Œπ.map‚Ä¶(Œπ=> Œπ.T? [Œπ] : Œπ.split(/(?=[{([\])}])/g).map‚Ä¶(Œπ=> Œπ.match(/^([{([\])}]?)([^]*)$/).slice(1)).filter(Œπ=>Œπ.‚Äñ) )
	# 	@ other_bracket ‚Üê i=>{ at ‚Üê {'[':0,'{':0,'(':0}; dir ‚Üê Œπ[i] in at? 1 : -1; for(;;){ for(var [a,b] of ['[]','()','{}']){ Œπ[i]===a && at[a]++; Œπ[i]===b && at[a]-- }; if( _(at).every(Œπ=>Œπ===0) ) break; i += dir; if (!(0<=i&&i<Œπ.‚Äñ)) ‚Ü©; } ;‚Ü© i }
	# 	‚Ü© Œπ.map(Œπ=> Œπ.T? Œπ.Œπ : Œπ) }
	‚Ü© code=>{
		t ‚Üê code; t = /^(\{|Œª\s*\()/.test(t)? '0?0: '+t : t; if( /^(\{|Œª\s*\()/.test(t) ) t = '0?0: '+t # ! it is a clumsy hack to put this on all of these code paths
		‚Ü© Œ∂_parse(t).map(Œπ‚áí
			: Œπ.T==='comment'? Œπ.Œπ.replace(/^#/,'//')
			: Œπ.T? Œπ.Œπ
			: Œ∂_compile_nonliteral(Œπ)
			).join('') } })
Œ∂_compile.‚Åª¬π = Œπ=> Œπ.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$Œë-Œ°Œ£-Œ©Œ±-œâ]+)(\s*)(=?)|\.\.\./g, (Œπ,name,s,eq)‚áí {'function':'Œª','return':'‚Ü©','this':'@','...':'‚Ä¶'}[Œπ] || (eq==='='? name+s+'‚Üê' : name+s+'‚Üê;') )

# êÖ´êÖÆêÖ™êÖ∞êÖÉ(__name(x)).Œπ = 
# E.__name = name=> Œπ=> def(Œπ,'name',{ value:name })

E.__name = name=> _(Object.create((anon_u5393 ||( anon_u5393 = def({,},'Œπ',{ set(Œπ){ def(Œπ,'name',{ value:@.name }) } }) )))) <- ({name}); anon_u5393‚Üê;
E.__err_format = (‚Ä¶a)=> Error(a.map(Œπ=> Tstr(Œπ)? Œπ : util_inspect_autodepth(Œπ)).join(' '))

if( require.extensions && !require.extensions['.Œ∂'] )(=>{
	require.extensions['.Œ∂'] = (module,Œπ)=> module._compile(Œ∂_compile(fs.readFileSync(Œπ,'utf8')),Œπ)
	super_ ‚Üê require.extensions['.js']; require.extensions['.js'] = (module,Œπ)=>{ (path.extname(Œπ)==='' && fs.readFileSync(Œπ,'utf8').re`#!/usr/bin/env Œ∂\s`? require.extensions['.Œ∂'] : super_)(module,Œπ) }
	})()

#################################### prelude ###################################
E.protos = Œª*(Œπ){ for(;!( Œπ===null || Œπ===undefined ); Œπ = Object.getPrototypeOf(Œπ)) yield Œπ }
E.|> = Œπ=> (‚Ä¶f)=> f.reduce((Œπ,f)=> f(Œπ),Œπ)
E.simple_hash_str = Œπ‚áí
	: Tfun(Œπ)? T(Œπ)+Œπ
	: JSON.stringify(Œπ, (k,Œπ)=>{ if (Tprim(Œπ)||Tarr(Œπ)) ‚Ü© Œπ; else{ r‚Üê{,}; _(Œπ).keys().sort().forEach(k=> r[k]=Œπ[k]) ;‚Ü© r } })
E.fromUInt32BE = Œπ=>{ t ‚Üê Buffer.alloc(4); t.writeUIntBE(Œπ,0,4) ;‚Ü© t }
E.b36 = Œπ=> npm`base-x@1.0.4`([‚Ä¶/[0-9a-z]/].join('')).encode(Œπ).replace(/^0+(?!$)/,'')
E.simple_hash = Œπ=> b36( require('crypto').createHash('sha256').update(simple_hash_str(Œπ)).digest() )
memo_frp ‚Üê (names,within,f)=>{
	dir ‚Üê œÜ`~/.memo_frp/${names}`
	if( within ){
		try{ t ‚Üê fs.readdirSync(dir+'') }catch(e){ if (!(e.code==='ENOENT')) throw e; t ‚Üê [] }
		now ‚Üê Time().i; t = t.sort().filter(Œπ=> Time(Œπ.re`^\S+`[0]).i >= now - within )[-1]
		if( t ) ‚Ü© dir.œÜ(t).json2.Œπ }
	a ‚Üê Time().iso; Œπ ‚Üê f(); b ‚Üê Time().iso
	dir.œÜ`${a} ${random_id(10)}`.json2 = { ,names ,date:[a,b] ,Œπ } ;‚Ü© Œπ }
E.memoize_persist = f=>{
	store ‚Üê œÜ`/tmp/Œ∂persist_${simple_hash(f)}`; store_Œπ ‚Üê store.json||{,}
	‚Ü© (‚Ä¶a)=>{ t ‚Üê new Property(store_Œπ,simple_hash(a)) ;‚Ü© t.‚àÉ? t.Œπ : ( t.Œπ = f(‚Ä¶a), store.json = store_Œπ, store_Œπ = store.json, t.Œπ ) } }
# frp will remove the last use(s) of slot_persist
E.slot_persist = name=>{ o ‚Üê œÜ`/tmp/Œ∂persist_${name}` ;‚Ü© def({name},'Œπ',{get(){‚Ü© o.json },set(Œπ){ o.json = Œπ }}) }
# E.memoize = f=>{ cache ‚Üê new WeakMap() ;‚Ü© _(Œπ=>{ if( cache.has(Œπ) ) ‚Ü© cache.get(Œπ); Tprim(Œπ) && ‚ÄΩ; r ‚Üê f(Œπ); cache.set(Œπ,r) ;‚Ü© r }) <- ({cache}) }

E.unicode_names = Œπ=> [‚Ä¶Œπ].map(memoize_persist(Œπ=>
	(anon_3lsx8||(anon_3lsx8= (=>{
		unicode_data ‚Üê 'Cc Cf Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs'.split(' ').map‚Ä¶(Œπ=> _(npm('unicode@0.6.1/category/'+Œπ)).values() )
		‚Ü© unicode_data.filter(Œπ=> !/^</.test(Œπ.name)).map(Œπ=> [parseInt(Œπ.value,16), '_'+Œπ.name.replace(/[- ]/g,'_').toLowerCase()+'_'])._.object()
		})() ) )[ord(Œπ)]).X).join(''); anon_3lsx8‚Üê;

regex_parse ‚Üê lazy_fn(=>{t‚Üê; # status: output format unrefined
	P ‚Üê require('./parsimmon2.js')
	dehex ‚Üê Œπ=> chr(parseInt(Œπ,16))
	ESCAPE ‚Üê P('\\').then(P.alt( P(/x([0-9a-fA-F]{2})/,1).map(dehex), P(/u\{([0-9a-fA-F]+)\}/,1).map(dehex), P(/u([0-9a-fA-F]{4})/,1).map(dehex), P(/./).map(Œπ=> '.[|^$()*+?{}\\/'.includes(Œπ)? Œπ : P.T('escape',Œπ) ) ))
	s1 ‚Üê P.alt(
		, P(/[^.()[\]^$|\\]/)
		, ESCAPE
		, P`.`.T`any`
		, P`(?:${=>OR_or_SEQ})`
		, P`(?=${=>OR_or_SEQ})`.T`lookahead`
		, P`(?!${=>OR_or_SEQ})`.T`nlookahead`
		, P`(${=>OR_or_SEQ})`.T`capture`
		, P`[${[ /\^?/, ( t= ESCAPE.or(/[^\]]/), P([ t.skip('-'), t ]).or(t) ).many() ]}]`.map(Œπ=> P.T(Œπ[0]? 'nset' : 'set', Œπ[1]))
		)
	TIMES ‚Üê P([ s1, P.alt('*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/,P.of())
		.map(Œπ=> Œπ = !Œπ? Œπ : Œπ==='*'? [0,‚àû] : Œπ==='+'? [1,‚àû] : Œπ==='?'? [0,1] : (=>{ [À£,a,two,b] ‚Üê Œπ.match(/\{([0-9]+)(?:(,)([0-9]*))?\}/) ;‚Ü© [a|0,b? b|0 : two? ‚àû : a|0] })() )
		]).map(([Œπ,for_])=> !for_? Œπ : {T:'times', Œπ, for:for_} )
	s2 ‚Üê P.alt( P('^').T`begin`, P('$').T`end`, TIMES )
	OR_or_SEQ ‚Üê P.sep_by(s2.many().T`seq`, '|').map(Œπ=> Œπ.‚Äñ > 1? P.T('or',Œπ) : Œπ[0])
	# t1 ‚Üê regex_parse(/^(foo)(?:bep){2,7}\baz(?:\\b.ar|[a-c-e()}][^\s]|b|baz(?=gremlin)(?!groblem)|)*/i)
	‚Ü© Œπ‚áí {Œπ:OR_or_SEQ.parse(Œπ.source), flags:Œπ.flags} })
E.applescript = {
	parse: lazy_fn(=>{
	  P ‚Üê require('./parsimmon2.js')
	  ws ‚Üê Œπ=> ws_.then(Œπ).skip(ws_); ws_ ‚Üê P(/[ \t\n\r]*/)
	  value ‚Üê P(=> P.alt(false_,true_,number,object,array,string,raw) )
	  false_ ‚Üê P('false').map(=> ‚úó)
	  true_ ‚Üê P('true').map(=> ‚úì)
	  number ‚Üê P(/-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][-+]?[0-9]+)?/).map(Œπ=> +Œπ)
	  _member ‚Üê P.seq(P(/[ a-z0-9-]+/i).skip(ws(P(':'))), value)
	  object ‚Üê ws(P('{')).then(P.sep_by(_member,ws(P(',')))).skip(ws(P('}'))).map(Œπ=> Œπ.‚Äñ? _.object(Œπ) : [])
	  array ‚Üê ws(P('{')).then(P.sep_by(value,ws(P(',')))).skip(ws(P('}')))
	  _char ‚Üê P(/[\n\t\x20-\x21\x23-\x5B\x5D-\u{10FFFF}]|\\(["\\\/bfnrt]|u[0-9a-fA-F]{4})/u).map(Œπ=> Œπ[0]!=='\\'? Œπ : {'"':'"','\\':'\\','/':'/',b:'\b',f:'\f',n:'\n',r:'\r',t:'\t'}[Œπ[1]] || chr(parseInt(Œπ.slice(2),16)) )
	  string ‚Üê P('"').then( _char.many().map(Œπ=> Œπ.join('')) ).skip(P('"'))
	  raw ‚Üê P(/[^,}"]+/).or(string.map_js((Œπ,[i0,i1],l)=> l.slice(i0,i1))).many().map(Œπ=>{ Œπ=Œπ.join('') ;‚Ü© Œπ==='missing value'? ‚àÖ : {T:'raw',Œπ} })
	  ‚Ü© Œπ=> Œπ===''? ‚àÖ : ws(value).parse(Œπ) }),
	print: Œπ=> Tnum(Œπ)? Œπ+'' : Tstr(Œπ)? '"'+Œπ.replace(/["\\]/g,'\\$&')+'"' : Tarr(Œπ)? '{'+Œπ.map(applescript.print.X).join(',')+'}' : ‚ÄΩ,
	}
# E.lenient_json_parse = (=>{
# 	P ‚Üê require('./parsimmon2.js')

# 	whitespace ‚Üê P(/\s*/m)
# 	escapes ‚Üê { b:'\b', f:'\f', n:'\n', r:'\r', t:'\t', }
# 	un_escape ‚Üê (str)=> str.replace(/\\(u[0-9a-fA-F]{4}|[^u])/, (À£,escape)=> escape[0]==='u'? chr(parseInt(escape.slice(1),16)) : escapes[escape[0]] || escape[0] )
# 	comma_sep ‚Üê (parser)=> P.sepBy(parser, token(P(',')))
# 	token ‚Üê p=> p.skip(whitespace)

# 	l_null ‚Üê token(P('null')).map(=> null)
# 	l_t ‚Üê token(P('true')).map(=> ‚úì)
# 	l_f ‚Üê token(P('false')).map(=> ‚úó)
# 	l_str ‚Üê token(P(/"((?:\\.|.)*?)"/, 1)).map(un_escape).desc('string')
# 	l_num ‚Üê token(P(/-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/)).map(Number).desc('number')

# 	json ‚Üê P.lazy(=> whitespace.then(P.alt( object, array, l_str, l_num, l_null, l_t, l_f )) )
# 	array ‚Üê token(P('[')).then(comma_sep(json)).skip(token(P(']')))
# 	pair ‚Üê P.seq(l_str.skip(token(P(':'))), json)
# 	object ‚Üê token(P('{')).then(comma_sep(pair)).skip(token(P('}'))).map(Œπ=> _.object(Œπ))
# 	‚Ü© Œπ=> json.parse(Œπ).value })()
E.JSON_pretty = (Œπ,replacer)=>{
	seen ‚Üê []
	T ‚Üê '  ' # tab
	wrap_width ‚Üê 140
	indent_show ‚Üê Œπ=> show(Œπ).replace(/\n/g,'\n'+T)
	show ‚Üê Œπ=>{t‚Üê;
		if (Œπ===‚àÖ||Œπ===null) ‚Ü© 'null'
		replacer && (Œπ = replacer(Œπ))
		while (Œπ.toJSON) Œπ = Œπ.toJSON()
		switch (typeof(Œπ)==='object'? Object.prototype.toString.call(Œπ) : typeof(Œπ)) {
			case 'string': case '[object String]': ‚Ü© JSON.stringify(Œπ)
			case 'boolean': case '[object Boolean]': case 'number': case '[object Number]': ‚Ü© Œπ+''
			case 'function': ‚Ü© 'null'
			default:
				if (seen.indexOf(Œπ) !== -1) throw TypeError('Converting circular structure to JSON')
				seen.push(Œπ)
				if (Tarr(Œπ)) { [a,b] ‚Üê '[]'; Œπ = Œπ.map(indent_show); for (i‚Üê0;i<Œπ.‚Äñ;i++) Œπ[i]===‚àÖ && (Œπ[i] = 'null') }
				else { [a,b] ‚Üê '{}'; Œπ = _(Œπ).pairs().filter(Œπ=> !(Œπ[1]===‚àÖ || Tfun(Œπ[1]))).map(Œπ=> show(Œπ[0])+': '+indent_show(Œπ[1])) }
				seen.pop()
				‚Ü© (t=a+Œπ.join(', ')+b).‚Äñ <= wrap_width? t : a+'\n'+T+Œπ.join(',\n'+T)+'\n'+b
				} }
	‚Ü© show(Œπ) }
genex_simple ‚Üê Œπ=>{ P ‚Üê require('parsimmon')
	unit ‚Üê P.lazy(=> P.alt( P.noneOf('()|'), P.string('(').then(s_or).skip(P.string(')')).map(Œπ‚áí{T:'capture',Œπ}) ) )
	s_or ‚Üê P.sepBy(unit.many(),P.string('|')).map(Œπ=> Œπ.length > 1? {T:'or',Œπ:Œπ} : Œπ[0])
	Œõ ‚Üê Œπ=> Œπ.T==='or'? Œπ.Œπ.map(Œõ) : Œπ.T==='capture'? Œõ(Œπ.Œπ) : Tarr(Œπ)? cartesian_str(Œπ.map(Œõ)) : [Œπ]
	‚Ü© Œõ(P.alt( P.string('|'), unit ).many().parse(Œπ).value) }
genex ‚Üê Œª Œõ(Œπ){‚Ü©0,
	Tstr(Œπ)? [Œπ] :
	Œπ.flags!==‚àÖ?( Œπ.flags.replace(/u/,'') && ‚ÄΩ, Œõ(Œπ.Œπ) ):
	Œπ.T==='capture'? Œõ(Œπ.Œπ) :
	Œπ.T==='escape'? ‚ÄΩ :
	Œπ.T==='or'? Œπ.Œπ.map‚Ä¶(Œõ) :
	Œπ.T==='seq'? cartesian_str(Œπ.Œπ.map(Œõ)) :
	# Œπ.T==='times'? # Œõ(Œπ.Œπ).map‚Ä¶(x=> _.range(Œπ.for[0],Œπ.for[1]+1).map(i=> x.repeat(i)) ) :
	# 	Œπs ‚Üê Œõ(Œπ.Œπ)
	Œπ.T==='set'? Œπ.Œπ.map‚Ä¶(Œπ=>
		Tarr(Œπ)? _.range(ord(Œπ[0]),ord(Œπ[1])+1).map(chr) :
		Œπ.T==='escape'? ‚ÄΩ :
			[Œπ] ):
		‚ÄΩ(Œπ) }

_(E) <- (_(Math).pick('abs','ceil','exp','floor','log10','log2','max','min','round','sqrt','cos','sin','tan')); _(E) <- ({ln:Math.log, œÄ:Math.PI, œÑ:Math.PI*2, e:Math.E, '‚çü':Math.log, })
E.multiline = Œª(Œπ){ Œπ = (Œπ+'').split('\n').slice(1,-1); t ‚Üê Œπ.map(Œπ=> Œπ.re`^\t*`[0].‚Äñ)._.min(); Œπ = Œπ.map(Œπ=> Œπ.slice(t)) ;‚Ü© (Œπ[0]==='' && Œπ[-1]===''? Œπ.slice(1,-1) : Œπ).join('\n') }
E.sleep = Œπ=>{ h‚Üê; for(hr‚Üêhrtime(); (h=hrtime(hr)) < Œπ; Œπ-h > 0.03 && (sh·µ•`sleep ${Œπ-h-0.02}`,1)); }
E.bench = (f,opt={,})=>{ var {TH=0.4} = opt
	# ! really should include a confidence interval or smth
	r‚Üê0; I‚Üê1; hr‚Üêhrtime(); R ‚Üê => Unit(hrtime(hr) / r,'s')
	t‚Üêf(); r++
	if( T.Promise(t) ) ‚Ü© Œ†(yes=>{ t.then(Œª Œõ(){ if( hrtime(hr) < TH ){ r++; f().then(Œõ) }else yes(R()) }) })
	else{ for(;hrtime(hr) < TH;){ for(i‚Üê0;i<I;i++) f(); r += I; I = ceil(I*1.5) } ;‚Ü© R() } }
E.bench1 = f=>{ hr ‚Üê hrtime(); f() ;‚Ü© Unit(hrtime(hr),'s') }
E.GET_L = (Œπ,within)=> memo_frp(['GET -L', Œπ+''], within, => sh·µ•`curl -sL ${Œπ}`) # ! some requests have short responses; will need more intelligent caching for those 'cause the filesystem can't take too much
E.random = Œª(Œπ){‚Ü© arguments.length===0? Math.random() : Tnum(Œπ)? random()*Œπ |0 : _.sample(Œπ) }
E.random_id = L=> L.map(=> random(anon_clqkb||(anon_clqkb=[‚Ä¶/[0-9a-z]/]))).join(''); anon_clqkb‚Üê;
random_id.braille = L=> L.map(=> random(anon_8zw5b||(anon_8zw5b= [‚Ä¶re`[‚†Å-‚£ø]`] ))).join(''); anon_8zw5b‚Üê;
random_id.greek = L=> L.map(=> random(anon_j6d9d||(anon_j6d9d= [‚Ä¶'êÖÇêÖÉêÖãêÖúêÖùêÖûêÖ¶êÖ®êÖ©êÖ™êÖ´êÖ¨êÖ≠êÖÆêÖØêÖ∞'] ))).join(''); anon_j6d9d‚Üê;

E.ord = Œπ=> Tnum(Œπ)? Œπ : Œπ.codePointAt()
E.chr = Œπ=> Tstr(Œπ)? Œπ : String.fromCodePoint(Œπ)
process.stdio = [ process.stdin,process.stdout,process.stderr ]
E.‚ôì_on_exits = f=> (anon_gjyfd||(anon_gjyfd= require('signal-exit') ))((i,sig)=>{
	if( i===null ) i = 128+{ ,SIGHUP:1,SIGINT:2,SIGQUIT:3,SIGTRAP:5,SIGABRT:6,SIGIOT:6,SIGSYS:12,SIGALRM:14,SIGTERM:15,SIGXCPU:24,SIGXFSZ:25,SIGVTALRM:26,SIGUSR2:31 }[sig]
	f(i,sig) }); anon_gjyfd‚Üê;
E.pad_r = (Œπ,s)=> [Œπ,s.slice(Œπ.‚Äñ)].fold(Tstr(Œπ)? (a,b)=> a+b : Tarr(Œπ)? (a,b)=> [‚Ä¶a,‚Ä¶b] : ‚ÄΩ)

find_closest_ISU ‚Üê (Œπs,Œπ)=>{ for(i‚Üê0;i<Œπs.‚Äñ;i++) if( Œπ <= Œπs[i] ) ‚Ü© i===0? i : abs(Œπs[i]-Œπ) < abs(Œπs[i-1]-Œπ)? i : i-1 ;‚Ü© Œπs.‚Äñ-1 }
cartesian_str ‚Üê Œπ=> Œπ.reduce((a,b)=>{ r ‚Üê []; a.forEach(a=> b.forEach(b=> r.push(a+b))) ;‚Ü© r }, [''])
E.copy_deep = Œπ‚áí
	: Tprim(Œπ)? Œπ
	: T.Map(Œπ)? new Map(Œπ)
	: T.Set(Œπ)? new Set(Œπ)
	: (=>{
		r ‚Üê new Œπ.constructor()
		for(var k in Œπ) if( Object.prototype.hasOwnProperty.call(Œπ,k) ) r[k] = copy_deep(Œπ[k])
		‚Ü© r })()
E.seq = Œπ=>{ t‚Üê Object.create(seq.prototype); t.Œπ = Œπ ;‚Ü© t }
seq.prototype = {
	,next_Œπ:Œª(){ t ‚Üê¬†@.Œπ; if(! t.next ) t = t.@@iterator() ;‚Ü© t.next().value }
	# ,map(){}
	# ,'map‚Ä¶':Œª(){}
	# ,fold(){}
	# ,repeat(){}
	# ,filter(){}
	# ,clone(){}
	# ,pin(){}
	# ,find_(){}
	# ,slice(){}
	# ,'‚Äñ':Œª(){}
	# ,some(){}
	# ,every(){}
	}
assign_properties_in_E_informal({
,'Object.prototype._':{ writable:‚úì, get(){‚Ü© _(@)}, } # ! remove this
,'(Array|Set|Map).prototype._':{ get(){‚Ü© _(@)} }

,'(Array|Buffer|String|Function).prototype.‚Äñ':{ get(){‚Ü© @.length } }
,'(Set|Map).prototype.‚Äñ':{ get(){‚Ü© @.size } }

# 'Array.prototype.map'
# ,'Buffer.prototype.map':Œª(f){ r ‚Üê Buffer.alloc(@.‚Äñ); for(i‚Üê0;i<@.‚Äñ;i++) r.push(f(@[i])) ;‚Ü© r } does not even work
,'Set.prototype.map':Œª(f){‚Ü© [‚Ä¶@].map(f) }
,'Map.prototype.map':Œª(f){‚Ü© [‚Ä¶@.entries()].map(([i,v])=> f(v,i,@)) }
,'Number.prototype.map':Œª(f){'use strict'; Œπ‚Üê+@; r ‚Üê Array(Œπ); for(i‚Üê0;i<Œπ;i++) r[i] = f(i,i,Œπ) ;‚Ü© r }

,'Array.prototype.map‚Ä¶':Œª(f){ r ‚Üê []; for(i‚Üê0;i<@.‚Äñ;i++){ t ‚Üê f(@[i],i,@); for (j‚Üê0;j<t.‚Äñ;j++) r.push(t[j]) } ;‚Ü© r }
# ,'Buffer.prototype.map‚Ä¶':Œª(f){‚Ü© Buffer.concat(@.map(f)) }
,'(Set|Map|Number).prototype.map‚Ä¶':Œª(f){‚Ü© @.map(f)._.flatten(‚úì) }

,'Array.prototype.fold':Array.prototype.reduce

,'Array.prototype.repeat':Œª(x){‚Ü© x<=0? [] : x.map‚Ä¶(=> @) }
,'Buffer.prototype.repeat':Œª(x){‚Ü© Buffer.concat(x<=0? [] : x.map(=> @)) }

,'Set.prototype.join':Œª(Œπ){‚Ü© [‚Ä¶@].join(Œπ) }

,'(Array|Buffer|String|Set).prototype.count':Œª(){ r ‚Üê new Map(); for (var t of @) r.set(t, (r.has(t)? r.get(t) : 0)+1 ) ;‚Ü© r }
,'(Array|Buffer|String|Set).prototype.group':Œª(f){ f||(f = Œπ=>Œπ); r ‚Üê new Map(); for (var t of @){ t2 ‚Üê¬†f(t); r.set(t2, (r.get(t2)||new Set()).‚à™([t])) } ;‚Ü© r }

,'Map.prototype.zip':Œª(‚Ä¶a){ a.unshift(@); r ‚Üê¬†new Map(); a.forEach((Œπ,i)=> Œπ.forEach((Œπ,k)=>{ t ‚Üê¬†r.get(k) || [‚àÖ].repeat(a.‚Äñ); t[i] = Œπ; r.set(k,t) })) ;‚Ü© r }

,'(Array|Buffer|String).prototype.chunk':Œª(L){‚Ü© _.range(0,@.‚Äñ,L).map(i=> @.slice(i,i+L)) }
,'(Array|Buffer|String).prototype.windows':Œª(L){‚Ü© (@.‚Äñ-L+1).map(i=> @.slice(i,i+L)) }
,'(Array|Buffer|String).prototype.-1':{get(){‚Ü© @.‚Äñ<1? ‚àÖ : @[@.‚Äñ-1] },set(Œπ){ @.‚Äñ<1 || (@[@.‚Äñ-1] = Œπ) }}
,'(Array|Buffer|String).prototype.-2':{get(){‚Ü© @.‚Äñ<2? ‚àÖ : @[@.‚Äñ-2] },set(Œπ){ @.‚Äñ<2 || (@[@.‚Äñ-2] = Œπ) }}
,'(Array|Buffer|String).prototype.-3':{get(){‚Ü© @.‚Äñ<3? ‚àÖ : @[@.‚Äñ-3] },set(Œπ){ @.‚Äñ<3 || (@[@.‚Äñ-3] = Œπ) }}
,'(Array|Buffer|String).prototype.-4':{get(){‚Ü© @.‚Äñ<4? ‚àÖ : @[@.‚Äñ-4] },set(Œπ){ @.‚Äñ<4 || (@[@.‚Äñ-4] = Œπ) }}

,'(Array|Set).prototype.‚à™':Œª(‚Ä¶a){‚Ü© new Set([@,‚Ä¶a].map‚Ä¶(Œπ=> [‚Ä¶Œπ])) }
,'(Array|Set).prototype.‚à©':Œª(‚Ä¶a){ r ‚Üê new Set(@); for(var x of a){ x = T.Set(x)? x : new Set(x); for(var Œπ of r) x.has(Œπ) || r.delete(Œπ) } ;‚Ü© r }
,'(Array|Set).prototype.-':Œª(‚Ä¶a){ r ‚Üê new Set(@); for(var t of a) for(var Œπ of t) r.delete(Œπ) ;‚Ü© r }
,'(Array|Set).prototype.‚äï':Œª(b){a‚Üê@; ‚Ü© a.-(b).‚à™(b.-(a)) }

,'(Set|Map).prototype.filter!':Œª(f){ @.forEach((Œπ,i)=> f(Œπ,i,@) || @.delete(i)) }
,'Set.prototype.pop':Œª(){ t ‚Üê @[0]; @.delete(t) ;‚Ü© t }
,'Set.prototype.0':{get(){‚Ü© seq(@).next_Œπ() }}
,'(Array|Set).prototype.-eq':Œª(‚Ä¶a){ t ‚Üê _([‚Ä¶@]).groupBy(simple_hash_str); a.forEach(Œπ=> Œπ.forEach(Œπ=> delete t[simple_hash_str(Œπ)])) ;‚Ü© _(t).values()._.flatten(‚úì) }

,'Map.prototype.‚Åª¬πdeclare_uniq':{get(){‚Ü© new Map([‚Ä¶@.entries()].map(Œπ=>[Œπ[1],Œπ[0]])) }}
,'Map.prototype.‚Åª¬π':{get(){‚Ü© [‚Ä¶@.keys()].group(Œπ=> @.get(Œπ)) }}

,'Array.prototype.find_':Œª(f){ r‚Üê; if (@.some(Œª(Œπ,i,o){t‚Üê; if( (t= f(Œπ,i,o))!==‚àÖ ){ r = [i,Œπ,t] ;‚Ü© ‚úì } })) ‚Ü© r }
,'Array.prototype.find_index_deep':Œª(f){
	for(i‚Üê0;i<@.‚Äñ;i++){ Œπ ‚Üê @[i]
		if (Tarr(Œπ)){ t ‚Üê Œπ.find_index_deep(f); if (t) ‚Ü© [i,‚Ä¶t] }
		else{ if (f(Œπ)) ‚Ü© [i] }
		} }
,'Array.prototype.Œ†&':{get(){‚Ü© Œ†.&(@) }}
,'Array.prototype.Œ†|':{get(){‚Ü© Œ†.|(@) }}
,'Array.prototype.seq':{get(){ Œ∏ ‚Üê Œª*(){ for(;Œ∏.i<Œ∏.Œπ.‚Äñ;) yield Œ∏.Œπ[Œ∏.i++] }(); _(Œ∏) <- ({ Œπ:@, i:0, clone(){‚Ü© _(@.Œπ.seq) <- (@) } }) ;‚Ü© Œ∏ }}
,'Array.prototype.find_last_index':Œª(f){ for(i‚Üê@.‚Äñ-1;i>=0;i--) if( f(@[i],i,@) ) ‚Ü© i }

# ,'Set.prototype.@@iterator':Set.prototype.values
# ,'Map.prototype.@@iterator':Map.prototype.entries
,'RegExp.prototype.@@iterator':Œª*(){yield* genex(regex_parse(@)) }
,'RegExp.prototype.exec_at':Œª(Œπ,i){ @.lastIndex = i ;‚Ü© @.exec(Œπ) }

,'Promise.prototype.status':{writable:‚úì, get(){ [s,v] ‚Üê b_util.getPromiseDetails(@); r ‚Üê [‚àÖ,‚úì,‚úó][s]; if( r!==‚àÖ ){ [@.status,@.Œπ] = [r,v] ;‚Ü© r } }}
,'Promise.prototype.Œπ':{writable:‚úì, get(){ if( @.status!==‚àÖ ) ‚Ü© @.Œπ }}

,'stream.Readable.prototype.pin':Œª(){‚Ü© Œ†(yes=>{ t ‚Üê []; @.resume(); @.on('data',Œπ=> t.push(Œπ) ).on('end',=> yes(Buffer.concat(t)) ) })}
,'Buffer.prototype.pipe':Œª(to,opt){ t ‚Üê¬†new stream.Duplex(); t.push(@); t.push(null) ;‚Ü© t.pipe(to,opt) }
})

TimerCons ‚Üê Œª(a,b){@.a=a;@.b=b}; TimerCons.prototype = {clear:Œª(){@.a.clear();@.b.clear()}, ref:Œª(){@.a.ref();@.b.ref()}, unref:Œª(){@.a.unref();@.b.unref()}}
E.Œ† = Œπ‚áí
	: !Tfun(Œπ)?( T.Error(Œπ)? Promise.reject(Œπ) : Promise.resolve(Œπ) )
	: /^(yes|\(yes,no\))=>/.test(Œπ+'')? new Promise(Œπ)
	: (=>{ # type union of new.Promise(nodeback) and Promise.resolve(object)
		type ‚Üê '?'
		r ‚Üê (‚Ä¶a)=>{ type==='?' &&( type = 'nodeback' ) ;‚Ü© type==='object'? Œπ(‚Ä¶a) : Œ†((yes,no)=> Œπ(‚Ä¶a,(e,Œπ)=>{ e? no(e) : yes(Œπ) })) }
		for(var name of ['then','catch'])
			r[name] = (‚Ä¶a)=>{ type==='?' &&( type = 'object', Œπ = Promise.resolve(Œπ) ) ;‚Ü© Œπ[name](‚Ä¶a) }
		‚Ü© r })()
Œ†.& = Œπ=> Promise.all(Œπ)
Œ†.| = Œπ=> Promise.race(Œπ)
assign_properties_in_E_informal({
,'Function.prototype.P':Œª(‚Ä¶a){‚Ü© @.bind(‚àÖ,‚Ä¶a) }
,'Function.prototype.X':{get(){‚Ü© Œπ=> @(Œπ) }}
,'Function.prototype.defer':Œª(){‚Ü© setImmediate(@) }
,'Function.prototype.in':Œª(time){‚Ü© setTimeout(@,max(0,time||0)*1e3) }
,'Function.prototype.every':Œª(time,opt){ r ‚Üê setInterval(@,max(0,time)*1e3) ;‚Ü© !(opt&&opt.leading)? r : new TimerCons(@.in(0),r) }
# ,'Function.prototype.Œ†':Œª(){ ... }
})

;[Set,Map].map(Seq=>
	_(Object.getPrototypeOf( new Seq().entries() )) <- ({
		,map(f){‚Ü© [‚Ä¶@].map(f) }
		}) )
t‚Üê; _(Object.getPrototypeOf( (t=setImmediate(=>{}), clearImmediate(t), t) )) <- ({
	,clear(){ clearImmediate(@) }
	,ref(){} ,unref(){}
	})
t‚Üê; _(Object.getPrototypeOf( (t=setTimeout(=>{},0), clearTimeout(t), t) )) <- ({
	,clear(){ @._repeat? clearInterval(@) : clearTimeout(@) }
	})

E.walk = (Œπ,f,k,o)=>( Tprim(Œπ)||_(Œπ).forEach((Œπ,k,o)=> walk(Œπ,f,k,o)), Œπ!==‚àÖ && Œπ!==null && f(Œπ,k,o), Œπ )
E.walk_graph = (Œπ,f,seen=[])=> !( Tprim(Œπ) || seen.includes(Œπ) ) && ( seen.push(Œπ), _(Œπ).forEach(Œπ=> walk_graph(Œπ,f,seen)), seen.pop(), Œπ!==‚àÖ && Œπ!==null && f(Œπ), Œπ )
E.walk_both_obj = (Œπ,f·µÉ,f·µá,fseen,seen=[])=> fseen && seen.includes(Œπ)? fseen(Œπ) : !( Tprim(Œπ) || Tfun(Œπ) || seen.includes(Œπ) ) && ( f·µÉ(Œπ), seen.push(Œπ), _(Œπ).forEach(Œπ=> walk_both_obj(Œπ,f·µÉ,f·µá,fseen,seen)), seen.pop(), f·µá(Œπ), Œπ )
E.walk_fold = (Œπ,f,k,o)=> Tprim(Œπ)? Œπ : Tarr(Œπ)? ( Œπ = Œπ.map((Œπ,k,o)=> walk_fold(Œπ,f,k,o)), f(Œπ,k,o) ) : ( Œπ = _(Œπ).map((Œπ,k,o)=> [k,walk_fold(Œπ,f,k,o)])._.object(), f(Œπ,k,o) )
E.walk_obj_edit = (Œπ,f)=> Tprim(Œπ) || Tfun(Œπ)? Œπ : Tarr(Œπ)? Œπ.map(Œπ=> walk_obj_edit(Œπ,f)) : (=>{ for (var k in Œπ) if (Object.prototype.hasOwnProperty.call(Œπ,k)) Œπ[k] = walk_obj_edit(Œπ[k],f) ;‚Ü© f(Œπ) })()
E.search_obj = (Œπ,f)=>{ r‚Üê[]; walk(Œπ,(Œπ,k,o)=> Œπ!==‚àÖ && Œπ!==null && f(Œπ,k,o) && r.push(Œπ)) ;‚Ü© r }
E.search_graph = (Œπ,f)=>{ r‚Üê[]; walk_graph(Œπ,Œπ=> Œπ!==‚àÖ && Œπ!==null && f(Œπ) && r.push(Œπ)) ;‚Ü© r }
# the right name for walk is going to be along the lines of
# f /@ x       x.map(f)
# f //@ x      postwalk(x,f) # MapAll
# it could be a data structure that you can fmap over

E.hrtime = Œª(Œπ){ t ‚Üê arguments.length===0? process.hrtime() : process.hrtime([Œπ|0,(Œπ-(Œπ|0))*1e9]) ;‚Ü© t[0] + t[1]*1e-9 }
E.Time = Œª(Œπ){ r ‚Üê arguments.length===0? new Date() : Œπ instanceof Date? Œπ : new Date(Tnum(Œπ)? Œπ*1e3 : Œπ); r.toString = Œª(){‚Ü© util.inspect(@) } ;‚Ü© r }
fmt ‚Üê Œª(a,b){ t ‚Üê @.__local? npm`moment@2.18.1`(@).format('YYYY-MM-DD[T]HH:mm:ss.SSS') : @.toISOString(); t = t.slice(a,b); if (!@.__local && b > 10) t += 'Z' ;‚Ü© t }
assign_properties_in_E_informal({
,'Date.prototype.local':{get(){‚Ü© _(new Date(@)) <- ({__local:‚úì})}}
,'Date.prototype.i':{get(){‚Ü© +@ / 1e3}}
,'Date.prototype.ym':      {get(){‚Ü© fmt.call(@,0,'YYYY-MM'.‚Äñ)}}
,'Date.prototype.ymd':     {get(){‚Ü© fmt.call(@,0,'YYYY-MM-DD'.‚Äñ)}}
,'Date.prototype.ymdh':    {get(){‚Ü© fmt.call(@,0,'YYYY-MM-DDTHH'.‚Äñ)}}
,'Date.prototype.ymdhm':   {get(){‚Ü© fmt.call(@,0,'YYYY-MM-DDTHH:mm'.‚Äñ)}}
,'Date.prototype.ymdhms':  {get(){‚Ü© fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss'.‚Äñ)}}
,'Date.prototype.ymdhmss': {get(){‚Ü© fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.‚Äñ)}}
,'Date.prototype.iso':     {get(){‚Ü© fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.‚Äñ)}}
,'Date.prototype.hms':     {get(){‚Ü© fmt.call(@,'YYYY-MM-DDT'.‚Äñ,'YYYY-MM-DDTHH:mm:ss'.‚Äñ)}}
})

E.schema = (=>{
	sc_merge ‚Üê Œª(a,b){ak ‚Üê _.keys(a); bk ‚Üê _.keys(b); bk.-(ak).forEach(k=> a[k] = b[k]); ak.‚à©(bk).forEach(k=> a[k] = !Tprim(a[k])? sc_merge(a[k],b[k]) : !Tprim(b[k])? 'error' : a[k]) ;‚Ü© a }
	‚Ü© Œπ=> T.boolean(Œπ)? ‚úì : Tstr(Œπ)? '' : Tnum(Œπ)? 0 : Tarr(Œπ)? !Œπ.‚Äñ? [] : [Œπ.map(schema).fold(sc_merge)] : _.pairs(Œπ).map(Œπ=> [Œπ[0],schema(Œπ[1])])._.object()
	})()

[#Q E.brightness #Q].def(=>{
	br ‚Üê hs·µ•? {
		get(){‚Ü©Œ†( hs·µ•`hs.brightness.get()`/100 )},
		set(Œπ){‚Ü©Œ†( hs·µ•`hs.brightness.set(${Œπ*100|0})` )},
		} : npm`brightness@3.0.0`
	br.set_overlay = Œπ=> br.set(Œπ > 0.5? (Œπ===1? 1 : Œπ-1/64) : (Œπ===0? 0 : Œπ+1/64)).then(=> robot_key_tap('‚áß‚å•FnF'+(Œπ > 0.5? 2 : 1)) )
	‚Ü© br })

E.os_daemon = (cmd,opt)=>{ cmd+=''; {once} ‚Üê¬†opt||{,}
	job ‚Üê {
		,[once?'RunAtLoad':'KeepAlive']:‚úì
		,Label:`Œ∂.${œÜ(cmd).name}.${simple_hash(cmd).slice(0,8)}`
		,ProgramArguments:['sh','-c',sh`export anon_tns7w=${cmd}; PATH="/usr/local/bin:$PATH"; ${cmd}`]
		,StandardOutPath  :œÜ`~/Library/Caches/Œ∂.logic/${simple_hash(cmd)}.out`.ensure_dir()+''
		,StandardErrorPath:œÜ`~/Library/Caches/Œ∂.logic/${simple_hash(cmd)}.err`.ensure_dir()+''
		}
	job_path ‚Üê¬†œÜ`~/Library/LaunchAgents/${job.Label}.plist`; job_path.BAD_exists() ||( job_path.Œπ = job ); _.isEqual( job_path.plist, job ) || ‚ÄΩ
	‚Ü© { ,cmd ,job_path ,restart(){ t ‚Üê¬†@.job_path; sh·µ•`launchctl unload ${t} &>/dev/null; launchctl load ${t}` } } }
[#Q os_daemon.this #Q].def(=> process.env.anon_tns7w && os_daemon(process.env.anon_tns7w) )

E.if_main_do = f=>{ if( !module.parent ) f(‚Ä¶process.argv.slice(2)) }

E.robot_key_tap = Œπ=> require_new(œÜ`~/code/scratch/keyrc/index.Œ∂`).robot_key_tap(Œπ)
E.KEY_once = (‚Ä¶a)=> require_new(œÜ`~/code/scratch/keyrc/index.Œ∂`).KEY_once(‚Ä¶a)

json_socket ‚Üê¬†socket=>{ anon_ffkit‚Üê; anon_dsm09‚Üê; ‚Ü© {
	,to(Œπ){ t‚Üê; (anon_ffkit||(anon_ffkit=( t= npm`ndjson@1.5.0`.stringify(), t.pipe(socket), t ) )).write(Œπ) }
	,on(f){ (anon_dsm09||(anon_dsm09= socket.pipe(npm`ndjson@1.5.0`.parse()) )).on('data',f) }
	} }
ipc_wait ‚Üê f=>{H‚Üê; (H= new net.Server()).listen(0,'localhost').on('connection',socket=> json_socket(socket).on(_.once(Œπ=>{ socket.destroy(); H.close(); f(Œπ) })) ) ;‚Ü© Œ†(yes=> H.on('listening',yes.P(H)) ) }
E.notify = Œπ=>{ Tstr(Œπ) &&( Œπ = Œπ.re`\n`? Œπ.re`^(.*?)\n([^]*)`.slice(1) : Œπ.re` `? Œπ.re`^(.*?) ([^]*)`.slice(1) : [Œπ] )
	‚Ü© Œ†(yes=> ipc_wait(yes).then(H=>
		hs·µ•`hs.notify.new(
			function(x) x:withdraw(); hs.socket.new():connect('localhost',${H.address().port}):write(hs.json.encode({ at=x:actualDeliveryDate() })..'\n') end
			,{ title=${Œπ[0]}, informativeText=${Œπ[1]||''}, otherButtonTitle='\u{2063}', actionButtonTitle='\u{2063}', }
			):send()`
		) ) }
E.fn_wrap_lits = (eval_,f)=> code=> eval_('('+Œ∂_parse(code+'').map(Œπ=> Œπ.T==='shebang'? '' : Œπ.T==='string'||Œπ.T==='regex'? f(Œπ.Œπ) : Œπ ).join('')+')')

E.normal_PDF = x=>{ Œº ‚Üê 0; œÉ ‚Üê 1; v ‚Üê œÉ**2 ;‚Ü© 1/sqrt(v*œÑ)*exp(-((x-Œº)**2)/(2*v)) }
E.normal_CDF = x=>{ Œº ‚Üê 0; œÉ ‚Üê 1 ;‚Ü© (1 + npm`math-erf@1.0.0`( (x-Œº) / (œÉ*sqrt(2)) ))/2 }
E.invert_specific = f=> fx=>{ t ‚Üê 0; while (f(t) > fx) t+=0.01 ;‚Ü© t }

##################################### .Œ∂rc #####################################
process.env.PATH = ['./node_modules/.bin','/usr/local/bin',‚Ä¶(process.env.PATH||'').split(':'),'.'].‚à™([]).join(':')
E.nice_url = Œª(Œπ){t‚Üê; Uri ‚Üê npm`urijs@1.18.12`; {sourcemap} ‚Üê Œπ; Œπ=Œπ+''
	# very nice google maps urls
	# if url ‚âà google.com/maps/
	# fetch short url:
	# 	# @2016-08-18 wait-click $('#searchbox-hamburger')
	# 	wait-click $('[guidedhelpid="searchbox_hamburger"]')
	# 	wait-click $('[jsaction="settings.share"]')
	# 	wait-check $('#share-short-url')
	# 	t ‚Üê $('.widget-share-link-url').val() wait Œπ=> Œπ.re`^https?://goo.gl/maps/`
	# 	return t
	# 	$('.modal-container').click()
	# wait-check: if not $`${Œπ}:checked`; Œπ.click(); wait for $`${Œπ}:checked`
	# wait-click: wait for Œπ.‚Äñ; Œπ.click()
	# decode: parse curl https://goo.gl/maps/7s6wKcW8zUC2

	if (t=Œπ.re`^"(.*)"$`) ‚Ü© '‚Äú'+t[1]+'‚Äù' # ! bad hack

	apply_regexes ‚Üê regs=> multiline(regs).split(/\n/g).map(Œª(t){ [a,b] ‚Üê t.split(/  +/g); Œπ = Œπ.replace(RegExp(a),b) })
	URL ‚Üê /\b(?:(?:https?|chrome):\/\/|(?:file|mailto):)(?:[^\s‚Äú‚Äù"<>]*\([^\s‚Äú‚Äù"<>]*\))?(?:[^\s‚Äú‚Äù"<>]*[^\s‚Äú‚Äù"<>)\]}‚ü©?!,.:;])?/g
	parse_alicetext ‚Üê Œπ=> _.zip(Œπ.split(URL).map(Œπ‚áí {type:'text', Œπ}), (Œπ.match(URL)||[]).map(Œπ‚áí {type:'url', Œπ}))._.flatten(‚úì).filter(Œπ=> !(Œπ === ‚àÖ || (Œπ.type === 'text' && Œπ.Œπ === '')))

	# Œπ = parse_alicetext(Œπ).map(Œª(Œπ){t‚Üê; Œπ.type==='url' && (t=Uri(Œπ.Œπ)).domain()+t.path()==='google.com/webhp' && t.path('/search') && (Œπ.Œπ = t+'') ;‚Ü© Œπ})._.map('Œπ').join('')

	if (sourcemap && sourcemap.title && sourcemap.url && (t=Uri(Œπ.slice(‚Ä¶sourcemap.url)),
		t.domain() in {'github.com':0} ||
		t.domain()+t.path()==='google.com/search'
		)) Œπ = Œπ.slice(‚Ä¶sourcemap.url)
	
	Œπ = Œπ.replace(/%CE%B6/g,'Œ∂')
	apply_regexes(Œª(){/*
	\bhttps://         http://
	\b(http://)www\.   $1
	\b(http://)(?:mail\.)?(google\.com/mail/)u/0/[?&]?#(?:(?:label|search)/[\w%+]+|\w+)/(\w+)        $1$2#all/$3
	 - Gmail( http://google\.com/mail/)                $1
	 - [\w.]+@gmail\.com( http://google\.com/mail/)    $1
	Fwd: (.* http://google\.com/mail/)                 $1
	\b(http://)en\.(?:m\.)?(wikipedia\.org/)           $1$2
	\b(http://)youtube\.com/watch[?&]v=([\w-_]+)       $1youtu.be/$2
	\b(http://youtu\.be/[\w-_]+)[?&]feature=youtu\.be  $1
	\b(http://youtu\.be/[\w-_]+)&(\S*)$                $1?$2
	 - YouTube( http://youtu\.be/)                     $1
	 \([oO]fficial [vV]ideo\)( http://youtu\.be/)      $1
	\b(http://)smile\.(amazon\.com/)                   $1$2
	\b(http://docs\.google\.com/document/d/[\w_-]+)/edit(?:[?&]ts=\w+)?$  $1
	\b(http://docs\.google\.com/spreadsheets/d/[\w_-]+)/edit(?:#gid=0)?$  $1
	 - Google Docs( http://docs\.google\.com/)         $1
	\b(http://dropbox\.com/\S*)[?&]dl=0$               $1
	\b(http://)facebook(\.com/)                        $1fb$2
	\b(http://fb\.com/)profile\.php\?id=               $1
	\(\d+\) (.* http://fb\.com/)                       $1
	 - Wikipedia, the free encyclopedia( http://wikipedia\.org/)  $1
	 - Album on Imgur( http://imgur\.com/)             $1
	 - Google Maps( http://google\.com/maps/)          $1
	*/})

	Œπ = parse_alicetext(Œπ).map(Œπ=>{t‚Üê;
		if (Œπ.type === 'url') {
			u ‚Üê Uri(Œπ.Œπ)
			switch (u.domain()) { default: ‚Ü© Œπ
				break; case 'amazon.com':
					u.removeSearch(['sa-no-redirect','keywords','qid','ie','s','sr','tag','linkCode','camp','creative','creativeASIN'])
					u.filename().re`^ref=[\w_]+$` && u.filename('')
					if (t=u.resource().re`^/(?:[\w-]+/)?(?:dp|gp)/(?:product/)?(\w+)/?$`) {Œπ.Œπ = 'http://amzn.com/'+t[1] ;‚Ü© Œπ}
				break; case 'fb.com': u.removeSearch(['fref','hc_location','_rdr','pnref'])
				break; case 'google.com': if (u.segment()._.isEqual(['search'])){ u.removeSearch(['gws_rd','aqs','sourceid','es_sm','ie']); u.hasSearch('q') && u.removeSearch('oq') }
				}; Œπ.Œπ = u+'' }
		‚Ü© Œπ}).map(Œπ=>Œπ.Œπ).join('')

	apply_regexes(Œª(){/*
	: \d{5,}: Amazon(?:Smile)?: Books( http://amzn.com/)        $1
	*/})

	Œπ = parse_alicetext(Œπ).map(Œπ=>{t‚Üê;
		if (Œπ.type === 'url') {
			u ‚Üê Uri(Œπ.Œπ)
			if( Œπ.Œπ.re`\)$` && u.hash()==='' ) Œπ.Œπ += '#'
			}
		‚Ü© Œπ}).map(Œπ=>Œπ.Œπ).join('')

	#################################### todo ####################################
	# http://smile.amazon.com/gp/product/0300078153
	# Seeing like a State http://amzn.com/0300078153

	# https://docs.google.com/spreadsheets/d/1wfFMPo8n_mpcoBCFdsIUUIt7oSm7d__Duex51yejbBQ/edit#gid=0
	# http://goo.gl/0nrUfP

	# generalize the ‚Äúfix & to ?‚Äù to many different things

	# http://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	# A Big Little Idea Called Legibility http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	# http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility
	# http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility (3K words)

	# decodeURI('https://www.google.com/search?q=%28cos%28x%29-x%2F%2810*%CF%80%29%29%5E2%2C+cos%28x%29%5E2%2C+2*%28-x%2F%2810*%CF%80%29%29*cos%28x%29%2C+%28-x%2F%2810*%CF%80%29%29%5E2&oq=%28cos%28x%29-x%2F%2810*%CF%80%29%29%5E2%2C+cos%28x%29%5E2%2C+2*%28-x%2F%2810*%CF%80%29%29*cos%28x%29%2C+%28-x%2F%2810*%CF%80%29%29%5E2&gs_l=psy-ab.3...106740.118625.0.119014.18.18.0.0.0.0.163.1395.16j1.17.0....0...1.1.64.psy-ab..2.0.0.9dJSX0MrIe0')
	# https://www.google.com/search?q=(cos(x)-x%2F(10*œÄ))^2%2C+cos(x)^2%2C+2*(-x%2F(10*œÄ))*cos(x)%2C+(-x%2F(10*œÄ))^2&oq=(cos(x)-x%2F(10*œÄ))^2%2C+cos(x)^2%2C+2*(-x%2F(10*œÄ))*cos(x)%2C+(-x%2F(10*œÄ))^2&gs_l=psy-ab.3...106740.118625.0.119014.18.18.0.0.0.0.163.1395.16j1.17.0....0...1.1.64.psy-ab..2.0.0.9dJSX0MrIe0
	# https://www.google.com/search?q=(cos(x)-x%2F(10*œÄ))^2%2C+cos(x)^2%2C+2*(-x%2F(10*œÄ))*cos(x)%2C+(-x%2F(10*œÄ))^2&oq=(cos(x)-x%2F(10*œÄ))^2%2C+cos(x)^2%2C+2*(-x%2F(10*œÄ))*cos(x)%2C+(-x%2F(10*œÄ))^2
	# https://www.google.com/search?q=(cos(x)-x/(10*œÄ))^2,+cos(x)^2,+2*(-x/(10*œÄ))*cos(x),+(-x/(10*œÄ))^2&oq=(cos(x)-x/(10*œÄ))^2,+cos(x)^2,+2*(-x/(10*œÄ))*cos(x),+(-x/(10*œÄ))^2

	‚Ü© Œπ}
E.sfx = Œª(ss,‚Ä¶Œπs){ Œπ ‚Üê ss[0]
	sh‚Çê`afplay ~/code/scratch/dotfiles/${Œπ}.wav`
	if (Œπ==='done' && osa·µ•`get volume settings`['output muted']){ br ‚Üê brightness; br.get().then(old=>{ br.set(0); (=> br.set(old)).in(0.2) }) }
	}
üîÖüîÜ ‚Üê go=>{ Œπs ‚Üê [0,1,2.5,5.5,10,16].map(Œπ=>Œπ/16) ;‚Ü© brightness.get().then(br=> brightness.set_overlay( Œπs[min(max( 0, find_closest_ISU(Œπs,br) + go ), Œπs.‚Äñ-1 )] )) }
E.üîÖ = => üîÖüîÜ(-1)
E.üîÜ = => üîÖüîÜ(1)
E.moon = Œπ=>{ Œπ||(Œπ=Time()); moons ‚Üê [‚Ä¶'üåëüåíüåìüåîüåïüåñüåóüåò'] ;‚Ü© moons[floor((npm`suncalc@1.7.0`.getMoonIllumination(Œπ).phase * moons.‚Äñ + 0.5) % moons.‚Äñ)] }
E.github_url = Œπ=>{
	github_remote_origin ‚Üê file=>{
		Œπ ‚Üê œÜ(file).root('/')
		root ‚Üê Œπ; while( root+''!=='/' && !root.œÜ`.git`.BAD_exists() ) root = root.œÜ`..`
		if( root+''==='/' ) throw _(Error()) <- ({ human:'did not find github remote origin for '+(file||'<anon>') })
		Œπ = (Œπ+'').slice((root+'/').‚Äñ)
		name ‚Üê root.œÜ`.git/config`.ini['remote "origin"'].url.match(/github\.com[:/](.+)\/(.+)\.git/).slice(1).join('/')
		commit ‚Üê¬†/*jet[*/ catch_Œπ(=> root.œÜ`.git/HEAD`.text.trim()==='ref: refs/heads/master' && root.œÜ`.git/refs/heads/master`.text.trim() ) /*]*/ || sh·µ•`cd ${root}; git rev-parse HEAD`+''
		‚Ü© encodeURI('http://github.com/'+name+'/blob/'+commit+'/'+Œπ) }
	[file,h] ‚Üê sb·µ•`view = deserialize(${Œπ}); s = view.sel(); [ view.file_name(), [view.rowcol(Œπ) for Œπ in [s[0].begin(), s[-1].end()]] ]`
	fm ‚Üê Œπ=> 'L'+(Œπ+1)
	‚Ü© github_remote_origin(file||'')+( _.isEqual(h[0],h[1])? '' : '#'+(h[0][0]===h[1][0]? fm(h[0][0]) : fm(h[0][0])+'-'+fm(h[1][0])) ) }
E.go_to = (‚Ä¶a)=>{ # synonyms: go_to, open, search?
	opt ‚Üê !Tprim(a[-1])? a.pop() : {,}
	type ‚Üê a.‚Äñ===1? ‚àÖ : a.shift()
	Œπ ‚Üê a[0]
	{new:new_,focus,in_app,sb_view_file_name} ‚Üê _({new:‚úó, focus:‚úì, in_app:‚àÖ, sb_view_file_name:‚àÖ}) <- (opt)

	is_url ‚Üê Œπ=> Œπ.re`^((https?|chrome-extension)://|file:|mailto:)`
	searchify ‚Üê Œπ=> 'https://www.google.com/search?q='+encodeURIComponent(Œπ)

	in_app && (in_app = in_app.toLowerCase())

	if (!focus) sfx`ack`

	# windows_in_current_space_in_app ‚Üê app=> hs·µ•`hs.fnutils.imap( hs.window.filter.new(false):setAppFilter(${app},{visible=true,currentSpace=true}):getWindows(), function(x) return x:id() end)`
	# apps_with_windows_in_current_space ‚Üê => hs·µ•`hs.fnutils.imap( hs.window.filter.new(false):setAppFilter('default',{visible=true,currentSpace=true}):getWindows(), function(x) return x:application():name() end)`

	############################ go to specific chrome ###########################
	# 	wnd ‚Üê 1
	# 	is_chromeapp_active ‚Üê is_chromeapp_exist && osa·µ•`tell app "System Events"; get name of menu bar items of menu bar 1 of process (name of app ${app}); end tell`[1] !== 'Chrome'
	# 	# System Events got an error: osascript is not allowed assistive access
	# 	# compile_mapping(M('c','; '+js`terminal_do_script(${sh`Œ∂ --fresh ${js`(‚Ä¶${osa_activate_thing·µ•+''})('chrome')`}; exit`})`)).Œπ,
	# 	if (is_chromeapp_active){ osa·µ•`tell app "System Events"; activate app "sublime text"; click menu item ‚Ä¶${Tnum(wnd)? osa`(name of window ${wnd} of a)` : osa`${wnd}`} of menu 1 of menu bar item "Window" of menu bar 1 of process (name of app ${app}); end tell; activate app ${app}` ;‚Ü© }
	#  
	# 	t ‚Üê [2,1]; chrome_simple_js_·µ•(`alert('foo')`,{window:t[0],tab:t[1]})

	if (!type){ !new_ || ‚ÄΩ
		if (!is_url(Œπ)) Œπ = searchify(Œπ)
		if (!in_app && Œπ.re`^file:`){
			file ‚Üê decodeURI(Œπ).replace(re`^file:(//)?`,'')
			if (file[0]!=='/') file = require('path').normalize(require('path').join( œÜ(sb_view_file_name||‚ÄΩ).œÜ`..`+'', file ))
			if (œÜ(file).is_dir) in_app = 'path finder'
			else if (['.pdf','.m4a','.epub','.mobi'].includes(require('path').extname(file)));
			else if (['.png','.jpg'].includes(require('path').extname(file))) in_app = '#ql'
			else in_app = 'sublime text'
			[À£,p,r] ‚Üê decodeURI(Œπ).re`^(.*?:)([^]*)`; Œπ ‚Üê p+r.replace(/[^\/]+/g,encodeURIComponent.X)
			}
		if (in_app==='#ql') sh‚Çê`( &>/dev/null qlmanage -p ${file} &)`
		else{
			in_app ||( in_app = 'chrome' )
			if (in_app==='chrome'){
				t ‚Üê osa·µ•`chrome: URL of tabs of windows`.find_index_deep(t=> t===Œπ); if (t)
					{ [window_,tab] ‚Üê t; osa‚Çê`chrome: set active tab index of window ${window_+1} to ${tab+1}`; osa‚Çê`chrome: activate` ;‚Ü© } }
			if (Œπ.re`^chrome-extension://`) sh·µ•`duti -s com.google.Chrome chrome-extension` # bug workaround
			sh·µ•`open ‚Ä¶${in_app && sh`-b ${|>(in_app)(memoize_persist(Œπ=> catch_Œπ(=> osa·µ•`id of app ${Œπ}`) ))}`} ${!focus && '-g'} ${Œπ}`
			}
		if (focus && in_app==='path finder') osa‚Çê`${in_app}: activate`
		}
	else if (type==='app'){ ( !new_ && focus && !in_app )||‚ÄΩ; app ‚Üê Œπ
		# ! should gather most of this information periodically async & record it. should use FRP.
		hint_screen ‚Üê {'sublime text':2, 'path finder':3, 'github desktop':4}
		isnt_standalone ‚Üê {ibooks:1, preview:1}
		if( app==='chrome' && (sh·µ•`ps -x -o comm`+'').includes('/Chrome Apps.localized/') ){ ['‚åò‚ê£',‚Ä¶'chrome‚Ü©'].map(robot_key_tap) ;‚Ü© }
		hint_screen[app] && robot_key_tap('^'+hint_screen[app])
		isnt_standalone[app]? osa·µ•`${app}: if it is running then; activate; end if` : osa·µ•`${app}: activate`
		}
	else if (type==='screen'){ ( !new_ && focus && !in_app && /^[1-9]$/.test(Œπ+'') )||‚ÄΩ; robot_key_tap('^'+Œπ) }
	else if (type==='path'){ ( !new_ && focus )||‚ÄΩ
		# ! i think this might be a pretty badly designed type
		new_ = ‚úì
		if (Œπ.re`^(?:code|consume|documents|history|notes|pix)/.{1,80}:\d+:`){ !in_app || ‚ÄΩ # ! duplication with munge_stuff.py:FIND_RESULT
			# in_app = 'sublime text'
			[À£,Œπ,line] ‚Üê Œπ.re`^(.+):(\d+):$`
			Œπ = œÜ('~/file/'+Œπ)
			sh·µ•`'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' ${Œπ}:${line}` ;‚Ü© }
		if (in_app==='terminal'){
			here ‚Üê hs·µ•`hs.fnutils.imap( hs.window.filter.new(false):setAppFilter('Terminal',{visible=true,currentSpace=true}):getWindows(), function(x) return x:id() end)`
			unbusy ‚Üê => osa·µ•`terminal: id of windows where busy = false`
			available ‚Üê here.‚à©(unbusy())[0]
			terminal_do_script( sh`cd ${Œπ}; ‚Ä¶${!available && sh.clear}`, osa`‚Ä¶${!!available && osa`in (window 1 whose id = ${available})`}; ‚Ä¶${focus && 'activate'}` ) ;‚Ü© }
		else go_to(encodeURI('file:'+œÜ(Œπ).root('/')),{in_app,focus,sb_view_file_name})
		}
	else ‚ÄΩ }

###### metaprogramming ‚Üí runtime macros built on top of template literals ######
# to design this correctly, (ss,‚Ä¶Œπs) => (s,‚Ä¶a) or maybe (`s${a}`) lol no
# existing semistandard usage is in
# 	im_autowhite
# 	scratch.txt
# 	Œ∂/index.Œ∂
# s is interned, so use it as a memoization key for things
E.is_template = ([ss,‚Ä¶Œπs])=> ss && Tarr(ss.raw) && ss.raw.‚Äñ-1 === Œπs.‚Äñ
tmpl_flatten ‚Üê (raw2,Œπs2)=> _.zip(raw2,Œπs2)._.flatten(‚úì).slice(0,-1).filter(Œπ=> Œπ!=='')
E.simple_template = Œª(ss,Œπs,filter){ is_template([ss,‚Ä¶Œπs]) || ‚ÄΩ
	falsy ‚Üê Œπ=> Œπ===‚àÖ||Œπ===null||Œπ===‚úó
	if( filter && !Tfun(filter) ){ [root,join] ‚Üê filter; filter = Œπ=> Tarr(Œπ)? Œπ.map(Œπ=> root`${Œπ}`).join(join) : falsy(Œπ)? '' : ‚àÖ }
	filter_special ‚Üê Œπ=> falsy(Œπ)? '' : Œπ+''
	Œπ ‚Üê tmpl_flatten( ss.raw.map(Œπ=> Œπ.replace(/\\(?=\$\{|`)/g,'')), Œπs.map(Œπ‚áí{raw:Œπ}) )
	for(i‚Üê0;i<Œπ.‚Äñ-1;i++) if (Tstr(Œπ[i]) && !Tstr(Œπ[i+1])) Œπ[i] = Œπ[i].replace(/‚Ä¶$/,=>{ Œπ[i+1] = filter_special(Œπ[i+1].raw); i++ ;‚Ü© '' })
	filter && (Œπ = Œπ.map(Œª(Œπ){t‚Üê; ‚Ü© Tstr(Œπ)? Œπ : (t=filter(Œπ.raw), t===‚àÖ? Œπ : t) }))
	‚Ü© Œπ}
E.easy_template = (=>{
	read ‚Üê (ss,Œπs)=> tmpl_flatten(ss.raw,Œπs.map(Œπ=>[Œπ]))
	show ‚Üê Œª(Œπ){ raw ‚Üê ['']; Œπs ‚Üê []; Œπ.forEach(Œπ=> Tstr(Œπ)? raw[-1]+=Œπ : (Œπs.push(Œπ), raw.push('')) ) ;‚Ü© [{raw},‚Ä¶Œπs] }
	‚Ü© f=> Œª(ss,‚Ä¶Œπs){‚Ü© f.call(@,read(ss,Œπs),show) }
	})()

E.clipboard = def({,},'Œπ',{ get(){‚Ü© sh·µ•`pbpaste`+'' }, set(Œπ){ sh‚Çê`${sb.encode(Œπ)} |`` pbcopy` }, })
E.sb = Œª self(){‚Ü© self._call() } # let personal concepts use sb as callable
[#Q sb.tab #Q].def({
	get(){
		r ‚Üê sb·µ•`[serialize(Œπ) for Œπ in (Œπ.view() for Œπ in sublime.windows() for Œπ in Œπ.sheets()) if Œπ]`
		r.active = sb·µ•`serialize(sublime.active_window().active_sheet().view())`
		;[‚Ä¶r,r.active].map(Œπ=> Œπ && [#Q Œπ.Œπ #Q].def({ enumerable:‚úó,
			get(){‚Ü© sb·µ•` view = deserialize(${@}); view.substr(Region(0,view.size())) ` },
			set(Œπ){ sb_edit·µ•(@)` view.replace(edit,Region(0,view.size()),${Œπ}) ` },
			}) )
		[#Q r.push #Q].def({ enumerable:‚úó, value:
			Œª(Œπ){ sh‚Çê`${sb.encode(Œπ)} |`` open -a 'Sublime Text.app' -f`; @.‚Äñ = 0; (=> _(@) <- (sb.tab) ).in(0.02) } # ! wtf async/sync mix
			})
		‚Ü© r },
	})

fs_ipc_emit ‚Üê (port,Œπ)=>{ œÜ`/tmp/fs_ipc_${port}`.Œπ = Œπ ;‚Ü© sh·µ•`curl -s -X PUT localhost:${port}`+'' }

E.sb·µ• = Œª(ss,‚Ä¶Œπs){
	ENC ‚Üê JSON.stringify; Œπ ‚Üê simple_template(ss,Œπs).map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw) : Œπ).join('')
	t ‚Üê JSON.parse(fs_ipc_emit(34289,Œπ)); t===null &&( t = ‚àÖ ) ;‚Ü© t }
E.sb_edit·µ• = view=>(ss,‚Ä¶Œπs)=>{ sb·µ•`edit(${view},${py(ss,‚Ä¶Œπs)})` }

# sublime/sb
# 	tab
# 	view

E.re = Œª(ss,‚Ä¶Œπs){
	# would like to embed regex in [] and have that be ok; ie re`[${/[a-z]/}]` = /[a-z]/
	Œπ ‚Üê simple_template(ss,Œπs,[(‚Ä¶a)=>re(‚Ä¶a).source,''])
	ENC ‚Üê Œπ=> T.RegExp(Œπ)? ( Œπ.flags.replace(/[gy]/g,'')==='u' || ‚ÄΩ, Œπ.source ) : (Œπ+'').replace(/([.*+?^${}()\[\]|\\])/g, '\\$1')
	‚Ü© RegExp( Œπ.map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw) : Œπ).join(''), 'u' ) }
assign_properties_in_E_informal({
'RegExp.prototype.Œª':Œª(Œπ){‚Ü© Œπ===‚àÖ || Œπ===null? null : Œπ.match(@) },
'RegExp.prototype.g':{get(){‚Ü© RegExp(@.source,@.flags.replace(/g/,'')+'g') }},
'RegExp.prototype.i':{get(){‚Ü© RegExp(@.source,@.flags.replace(/i/,'')+'i') }},
'RegExp.prototype.m':{get(){‚Ü© RegExp(@.source,@.flags.replace(/m/,'')+'m') }},
'RegExp.prototype.u':{get(){‚Ü© RegExp(@.source,@.flags.replace(/u/,'')+'u') }},
'RegExp.prototype.y':{get(){‚Ü© RegExp(@.source,@.flags.replace(/y/,'')+'y') }},
'String.prototype.re':{get(){‚Ü© (ss,‚Ä¶Œπs)=> @.match(re(ss,‚Ä¶Œπs))}},
})

E.js = E.py = Œª(ss,‚Ä¶Œπs){ ENC ‚Üê JSON.stringify ;‚Ü© simple_template(ss,Œπs).map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw) : Œπ).join('') }

E.sh = Œª(ss,‚Ä¶Œπs){ ENC ‚Üê Œπ=> "'"+(Œπ+'').replace(/'/g,"'\\''")+"'" ;‚Ü© simple_template(ss,Œπs,[sh,' ']).map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw) : Œπ).join('') }
sh.clear = "/usr/bin/clear && printf %s $'\\e[3J'"
ellipsify ‚Üê Œπ=> util_inspect_autodepth(Œπ.slice(0,100))+(Œπ.slice(100).‚Äñ?'‚Ä¶':'')

if_sh_err ‚Üê (name,code,Œπ)=>{ if (Œπ.status!==0) throw _(Error(name+'`'+code+'` ‚Üí status:'+Œπ.status+', stderr:'+ellipsify(Œπ.stderr+''))) <- (_(Œπ).pick('status','stdout','stderr')) }
E.sh·µ• = Œª(ss,‚Ä¶Œπs){ code ‚Üê sh(ss,‚Ä¶Œπs)
	# Œπ ‚Üê process_spawn('/bin/sh',{ ,args:['-c',code] ,‚öì:1 })
	Œπ ‚Üê require('child_process').spawnSync(code,{shell:‚úì})
	if_sh_err('sh·µ•',code,Œπ)
	‚Ü© _(Œπ.stdout) <- ({ toString(‚Ä¶a){ Œπ ‚Üê Buffer.prototype.toString.call(@,‚Ä¶a) ;‚Ü© a.‚Äñ? Œπ : Œπ.replace(/\n$/,'') } }) }
_sh‚Çê ‚Üê (ss,Œπs,opt={,})=>{
	if (ss.‚Äñ===2 && ss[0]==='' && ss[1].re`^ *\|$`){ opt.stdio && ‚ÄΩ; opt.stdio = [œÜ.fd.from(Œπs[0]),'pipe','pipe',] ;‚Ü© sh‚Çê2(opt) }
	else{ code ‚Üê sh(ss,‚Ä¶Œπs)
		# Œπ ‚Üê process_spawn('/bin/sh',_({ ,args:['-c',code] }) <- (opt))
		# Œπ.exit.then(exit=>{ if_sh_err('sh‚Çê',code,_(Œπ) <- ({exit})) })
		Œπ ‚Üê require('child_process').spawn(code,_({shell:‚úì}) <- (_(opt).pick('stdio','detached')))
			.on('exit',Œª(status){ if_sh_err('sh‚Çê',code,_({status}) <- (Œπ)) })
		‚Ü© Œπ } }
E.sh‚Çê = (ss,‚Ä¶Œπs)=> _sh‚Çê(ss,Œπs)
E.sh‚Çê2 = opt=>(ss,‚Ä¶Œπs)=> _sh‚Çê(ss,Œπs,opt)

E.osa = Œª(ss,‚Ä¶Œπs){t‚Üê;
	Œπ ‚Üê simple_template(ss,Œπs)
	# ! this is such a mess
	if (Tstr(Œπ[0]) && (t=Œπ[0].re`^(?!tell )([\w ]+):`)){ Œπ[0] = Œπ[0].slice(t[0].‚Äñ); Œπ = [osa`tell app ${t[1]};`, ‚Ä¶Œπ, '; end tell'] }
	if (!Tstr(Œπ[0]) && Tstr(Œπ[0].raw) && Œπ[0].raw.re`^[\w ]+$` && Tstr(Œπ[1]) && (t=Œπ[1].re`^ *:`)){ Œπ[1] = Œπ[1].slice(t[0].‚Äñ); Œπ = [osa`tell app ${Œπ.shift().raw};`, ‚Ä¶Œπ, '; end tell'] }
	‚Ü© Œπ.map(Œπ=> !Tstr(Œπ)? applescript.print(Œπ.raw) : Œπ.replace(/;/g,'\n') ).join('') }
E.osa·µ• = Œª(ss,‚Ä¶Œπs){ Œπ ‚Üê osa(ss,‚Ä¶Œπs) ;‚Ü© applescript.parse(sh·µ•`osascript -ss -e ${Œπ}`+'') }
E.osa‚Çê = Œª(ss,‚Ä¶Œπs){ Œπ ‚Üê osa(ss,‚Ä¶Œπs); sh‚Çê`osascript -ss -e ${Œπ}` }

E.terminal_do_script = Œª(a,b){ œÜ`/tmp/__¬∑`.Œπ = a; osa·µ•`terminal: do script "¬∑" ‚Ä¶${b}` } # ~/.bashrc.Œ∂ :: E['¬∑']
E.chrome_simple_osa·µ• = (Œπ,{tab,window=0})=> osa·µ•`chrome: execute window ‚Ä¶${window+1}'s tab ‚Ä¶${tab+1} javascript ${Œ∂_compile(Œπ)}`
E.chrome_simple_js_·µ• = (Œπ,{tab,window=0})=> osa·µ•`chrome: tell window ‚Ä¶${window+1}'s tab ‚Ä¶${tab+1} to set URL to ${'javascript:'+Œ∂_compile(Œπ)}`
# E.chrome·µ• = ‚Ä° not actually used ‚Ä° wait, nope, is actually used, but mostly in one-off scripts
	# Œª(Œπ,tab){tab = tab!==‚àÖ? 'tab '+(tab+1) : 'active tab'
	# 	# E.chrome_$·µ• = Œª(Œπ,tab){r‚Üê; $null ‚Üê '__$null_'+random_id(10); fst ‚Üê 1; while ((r=chrome·µ•("if (window.jQuery){"+Œπ+"} else {"+(fst? (fst=0, "t ‚Üê document.createElement('script'); t.src = 'https://code.jquery.com/jquery-3.1.1.min.js'; document.getElementsByTagName('head')[0].appendChild(t)") : "")+"; '"+$null+"'}",tab))===$null) ;‚Ü© r}
	# # probably add a random_id(10) call to '#applescript_hack'
	# 	t ‚Üê "t ‚Üê document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); Œπ ‚Üê (0,eval)("+JSON.stringify(Œ∂_compile(Œπ))+"); t ‚Üê document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(Œπ); t2 ‚Üê document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); ‚àÖ"
	# 	chrome_simple_js_·µ•(t,tab)
	# 	t ‚Üê "document.querySelectorAll('#applescript_hack')[0].textContent"
	# 	‚Ü© JSON.parse(chrome_simple_osa·µ•(t,tab) || '""') }

E.which = _.memoize((‚Ä¶a)=> !is_template(a)? which`${a[0]}` : catch_Œπ(=> sh·µ•`which ‚Ä¶${sh(‚Ä¶a)}`+'')) # ! should use FRP to background-recompute hash values after certain amounts of time and discard hash values after certain amounts of time

[#Q E.hs·µ• #Q].def(=> which('hs') && Œª(ss,‚Ä¶Œπs){
	ENC ‚Üê Œπ=> Tstr(Œπ) || Tnum(Œπ)? JSON.stringify(Œπ) : ‚ÄΩ; Œπ ‚Üê simple_template(ss,Œπs).map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw) : Œπ).join('')
	# t ‚Üê sh·µ•`hs -c ${Œπ}`
	t ‚Üê sh·µ•`/usr/local/bin/hs -c ${Œπ}`
	# t ‚Üê child_ process.spawnSync(which('hs'),['-c',Œπ]).stdout
	t ‚Üê (t+'').split('\n')[-1]; r ‚Üê catch_Œπ(=> JSON.parse(t)[0]) ;‚Ü© r!==‚àÖ?r: t } )

E.ts·µ• = Œª(ss,‚Ä¶Œπs){
	ENC ‚Üê JSON.stringify; Œπ ‚Üê simple_template(ss,Œπs).map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw) : Œπ).join('')
	Œπ = 'require "totalspaces2"; TS = TotalSpaces2; '+Œπ
	PORT = 34290
	R ‚Üê => JSON.parse(fs_ipc_emit(PORT,Œπ))[0]
	launch_serv ‚Üê =>{
		(sh·µ•`gem list`+'').re`(^|\n)totalspaces2 ` || ‚ÄΩ
		t ‚Üê œÜ`/tmp/evalserv_${random_id(9)}.rb`; t.text = String.raw`#!/usr/bin/env ruby
			require "socket"; require "json"
			server = TCPServer.new("localhost",${PORT})
			loop do
			  t = server.accept
			  r = JSON.generate([eval(File.read("/tmp/fs_ipc_#{${PORT}}"))])
			  t.print "HTTP/1.1 200 OK\r\n"+"Content-Type: text/plain\r\n"+"Content-Length: #{r.bytesize}\r\n"+"Connection: close\r\n"+"\r\n"+r
			  t.close
			end`
		sh·µ•`chmod +x ${t}`
		require('child_process').spawn(t,{shell:‚úì,detached:‚úì,stdio:'ignore'}).unref()
		# process_spawn('/bin/sh',{ ,args:['-c',t+''] ,child:‚úó })
		}
	try{ ‚Ü© R() }catch(e){ if( e.status===7 ) launch_serv(); sleep(0.1) ;‚Ü© R() } }

# such hack
json2_read ‚Üê Œπ=>{ r ‚Üê JSON.parse(Œπ); (Œª Œõ(Œπ,k,o){if( Œπ.type==='Buffer' ){
	t ‚Üê 'data' in Œπ || 'utf8' in Œπ? Buffer.from(Œπ.data||Œπ.utf8) : 'base64' in Œπ? Buffer.from(Œπ.base64,'base64') : ‚ÄΩ
	if( o===‚àÖ ) r = t; else o[k] = t
	} else if(! Tprim(Œπ) ) _(Œπ).forEach(Œõ)})(r) ;‚Ü© r }
json2_show ‚Üê Œπ=> JSON_pretty(Œπ,Œª(Œπ){t‚Üê;
	if (Buffer.isBuffer(Œπ)) ‚Ü© Œπ.equals(Buffer.from(t=Œπ+''))? {type:'Buffer', utf8:t} : {type:'Buffer', base64:Œπ.toString('base64')}
	‚Ü© Œπ})

[#Q E.œÜ #Q].def(=>{
	ENC ‚Üê Œπ=> Œπ.re`/`? Œπ.replace(/[\/%]/g, encodeURIComponent.X) : Œπ
	œÜ.‚Åª¬π = Œπ=> /%2F/i.test(Œπ)? Œπ.replace(/%2[F5]/gi, decodeURIComponent.X) : Œπ
	œÜ.fd = {,}; œÜ.fd.from = Œπ=> fs.createReadStream(‚àÖ,{ fd:fs.openSync(_(œÜ`/tmp/${random_id(20)}`) <- ({Œπ}) +'','r') })

	existsSync ‚Üê Œπ=> !T.Error(catch_union(=> fs.accessSync(Œπ)))
	mkdir_p ‚Üê Œª Œõ(Œπ){ try{ fs.mkdirSync(Œπ) }catch(e){ if (e.code==='EEXIST'||e.code==='EISDIR') ‚Ü©; t ‚Üê path.dirname(Œπ); if (e.code!=='ENOENT' || Œπ===t) throw e; Œõ(t); fs.mkdirSync(Œπ) } }
	# walk ‚Üê Œª*(root,files){root += '/'
	# 	walk_ ‚Üê Œª*(Œπ){try {l ‚Üê fs.readdirSync(root+Œπ); for (i‚Üê0;i<l.‚Äñ;i++){t ‚Üê Œπ+l[i]; try{ fs.statSync(root+t).isDirectory()? (yield root+t, yield* walk_(t+'/')) : (files && (yield root+t)) }catch(e){} }} catch(e){} }
	# 	yield* walk_('') }
	read_file ‚Üê Œª(Œπ){ try{‚Ü© fs.readFileSync(Œπ) }catch(e){ if (!(e.code==='ENOENT')) throw e } }
	ensure_exists ‚Üê Œª(Œπ,ifdne){ existsSync(Œπ) || ( mkdir_p(path.resolve(path.dirname(Œπ))), fs.writeFileSync(Œπ,ifdne) ) }
	write_file ‚Üê Œª(Œπ,data){ try{ fs.writeFileSync(Œπ,data) }catch(e){ if (!(e.code==='ENOENT')) throw e; ensure_exists(Œπ,data) } }
	open ‚Üê Œª(Œπ,ifdne,f){
		ensure_exists(Œπ,ifdne); Lc ‚Üê new Œ¶(Œπ).‚Äñ
		fd ‚Üê fs.openSync(Œπ,'r+'); f({
			get L(){‚Ü© Lc},
			read(i,L){t ‚Üê Buffer.allocUnsafe(L); fs.readSync(fd,t,0,L,i) === L || ‚ÄΩ ;‚Ü© t},
			write(Œπ,i){L ‚Üê fs.writeSync(fd,Œπ,i); Lc = max(Lc, L+i)},
			truncate(L){fs.ftruncateSync(fd,L); Lc = min(Lc,L)},
			indexOf_skipping(from,to,step,find,skip){fl‚Üê@
				if (from<0) from += fl.L; if (to<0) to += fl.L; from = min(max(0, from ),fl.L-1); to = min(max(-1, to ),fl.L)
				if (!(step===-1 && from>to)) ‚ÄΩ('TODO')
				d ‚Üê fl.read(to+1,from-to)
				for(i‚Üêfrom;i>to;i+=step) {if (d[i-(to+1)]===find) ‚Ü© i; else if (chr(d[i-(to+1)]).match(skip)); else ‚Ü© ‚àÖ}
				},
			}); fs.closeSync(fd)}
	globmatch ‚Üê (glob,Œπ)=> Œπ.re`^‚Ä¶${_(glob).map(Œπ=> Œπ==='*'? '.*' : re`${Œπ}`.source).join('')}$`
	[#Q œÜ.cwd #Q].def({get(){‚Ü© new Œ¶(process.cwd()) }, set(Œπ){ t ‚Üê œÜ(Œπ+'')._Œπ; mkdir_p(t); process.chdir(t) }})

	normHs ‚Üê Œª(Œπ){if (Œπ._.isEqual(['~'])) ‚Ü© [process.env.HOME]; Tstr(Œπ[0]) && (Œπ[0] = Œπ[0].replace(/^~(?=\/)/,process.env.HOME)) ;‚Ü© Œπ}
	Œª Œ¶(Œπ){@._Œπ = Œπ}; Œ¶.prototype = {
		œÜ,
		toString(){‚Ü© @._Œπ },
		toJSON(){‚Ü© {type:'œÜ', Œπ:@._Œπ} },
		inspect(À£,opts){‚Ü© opts.stylize('œÜ','special')+opts.stylize(util_inspect_autodepth(@._Œπ.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') },
		get nlink(){‚Ü© fs.statSync(@._Œπ).nlink },
		get mtime(){‚Ü© fs.statSync(@._Œπ).mtime },
		get birthtime(){‚Ü© fs.statSync(@._Œπ).birthtime },
		get url(){‚Ü© encodeURI('file:'+@.root('/')) }, # ! should this be part of root
		get is_dir(){‚Ü© !!catch_Œπ(=> fs.statSync(@._Œπ).isDirectory()) },
		get name(){‚Ü© path.basename(@._Œπ) },
		BAD_exists(){‚Ü© existsSync(@._Œπ) },
		TMP_children(){‚Ü© |>(@._Œπ)(Œª Œõ(Œπ){‚Ü© œÜ(Œπ).is_dir? fs.readdirSync(Œπ).map(t=> Œπ+'/'+t).map‚Ä¶(Œõ) : [Œπ] }) },
		TMP_parents(){ r ‚Üê [@.root('/')]; while(r[-1].œÜ`..`+'' !== r[-1]+'') r.push(r[-1].œÜ`..`) ;‚Ü© r.slice(1) },
		root(x){switch(arguments.length){default: ‚ÄΩ
			case 0: ‚Ü© @._Œπ[0]==='/'? '/' : '.'
			case 1: ‚Ü© new Œ¶( x==='/'? path.resolve(@._Œπ) : x==='.'? path.relative(x,@._Œπ) : ‚ÄΩ('not yet implemented: nonstandard roots') )
			}},
		ensure_dir(){ @.œÜ`..`.BAD_exists() || mkdir_p(@.œÜ`..`+'') ;‚Ü© @ },

		# get Œπ(){‚Ü©},
		set Œπ(Œπ){
			if (@.is_dir) ‚ÄΩ('TODO')
			if (Œπ===‚àÖ||Œπ===null){ catch_union(=> fs.unlinkSync(@._Œπ) ) ;‚Ü© }
			e ‚Üê path.extname(@._Œπ)
			if (e==='.csv'){ @.csv = Œπ ;‚Ü© }
			if (e==='.xml'){ @.xml = Œπ ;‚Ü© }
			if (e==='.plist'){ @.plist = Œπ ;‚Ü© }
			Œπ = e==='.json'? JSON_pretty(Œπ) :
				Tstr(Œπ)? Œπ :
				Œπ instanceof Buffer? Œπ :
				JSON_pretty(Œπ)
			write_file(@._Œπ,Œπ) },
		get buf(){‚Ü© read_file(@._Œπ) || Buffer.alloc(0) },
		set buf(Œπ){ write_file(@._Œπ,Œπ) },
		get base64(){‚Ü© Buffer.from(@.text,'base64') },
		# set base64(Œπ){},
		get text(){‚Ü© (read_file(@._Œπ) || '')+'' },
		set text(Œπ){ write_file(@._Œπ,Œπ) },
		get lines(){‚Ü© Œª(‚Ä¶Œπs){
			d ‚Üê ((read_file(@._Œπ)||'\n')+'').replace(/\n$/,'').split('\n')
			if (Œπs.‚Äñ > 1) ‚Ü© Œπs.map(Œπ=> Tnum(Œπ)? d[Œπ] : d.slice(Œπ.re`^(\d+):$`[1]|0).join('\n')+'\n')
			else if (Œπs.‚Äñ === 0){
				‚Ü© {
					map(‚Ä¶a){‚Ü© d.map(‚Ä¶a)},
					} }
			else ‚ÄΩ('TODO')
			}},
		set lines(Œπ){ write_file(@._Œπ, Œπ.join('\n')+'\n') },
		get json(){‚Ü© JSON.parse(read_file(@._Œπ) || 'null') },
		set json(Œπ){ write_file(@._Œπ, JSON_pretty(Œπ)) },
		get json2(){‚Ü© json2_read(@.text) },
		set json2(Œπ){ @.text = json2_show(Œπ) },
		get ini(){‚Ü© npm`ini@1.3.4`.parse(@.text) },
		# set ini(Œπ){},
		# get csv(){‚Ü©},
		set csv(Œπ){ t ‚Üê œÜ`/tmp/csv_${random_id(25)}`; t.json = Œπ; sh·µ•`Œ∂ ${'npm`csv@0.4.6`.stringify('+js`œÜ(${t+''}).json,Œª(e,Œπ){ œÜ(${@.root('/')+''}).buf = Œπ })`}` },
		# get xml(){‚Ü© JSON.parse(sh·µ•`Œ∂ ${js`npm`xml2js@0.4.17`.parseString(œÜ(${@+''}).text,Œª(e,Œπ){ process.stdout.write(JSON.stringify(Œπ)) })`}`+'') },
		set xml(Œπ){ @.text = npm`xmlbuilder@8.2.2`.create(Œπ,{allowSurrogateChars:‚úì}).end({pretty:‚úì}) },
		get plist(){t‚Üê; buf ‚Üê @.buf ;‚Ü© 0?0
			# in case bplist-parser has bugs, this is available:
			# : which('plutil')? npm`plist@2.1.0`.parse(sh·µ•`plutil -convert xml1 -o - ${@.root('/')+''}`+'')
			: buf.slice(0,6)+''==='bplist'? ( t= œÜ`/tmp/plist_${random_id(25)}`, sh·µ•`Œ∂ ${'npm`bplist-parser@0.1.1`.parseFile('+js`${@.root('/')+''},Œª(e,Œπ){ œÜ(${t+''}).plist = Œπ })`}`, t.plist )
			: npm`plist@2.1.0`.parse(@.text)
			},
		set plist(Œπ){ @.text = npm`plist@2.1.0`.build(Œπ) },
		get json_array__synchronized(){‚Ü© Œª(‚Ä¶Œπs){_Œπ‚Üê@._Œπ
			if (Œπs.‚Äñ) ‚ÄΩ('TODO')
			d ‚Üê JSON.parse((read_file(_Œπ)||'[]')+'')
			‚Ü© {
			push(‚Ä¶a){a.map(Œª(Œπ){
				d.push(Œπ)
				open(_Œπ,'[]',Œª(fl){
					i ‚Üê fl.indexOf_skipping(-1,-1e4,-1,ord(']'),/[ \n\t]/) || ‚ÄΩ('bad file')
					is_0 ‚Üê fl.indexOf_skipping(i-1,-1e4,-1,ord('['),/[ \n\t]/)!==‚àÖ
					fl.write((is_0?'':',')+JSON.stringify(Œπ,‚àÖ,'  ')+']',i)
					})
				})},
			filter(f){‚Ü© d.filter(f)},
			get length(){‚Ü© d.‚Äñ},
			get ['‚Äñ'](){‚Ü© d.‚Äñ},
			} }},

		get size(){‚Ü© fs.statSync(@._Œπ).size },
		get ['‚Äñ'](){‚Ü© fs.statSync(@._Œπ).size },
		}
	Œª Œ¶s(Œπ){@._Œπ = Œπ}; Œ¶s.prototype = {
		inspect(À£,opts){‚Ü© opts.stylize('œÜ','special')+util.inspect(@._Œπ,opts)},
		get name_TMP(){‚Ü© @._Œπ.map(Œπ=> new Œ¶(Œπ).name)}, # fs.readdirSync
		get œÜs(){‚Ü© @._Œπ.map(Œπ=> new Œ¶(Œπ))}, # [œÜ]
		}
	Œª œÜ(ss,‚Ä¶Œπs){
		head ‚Üê @ instanceof Œ¶ && @._Œπ
		if (@ instanceof Œ¶s) ‚ÄΩ('not yet implemented')
		tmpl ‚Üê is_template([ss,‚Ä¶Œπs])
		if (tmpl){Œπ ‚Üê simple_template(ss,Œπs,[œÜ,'/']); if (Œπ.filter(Tstr).join('').re`\*|\{[^}]*?,`) {
			Œπ.‚Äñ <= 1 || ‚ÄΩ('not yet implemented * ** ${}',Œπ)
			Œπ = normHs(Œπ)
			Œπ = Œπ[0]
			Œπ.includes('**') && ‚ÄΩ('not yet implemented ** ${}',Œπ)
			r ‚Üê ['.']
			if (Œπ[0]==='/') r = ['/']
			Œπ.split('/').forEach(Œª(Œπ){
				if (Œπ==='')‚Ü©;
				r = r.map‚Ä¶(r=>{
					if (Œπ === '.') ‚Ü© [r]
					if (Œπ === '..') ‚Ü© [r==='.'? '..' : r.split('/').every(Œπ=>Œπ==='..')? r+'/..' : path.dirname(r)]
					‚Ü© fs.readdirSync(r).filter(b=> globmatch(Œπ,b)).map(b=> r+'/'+b)
					})
				})
			‚Ü© new Œ¶s(r) } }
		else {Œπ ‚Üê ss; if (Œπs.‚Äñ || Tarr(Œπ)) ‚ÄΩ('not yet implemented'); if (Œπ instanceof Œ¶s) ‚ÄΩ('not yet implemented')}
		if (tmpl){Œπ = normHs(Œπ).map(Œπ=> !Tstr(Œπ)? ENC(Œπ.raw+'') : Œπ).join('')}
		else if (Œπ instanceof Œ¶){‚Ü© head && Œπ._Œπ[0]!=='/'? new Œ¶(head+'/'+Œπ._Œπ) : Œπ}
		else {Œπ = (Œπ+'').replace(/^~(?=\/|$)/,process.env.HOME)}
		‚Ü© new Œ¶(path.normalize(head? head+'/'+Œπ : Œπ).replace(/(?!^)\/$/,'')) }
	‚Ü© œÜ })

############################### personal concepts ##############################
sb._call = => sb.tab.active.Œπ
E.p = Œª(Œπ){ t ‚Üê clipboard ;‚Ü© arguments.length===0? t.Œπ :( t.Œπ = Œπ ) }

#################################### Œ∂ infra ###################################
_(util.inspect.styles) <- ({null:'grey',quote:'bold'})
;[process,module].map(Œπ=> Œπ.inspect = Œª(){‚Ü© '{'+Object.getOwnPropertyNames(@).map(Œπ=> Œπ+':').join(', ')+'}' }) # ‚Ä° hack, like the [1] * 5 thing in Œ∂_repl_start. clean up by: can we override builtin inspects without problems? then: defining solid inspect functions for more things. otherwise: figure out something else.
;['global','Object'].map(Œπ=>{
global[Œπ].inspect = Œª(d,opt){‚Ü© opt.stylize(Œπ,'quote') }
})
# Number_toFixed ‚Üê Œª(Œ∏,Œπ){ Œ∏ = round(Œ∏ / 10**-Œπ) * 10**-Œπ ;‚Ü© Œπ>0? Œ∏.toFixed(Œπ) : Œ∏+'' }
# E.pretty_time_num = Œπ=> _(new Number(Œπ)) <- ({inspect:Œª(À£,opt){ P ‚Üê 20; Œπ‚Üê@; [Œπ,u] ‚Üê (Œπ >= P/1e3? [Œπ,'s'] : [Œπ*1e6,'Œºs']) ;‚Ü© opt.stylize(Number_toFixed(Œπ,-max(-3,floor(log10(Œπ/P))))+u,'number') }})
# E.pretty_time_num = Œπ=> Unit(Œπ,'s')
Unit ‚Üê (Œπ,u)=>{ ;r ‚Üê {Œπ,u} ;[#Q r.valueOf #Q].def({ value(){‚Ü© @.Œπ } }) ;[#Q r.inspect #Q].def({ value(À£,opt){‚Ü© util.inspect(@.Œπ,opt)+opt.stylize(@.u,'number') } }) ;‚Ü© r }
assign_properties_in_E_informal({
,'Number.prototype.inspect':Œª(d,opt){'use strict'; Œπ ‚Üê @; if(! Tprim(Œπ) ) ‚Ü© Œπ ;‚Ü© opt.stylize( Object.is(Œπ,-0)? '-0' : Œπ===‚àû? '‚àû' : Œπ===-‚àû? '-‚àû'
	: Number.isSafeInteger(Œπ)? ''+Œπ
	: Œπ.toExponential().replace('+','').replace(/(\.\d\d)\d+/,'$1').replace('e0','')
	,'number') }
,'Boolean.prototype.inspect':Œª(d,opt){'use strict' ;‚Ü© opt.stylize( @?'‚úì':'‚úó','boolean' ) }
,'Date.prototype.inspect':Œª(d,opt){‚Ü© opt.stylize(isNaN(+@)? 'Invalid Date' : @.getUTCSeconds()!==0? @.ymdhms : @.getUTCMinutes()!==0? @.ymdhm : @.getUTCHours()!==0? @.ymdh : @.ymd, 'date')}
# ,'Function.prototype.inspect':Œª(rec,ctx){t ‚Üê Œ∂_compile.‚Åª¬π(@+'').replace(/^Œª \(/,'Œª(').match(/^.*?\)/) ;‚Ü© ctx.stylize('['+(t?t[0]:'Œª ?(?)')+']', 'special')}
# ,'Buffer.prototype.inspect':Œª Œõ(){‚Ü© Œõ.super.call(@).replace(/(^<\w+)/,'$1['+@.‚Äñ+']')}
# ,inspect(À£,opt){‚Ü© opt.stylize('œÜ','special')+opt.stylize(util.inspect(@._Œπ.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') }
})
sb.encode = (=>{
	line ‚Üê Œπ‚áí
		: Tstr(Œπ)? Œπ
		# : util.inspect(Œπ,{ depth:‚àÖ, maxArrayLength:‚àÖ, })
		: util_inspect_autodepth(Œπ)
	‚Ü© Œπ‚áí
		: Œπ===‚àÖ? ''
		: Tarr(Œπ)? Œπ.map(line).join('\n')
		: line(Œπ) })()
# EventEmitter.prototype.inspect

E.cn = { log:(‚Ä¶a)=> console.log(
	is_template(a)?
		easy_template(Œπ=>Œπ)(‚Ä¶a).map(Œπ=> Tstr(Œπ)? Œπ : util_inspect_autodepth(Œπ[0],{colors:‚úì})).join('') :
		a.map(Œπ=> Tstr(Œπ)? Œπ : util_inspect_autodepth(Œπ,{colors:‚úì})).join(' ')
		) }
E.util_inspect_autodepth = Œª(Œπ,opt={,}){ opt.L || (opt.L = 1e6); last‚Üê; for(i‚Üê1;;i++){ r ‚Üê util.inspect(Œπ,_({maxArrayLength:opt.L/3 |0, depth:i}) <- (opt)); if (r===last || r.‚Äñ > opt.L) ‚Ü© last===‚àÖ? '<too large>' : last; last = r } }

E.‚Ä°_repl_start = => Œ∂_repl_start({
	# i know how to make the good repl for ct. i want to, but im tired
	prompt:'\x1b[30m\x1b[100m‚Ä°\x1b[0m ',
	compile:Œπ=>{t‚Üê;
		lock ‚Üê 0?0
			: ['ct','chrome_tabs','ps2','d','bookmarks'].‚à™([]).has(Œπ)? 'require_new(œÜ`~/.bashrc.Œ∂`).'+Œπ+'()'
			: (t= Œπ.re`^f(?: (.+))?$` )? js`go_to('path',${t[1]||'.'})`
			: Œπ
		lock===Œπ || cn.log('‚õì  '+lock)
		‚Ü© Œ∂_compile(lock) }, })
anon_b5s81‚Üê; anon_7268v‚Üê;
E.Œ∂_repl_start = opt=>{ opt = _({compile:Œ∂_compile, prompt:'\x1b[30m\x1b[42mŒ∂\x1b[0m '}) <- (opt)
	my_eval ‚Üê code=>{ # ! can be refactored further
		t ‚Üê opt.compile(code)
		try{ t = new vm.Script(t,{ filename:'repl', displayErrors:‚úó }) }
		catch(e){ if( e.name==='SyntaxError' ) ‚Ü© {parse_error:e}; e.stack = e.name+': '+e.message+'\n    at <repl>' ;‚Ü© {error:e} }
		try{ ‚Ü© {v:t.runInThisContext()} }
		catch(e){ e && Tstr(e.stack) &&( e.stack = e.stack.replace(/^([^]*)at repl:(.*)[^]*?$/,'$1at <repl:$2>') ) ;‚Ü© {error:e} }
		}
	q ‚Üê (Œπ,opt={,})=> util_inspect_autodepth(Œπ,_(opt).pick('colors'))
	promise_watch ‚Üê Œπ=>{ if(! Œπ.id ){
		Œπ.id = b36(fromUInt32BE([#Q (anon_b5s81||( anon_b5s81 = [0] )).0 #Q].Œπ++))
		hr ‚Üê hrtime(); Œπ.then(x=>{ x ‚Üê my_inspect(x); hrtime(hr) < 5 && x.‚Äñ && hs·µ•`hs.alert(${`Promise #${Œπ.id} = ${x.slice(0,200)}`},12)` }) } }
	my_inspect ‚Üê (Œπ,opt={,})‚áí
		: Œπ===‚àÖ? ''
		: T.Promise(Œπ)? 0?0
			: Œπ.status? 'Œ† '+q(Œπ.Œπ,opt)
			: Œπ.status===‚àÖ?( promise_watch(Œπ), `Œ† #${Œπ.id} { <pending> }` )
			: q(Œπ,opt)
		: Tarr(Œπ) && Œπ.‚Äñ > 1 && Œπ.every(t=> t===Œπ[0]) && _.range(Œπ.‚Äñ).every(t=> t in Œπ)
			? q([Œπ[0]],opt)+' √ó '+q(Œπ.‚Äñ,opt)
		: q(Œπ,opt)
	‚Ü© (f=> f.call( require('repl').start(_({useGlobal:‚úì}) <- (_(opt).pick('prompt'))) ))(Œª(){
	@.In = []; @.Out = []
	super_ ‚Üê @.completer; @.completer = Œª(line,cb){ line.trim()===''? cb(‚àÖ,[]) : super_.call(@,line,cb) }
	@.removeAllListeners('line').on('line',Œª(line){
		@.context.rl = @
		@.context.E = @.context
		if( @.bufferedCommand ){ Œπ ‚Üê @.history; Œπ.reverse(); t ‚Üê Œπ.pop(); Œπ[-1] += '\n'+t; Œπ.reverse() }
		code ‚Üê @.bufferedCommand+line
		{parse_error,error,v} ‚Üê my_eval(code)
		if( parse_error ){ @.bufferedCommand = code+'\n'; @.outputStream.write('    ') ;‚Ü© }
		@.bufferedCommand = ''
		if( code ){
			œÜ`~/.archive_Œ∂`.text = œÜ`~/.archive_Œ∂`.text + JSON.stringify({time:Time(), code}) + '\n'
			@.In.push(code); @.Out.push(error || v)
			}
		if( error ) @._domain.emit('error', error.err || error)
		else{
			if( T.Promise(v) ) [#Q @.context.__ #Q].def({get(){‚Ü© v.status? @.__ = v.Œπ : v }, writable:‚úì})
			else if( v!==‚àÖ ) @.context.__ = v
			try{ t ‚Üê my_inspect(v,{colors:@.useColors}) }catch(e){ t ‚Üê '<repl inspect failed>:\n'+(e&&e.stack) }
			@.outputStream.write(t && t+'\n') }
		@.displayPrompt()
		})
	@.removeAllListeners('SIGINT').on('SIGINT',Œª(){
		is_line ‚Üê @.bufferedCommand+@.line
		@.clearLine()
		if( is_line ){ @.bufferedCommand = ''; @.displayPrompt() } else @.close()
		})
	delete @.context._; @.context._ = _
	‚Ü© @
	}) }

##################################### main #####################################
sh_ify ‚Üê Œπ=>{t‚Üê; ‚Ü© Œ†( 0?0
	: T.Promise(Œπ)? Œπ.then(sh_ify.X)
	: Œπ===‚àÖ? {,}
	: Tstr(Œπ)? {out:Œπ}
	: T.boolean(Œπ)? {code:Œπ?0:1}
	: (t=catch_union(=> JSON.stringify(Œπ)), !T.Error(t))? {out:t}
	: {out:Œπ+''} )}
eval_ ‚Üê Œª __53gt7j(Œπ){
	try{
		try{ new vm.Script(Œπ) ;‚Ü© (0,eval)(Œπ) }catch(e){ if(!( e.name==='SyntaxError' && e.message==='Illegal return statement' )) throw e ;‚Ü© (0,eval)('(()=>{'+Œπ+'})()') }
	}catch(e){ e!==‚àÖ && e!==null && Tstr(e.stack) && (e.stack = e.stack.replace(/    at __53gt7j[^]*/,'    at <eval>')); throw e }
	}
E.Œ∂_main = ({a})=>{Œπ‚Üê;
	a[0]==='--fresh' && a.shift()
	if( !a.‚Äñ ) Œ∂_repl_start()
	else if( Œπ=a[0], œÜ(Œπ).BAD_exists() || Œπ.re`^\.?/` ){ process.argv = [process.argv[0],‚Ä¶a]; t ‚Üê œÜ(Œπ).root('/')+''; o‚ÜêModule._cache;m‚ÜêModule._resolveFilename(t,‚àÖ,‚úì);oŒπ‚Üêo[m]; o[m] = ‚àÖ; Module._load(t,‚àÖ,‚úì); o[m] = oŒπ }
	else {
		global.require = require; global.code = a.shift(); global.a = a; [global.a0,global.a1] = a; global.Œπ = a[0]
		code = code.replace(/;\s*$/,'; ‚àÖ')
		sh_ify(eval_(Œ∂_compile(code)))
			.then(Œπ=>{ Œπ.out && process.stdout.write(Œπ.out); Œπ.code &&( process.exitCode = Œπ.code ) })
		}
	}
if_main_do((‚Ä¶a)=>Œ∂_main({a}))
# inject as .bashrc
# 	sh` Œ∂(){ if [[ $# = 0 || $1 =~ ^\.?/ || $1 = --fresh ]]; then /usr/local/bin/Œ∂ "$@"; else Œ∂Œª "$@"; fi; } `

############################# remaining work for œÜ #############################
# https://www.npmjs.com/package/glob-to-regexp
/*
formats include
	image               
	pixels              
	png                 .png
	jpg                 .jpg
	plist               /^<\?xml / && /<\/plist>\s*$/           read: npm::plist.parse(it)     show: npm::plist.build(it)
	xml                 .xml || /^<\?xml /
	base64              .64
	pixels (grey)       
	stdin               fd:0
	FIFO                fd:0...
	:executable         ,/^#!/ | try{fs.accessSync(Œπ,fs.X_OK) ;‚Ü© ‚úì} catch(e){‚Ü© ‚úó}
	directory relative
	directory absolute
formats are Really stream formats
the formats are complicated to interact with, because
* GET POST PUT have really tangly apis for all sorts of efficiency concerns
* DELETE especially, we want to make some distinctions to make sure we don‚Äôt fuck things up accidentally (although trash could help)

# paths can have extensions, which are often meaningful. (basename/filename, ext/suffix. path.basename,dirname,extname)

# we need to be careful with non-atomic transactions
# we need to think about how this interacts with concurrency
# we need to think about how this interacts with distributed machines (e.g. mixing file and http URLs)
# 	‚Äúlike, it should be caching urls all the time.‚Äù

######################## things i need ** globbing to do #######################
scratch/scratch.txt:107:œÜ`**`.map(Œπ=> [Œπ+'',Œπ.get()])._.groupBy(1)._.values().map(Œπ=> Œπ._.map(0)).filter(Œπ=> Œπ.‚Äñ > 1)
scratch/sublime/index.Œ∂:60:	œÜ(arg.in).œÜ`**`.filter(Œπ=> !Œπ.dir()).map(Œª(Œπ){Œπ+=''; t‚Üê; Œπ = Œπ.slice(arg.in.‚Äñ).replace(/^\//,'')
scratch/sublime/index.Œ∂:66:	out ‚Üê œÜ(arg.out).œÜ`**`.filter(Œª(Œπ){Œπ+='' ;‚Ü© roots.some(Œª(r){‚Ü© Œπ.indexOf(r) === 0})}).filter(Œπ=> !Œπ.dir()).map(Œπ=> Œπ+'')
*/

# i'd like that to be #!/usr/bin/env node --max_old_space_size=10000 
