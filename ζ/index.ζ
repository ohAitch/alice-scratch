#!/usr/bin/env node
_ ← require('underscore')

// -------------------------- local metaprogramming ------------------------- //
E ← {} // exports
patches ← []
P ← λ(_ι){r ← λ(G){ι ← _ι(); (Tarr(ι)? ι : _(ι).pairs()).forEach(λ([name,ι]){genex_0(name).map(λ(name){
	name = name.split('.'); last ← name.pop()
	t ← name.reduce((r,ι)=> r[ι], G); Tfun(ι)? (ι.name && (ι.super = t[last]), t[last] = ι) : def(t,last,ι)
	}) }) }; r(global); patches.push(r)}

// ------------------------------- local utils ------------------------------ //
def ← E.def = (o,name,ι)=>{
	if (Tfun(ι)) ι = lazy(name,ι)
	'configurable' in ι || (ι.configurable = true)
	'value' in ι?
		'writable' in ι || (ι.writable = true) :
		'set' in ι || (ι.set = λ(ι){def(@,name,{value:ι, enumerable:true})})
	Object.defineProperty(o,name,ι); ↩ o }
lazy ← (name,ι)⇒ {get(){↩ @[name] = ι()}}
prop_assign ← (from,to)=> Object.getOwnPropertyNames(from).forEach(ι=> Object.defineProperty(to,ι,Object.getOwnPropertyDescriptor(from,ι)))

// ------------------------ should be in standard lib ----------------------- //
T ← E.T = λ(ι){ 
	ty ← typeof ι; if (ty!=='object') ↩ ty; if (ι===null) ↩ 'null'
	p ← Object.getPrototypeOf(ι); if (p===Object.prototype || p===null) ↩ 'object'
	for (var t of is_l) if (t[1](ι)) ↩ t[0]
	↩ 'object' }
internal_util ← process.binding('util')
is_l ← [
	['Array',Array.isArray],
	…['ArrayBuffer','DataView','Date','Map','MapIterator','Promise','RegExp','Set','SetIterator','TypedArray'].map(ι=> [ι,internal_util['is'+ι]]),
	…['Error','String','Boolean','Number'].map(ty=> [ty,ι=> Object.prototype.toString.call(ι)==='[object '+ty+']']),
	]
_(T).assign(_(is_l).object())
T.NaN = Number.isNaN
T['-0'] = ι=> ι===0 && 1/ι < 0
T.symbol = ι=> typeof ι === 'symbol'
Tstr ← E.Tstr = ι=> typeof ι === 'string'
Tnum ← E.Tnum = ι=> typeof ι === 'number'
Tbool ← E.Tbool = ι=> typeof ι === 'boolean'
Tfun ← E.Tfun = ι=> typeof ι === 'function'
Tarr ← E.Tarr = T.Array

Tprim ← E.Tprim = λ(ι){ switch(typeof(ι)){case 'undefined': case 'boolean': case 'number': case 'string': case 'symbol': ↩ true; case 'object': ↩ ι===null; default: ↩ false} }
Tbox ← E.Tbox = λ(ι){ if (ι===null || typeof ι!=='object') ↩ false; t ← Object.getPrototypeOf(ι); t = t.constructor&&t.constructor.name; ↩ (t==='Boolean'||t==='String'||t==='Number') && /^\[object (Boolean|String|Number)\]$/.test(Object.prototype.toString.call(ι)) }
Tprim.ι = {undefined:1,boolean:1,number:1,string:1,symbol:1,null:1}
Tbox.ι = {Boolean:1,String:1,Number:1}

// -------------------------------- requires -------------------------------- //
;[ ['child_process'],['events','EventEmitter'],['http'],['https'],['module','Module'],['net'],['os'],['querystring'],['readline'],['repl'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['lodash','_2'],
['fs'],//! hack
	].map(λ([ι,n]){ def(E, n||ι, ()=> require(ι)) })
global._ && (E._ = global._)
global.stream = E.stream
path ← require('path')
fs ← require('fs')
moment ← require('moment')
if (0){ require('util'); require('stream'); require('moment'); require('priorityqueuejs'); require('urijs') } // browserify
def(E,'robot',lazy('robot',()=> npm('robotjs@0.4.5') ))
def(E,'require_new',lazy('require_new',()=>{ t ← npm('require-new@1.1.0'); ↩ ι=> t(ι+'') }))

// --------------------------------- ζ infra -------------------------------- //
E.npm = λ(ι){ Tarr(ι) && (ι = ι[0]); APP ← '\x1b[34m[npm]\x1b[0m'
	[,name,version,sub] ← ι.re`^(.*?)(?:@(.*?))?(/.*)?$`
	abs_name ← ()=> name+'@'+version
	if (version){
		cache ← φ`~/.npm/${name}/${version}`; final ← cache.φ`/node_modules/${name}`+(sub||'')
		try{ ↩ require(final) }catch(e){ if (!(e.code==="MODULE_NOT_FOUND")) throw e }
		cache.BAD_exists() || shᵥ`cd ~; npm cache add ${abs_name()}`
		a←;b←; (a=cache.φ`package.json`).ι = {description:'-',repository:1,license:'ISC'}; (b=cache.φ`README`).ι = ''; shᵥ`cd ${cache} && npm --cache-min=Infinity i ${abs_name()}`; a.ι = b.ι = null
		↩ require(final) }
	else {
		sfx`ack`
		version = shᵥ`npm show ${ι} version`+''
		process.stderr.write(APP+' latest: '); process.stdout.write(ι.replace(/-/g,'_')+' ← npm('+util_inspect_autodepth(abs_name())+')'); process.stderr.write('\n')
		} }
E.js_tokenize = code=>{
	tok ← npm('babylon@6.14.1').parse(code,{allowReturnOutsideFunction:true}).tokens
	↩ _.zip( tok.map(ι=> code.slice(ι.start,ι.end)), tok.windows(2).map(([a,b])=> code.slice(a.end,b.start) ) )._.flatten(true).filter(ι=>ι) }
E.uses_this = f=> (f+'').match(/\bthis\b/) && js_tokenize('('+f+')').includes('this')? 'maybe' : false
def(E,'ζ_compile',λ(){
	word_extra ← re`♈-♓🔅🔆`.source; word_extra_gu ← re`[…${word_extra}]`.g
	word ← re`A-Za-z0-9_$ʰ-ʸˡ-ˣΑ-ΡΣ-ωᴬ-ᵛᵢ-ᵥᶜᶠᶻ⁰ⁱⁿₐ-ₓₕ-ₜℂℕℚℝℤⱼⱽ…${word_extra}`.source
	ζ_parse ← (λ(){
		P ← require('./parsimmon2.js')
		ident ← P(re`(?![0-9])[…${word}]+|@`)
		comment ← re`(//.*|/\*[^]*?(\*/|$))+`
		simple_js ← P(()=> P.alt(
			P(comment).type('comment'),
			P.seq( P('{'), simple_js, P('}') ),
			P.seq( P.alt(
				P(/(['"])(((?!\1)[^\\]|\\.)*?\1)/).type('string'),
				ident,
				P.seq( P('`').type('template'), tmpl_ι.many(), P('`').type('template') ),
				P(/[)\]0-9]/)
				), P.alt( P(re`[ \t]*(?!…${comment.source})/`), P.of('') ) ),
			P(re`/((?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/([a-z]*)`).type('regex'),
			P(re`[^{}/'"…${'`'})@\]…${word}]+|[^}]`)
			).many() )
		tmpl_ι ← P.alt( P.seq( P('${').type('template'), simple_js, P('}').type('template') ), P(/\\[^]|(?!`|\$\{)[^]/).type('template') )
		js_file ← P.seq( P(/(#!.*\n)?/).type('shebang'), simple_js )
		↩ code=>{
			ι ← js_file.parse(code)._.flatten()
			r ← []; for(var t of ι) t.T? r.push(t) : r[-1]&&r[-1].T? r.push(t) : (r[-1]+=t)
			↩ r } })()
	ζ_compile_nonliteral ← (λ(){
		unicode_names ← def({},'ι',()=>{
			unicode_data ← 'Cc Cf Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs'.split(' ').mapcat(ι=> npm('unicode@0.6.1/category/'+ι)._.values() )
			↩ unicode_data.filter(ι=> !/^</.test(ι.name)).map(ι=> [parseInt(ι.value,16), '_'+ι.name.replace(/[- ]/g,'_').toLowerCase()+'_'])._.object()
			})
		is_var ← re`(\[[…${word},…]+\]|\{[…${word},…]+\}|[…${word}]+)(\s*)←(;?)`.g
		↩ ι=> ι
			.replace(is_var,(ˣ,name,ws,end)=> 'var '+name+ws+(end?';':'=') )
			.replace(/↩ ?/g,'return ')
			.replace(/…(?!\$\{|\(\?)/g,'...')
			.replace(/λ(?=\*?(?:[ \t][^\(=←]*)?\([^\)]*\)[ \t]*\{)/g,'function')
			.replace(/@/g,'this')
			.replace(/‽(\(?)/g,(ˣ,callp)=> callp? '!function(...a){throw Error(a.map(ι=> Tstr(ι)? ι : util_inspect_autodepth(ι)).join(" "))}(' : '!function(){throw Error("‽")}()' )
			.replace(word_extra_gu,ι=> unicode_names.ι[ι.codePointAt(0)] )
			.replace(/⇒/g,'=>0?0:')
		})()
	r ← code=> ζ_parse(code).map(ι=> ι.T? ι.ι : ζ_compile_nonliteral(ι)).join('')
	r['⁻¹'] = ι=> ι.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$Α-ΡΣ-Ωα-ω]+)(\s*)(=?)|\.\.\./g, λ(ι,name,s,eq){↩ {'function':'λ','return':'↩','this':'@','...':'…'}[ι] || (eq==='='? name+s+'←' : name+s+'←;')})
	↩ r })
;[process,module,global].map(ι=> ι.inspect = λ(){↩ '{'+Object.getOwnPropertyNames(@).map(ι=> ι+':').join(', ')+'}' }) //‡ hack, like the [1] * 5 thing in ζ_repl_start. clean up by: can we override builtin inspects without problems? then: defining solid inspect functions for more things. otherwise: figure out something else.
E.ζ_repl_start = λ(opt){ opt={compile:ζ_compile, prompt:'\x1b[30m\x1b[42mζ\x1b[0m '}._.assign(opt)
	↩ (f=> f.call( repl.start({useGlobal:true}._.assign(opt._.pick('prompt'))) ))(λ(){
	@.In = []; @.Out = []
	super_ ← @.completer; @.completer = λ(line,cb){ line.trim()===''? cb(null,[]) : super_.call(@,line,cb) }
	inspect ← ι=> util_inspect_autodepth(ι,{colors:@.useColors})
	@.removeAllListeners('line').on('line',λ(line){
		if (line==='') ↩;
		if (@.bufferedCommand){ @.history[1] += '\n'+@.history[0]; @.history.shift() }
		t ← @.bufferedCommand + (line||''); code ← t
		if (t.re`^>`) t = '__SPECIAL__('+JSON.stringify(t.slice(1))+')' // hack: for apprentice
		if (/(^\{[^]*\}$)|(^λ\()/.test(t)) t = '('+t+')'
		t = opt.compile(t)
		try{ sc ← new vm.Script(t, {filename:'repl', displayErrors:false}) }
		catch(e){ if( e.name==='SyntaxError' ){ @.bufferedCommand += line+'\n'; @.outputStream.write('    '); ↩ }; e.stack = e.name+': '+e.message+'\n    at <repl>'; err ← e }
		if (sc)
		try{ global.this_ = @; ret ← sc.runInThisContext({displayErrors:false}) }
		catch(e){ e && Tstr(e.stack) && (e.stack = e.stack.replace(/^([^]*)at repl:(.*)[^]*?$/,'$1at <repl:$2>')); err ← e }
		φ`~/.history_ζ`.text = φ`~/.history_ζ`.text + JSON.stringify({time:Time(), code}) + '\n'
		@.In.push(code); @.Out.push(err || ret)
		if (err) @._domain.emit('error', err.err || err)
		@.bufferedCommand = ''
		if (!err && ret !== undefined) {
			@.context.__ = ret
			try{
				if (Tarr(ret) && ret.length > 1 && ret.every(ι=> ι===ret[0]) && _.range(ret.length).every(ι=> ι in ret))
					t ← inspect([ret[0]])+' * '+inspect(ret.length)
				else
					t ← inspect(ret)
			}catch(e){ t ← '<repl inspect failed>:\n'+(e&&e.stack) }
			@.outputStream.write(t+'\n') }
		@.displayPrompt()
		})
	@.removeAllListeners('SIGINT').on('SIGINT',λ(){
		if( @.bufferedCommand+@.line ){ @.clearLine(); @.lineParser.reset(); @.bufferedCommand = ''; @.lines.level = []; @.displayPrompt() }
		else{ @.clearLine(); @.close() }
		})
	delete @.context._; @.context._ = E._
	↩ @
	}) }

// ------------------------------- ζ & § infra ------------------------------ //
// E.ζ_compile_S = ι=> ι
// 	.replace(/§.[^]*?§|…(?!\$[{\/]|\(\?|':'| "\)\))|(?:λ\*?(?: λ)?(?=(?:[ \t][^\(=←]*)?\([^\)]*\)[ \t]*\{)|↩(?![\]"]|\([.?]|\$\/| ':'r|  │) ?|([\w$ʰ-ʸˡ-ˣΑ-ΡΣ-ωᴬ-ᵛᵢ-ᵥᶜᶠᶻ⁰ⁱⁿₐ-ₓₕ-ₜℂℕℚℝℤⱼⱽ]+)(\s*)←(;?))(?!['"]| ↑)/g,
// 		(ι,name,s,semi)=> ι[0]==='§'? ι : {'λ':'function', 'λ λ':'function λ','λ*':'function*', 'λ* λ':'function* λ', '↩':'return ', '↩ ':'return ', '…':'...'}[ι] || (semi===';'? 'var '+name+s+';' : 'var '+name+s+'=') )
// 	.replace(/§.[^]*?§|(^|[^'"])@(?![-`'"\w\/\\/$]| #|\([?.])/g,(ι,a1)=> ι[0]==='§'? ι : a1+'this')
// 	.replace(/§.[^]*?§|(?!"‽"|'‽')(^|[^])‽(?!\(\?)(\(?)/g, (ˣ,a,ι)=> ˣ[0]==='§'? ˣ : a+(ι? '!function(...a){throw Error(a.map(ι=> Tstr(ι)? ι : util_inspect_autodepth(ι,{colors:true})).join(" "))}(' : '!function(){throw Error("‽")}()') )
// E.ζS_compile = ι=> require('/Users/home/code/scratch/§/ζ§.ζ').S_macro_transform(E.ζ_compile_S(ι))
if (require.extensions) (()=>{ o ← require.extensions['.js']; require.extensions['.js'] = λ(module,ι){ d ← _.once(()=> fs.readFileSync(ι,'utf8')); t ← path.extname(ι)
	t==='.ζ' || (t==='' && d().re`#!/usr/bin/env ζ\s`)? module._compile(ζ_compile(d()),ι) :
	// t==='.ζ§' || (t==='' && d().re`#!/usr/bin/env ζ§\s`)? module._compile(E.ζS_compile(d()),ι) :
		o(module,ι) } })()

// ------------------------ should be in standard lib ----------------------- //
E.Π = ι=> Tfun(ι) && /(yes|\(yes,no\))=>/.test(ι+'')? new Promise(ι) : Promise.resolve(ι)
NODEp ← typeof process!=='undefined' && Object.prototype.toString.call(process)==='[object process]'
find_closest_ISU ← (ιs,ι)=>{ for(i←0;i<ιs.length;i++) if(ι <= ιs[i]) ↩ i===0? i : abs(ιs[i]-ι) < abs(ιs[i-1]-ι)? i : i-1; ↩ ιs.length-1 }
memo_frp ← λ(names,within,f){
	dir ← φ`~/.memo_frp/${names}`
	if (within){
		try{t ← fs.readdirSync(dir+'')} catch(e){if (!(e.code==='ENOENT')) throw e; t ← []}
		now ← Date.now()/1e3; t = t.sort().filter(ι=> Time(/^\S+/.λ(ι)[0]).i >= now - within)[-1]
		if (t) ↩ dir.φ(t).json2.ι}
	a ← Time().iso; ι ← f(); b ← Time().iso
	dir.φ`${a} ${rand_id(10)}`.json2 = {names, date:[a,b], ι}; ↩ ι}
regex_parse ← (λ(){
	// status: parses most regex. likely bugs. output format v unpolished. code v poorly put together.
	P ← require('parsimmon')

	P.Parser.prototype.type = λ(x){↩ @.map(ι⇒ {T:x,ι}) }
	P_ ← (…a)=> Tstr(a[0])? P.string(…a) : P.regex(…a)

	escape ← P_(/\\(x[0-9a-fA-F]{2}|u\{[0-9a-fA-F]+\}|u[0-9a-fA-F]{4}|.)/).type('escape')
	set_unit ← escape.or(P.noneOf(']'))
	set_unit2 ← P.seq(set_unit.skip(P_('-')), set_unit).type('range').or(set_unit)
	repeatable ← P.lazy(()=> P.alt( s_else,escape,s_any,s_group,s_lookahead,s_nlookahead,s_capture,s_set ) )
	unit ← P.lazy(()=> P.alt( s_begin,s_end,s_0_,s_1_,s_01,s_repeat,repeatable ) )
	reg ← P.lazy(()=> s_or)

	s_any ← P_('.').result({T:'any'})
	s_group ← P_('(?:').then(reg).skip(P_(')')).type('group')
	s_lookahead ← P_('(?=').then(reg).skip(P_(')')).type('lookahead')
	s_nlookahead ← P_('(?!').then(reg).skip(P_(')')).type('nlookahead')
	s_capture ← P_('(').then(reg).skip(P_(')')).type('capture')
	s_set ← P_('[').then(P.seq( P_(/\^?/), set_unit2.many() )).skip(P_(']')).map(ι⇒ {T:'set','^':!!ι[0],ι:ι[1]})
	s_else ← P.noneOf('.()[]^$|\\')

	s_begin ← P_('^').result({T:'begin'})
	s_end ← P_('$').result({T:'end'})

	s_0_ ← repeatable.skip(P_('*')).type('{0,}')
	s_1_ ← repeatable.skip(P_('+')).type('{1,}')
	s_01 ← repeatable.skip(P_('?')).type('{0,1}')
	s_repeat ← P.seq(repeatable, P_(/\{([1-9][0-9]*(?:,(?:[1-9][0-9]*)?)?|,[1-9][0-9]*)\}/,0)).map(ι⇒ {T:ι[1],ι:ι[0]})

	s_or ← P.sepBy(unit.many(),P_('|')).map(ι=> ι.length > 1? {T:'or',ι:ι} : ι[0])
	// reg.parse('^fo+o{,7}(?:\\b.ar|[a-c-e]|baz(?=gremlin)|)*')
	↩ ι=> reg.parse(ι).value })()
_apsc_parse ← _.memoize(λ(){
  P ← require('./parsimmon2.js')
  ws ← ι=> ws_.then(ι).skip(ws_); ws_ ← P(/[ \t\n\r]*/)
  value ← P(()=> P.alt(false_,true_,number,object,array,string,raw) )
  false_ ← P('false').result(false)
  true_ ← P('true').result(true)
  number ← P(/-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][-+]?[0-9]+)?/).map(ι=> +ι)
  _member ← P.seq(P(/[ a-z0-9-]+/i).skip(ws(P(':'))), value)
  object ← ws(P('{')).then(P.sep_by(_member,ws(P(',')))).skip(ws(P('}'))).map(ι=> ι.length? _.object(ι) : [])
  array ← ws(P('{')).then(P.sep_by(value,ws(P(',')))).skip(ws(P('}')))
  _char ← P(/[\n\t\x20-\x21\x23-\x5B\x5D-\u{10FFFF}]|\\(["\\\/bfnrt]|u[0-9a-fA-F]{4})/u).map(ι=> ι[0]!=='\\'? ι : {'"':'"','\\':'\\','/':'/',b:'\b',f:'\f',n:'\n',r:'\r',t:'\t'}[ι[1]] || String.fromCodePoint(parseInt(ι.slice(2),16)) )
  string ← P('"').then( _char.many().map(ι=> ι.join('')) ).skip(P('"'))
  raw ← P(/[^,}"]+/).or(string.map_js((ι,[i0,i1],l)=> l.slice(i0,i1))).many().map(ι=>{ ι=ι.join(''); ↩ ι==='missing value'? undefined : {T:'raw',ι} })
  ↩ ι=> ι===''? undefined : ws(value).parse(ι) })
E.applescript = {
	parse: ι=> _apsc_parse()(ι),
	print: ι=> Tnum(ι)? ι+'' : Tstr(ι)? '"'+ι.replace(/["\\]/g,'\\$&')+'"' : ‽,
	}

// E.lenient_json_parse = (λ(){
// 	P ← require('parsimmon')
// 	P_ ← (…a)=> Tstr(a[0])? P.string(…a) : P.regex(…a)

// 	whitespace ← P_(/\s*/m)
// 	escapes ← { b:'\b', f:'\f', n:'\n', r:'\r', t:'\t', }
// 	un_escape ← (str)=> str.replace(/\\(u[0-9a-fA-F]{4}|[^u])/, (ˣ,escape)=> escape[0]==='u'? String.fromCodePoint(parseInt(escape.slice(1),16)) : escapes[escape[0]] || escape[0] )
// 	comma_sep ← (parser)=> P.sepBy(parser, token(P_(',')))
// 	token ← p=> p.skip(whitespace)

// 	l_null ← token(P_('null')).result(null)
// 	l_t ← token(P_('true')).result(true)
// 	l_f ← token(P_('false')).result(false)
// 	l_str ← token(P_(/"((?:\\.|.)*?)"/, 1)).map(un_escape).desc('string')
// 	l_num ← token(P_(/-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/)).map(Number).desc('number')

// 	json ← P.lazy(()=> whitespace.then(P.alt( object, array, l_str, l_num, l_null, l_t, l_f )) )
// 	array ← token(P_('[')).then(comma_sep(json)).skip(token(P_(']')))
// 	pair ← P.seq(l_str.skip(token(P_(':'))), json)
// 	object ← token(P_('{')).then(comma_sep(pair)).skip(token(P_('}'))).map(ι=> _.object(ι))
// 	↩ ι=> json.parse(ι).value })()
genex_0 ← λ(ι){
	Λ ← ι=>
		ι.T==='or'? ι.ι.map(Λ) :
		ι.T==='capture'? Λ(ι.ι) :
		ι.T==='any'? ['.'] :
		ι.T==='set'?( ι['^']&&‽, ι.ι.mapcat(ι=> ι.T==='range'? _.range(ι.ι[0].codePointAt(),ι.ι[1].codePointAt()+1).map(String.fromCodePoint.X) : [ι]) ):
		Tarr(ι)? ι.map(Λ).reduce((a,b)=> _(a.map(a=> b.map(b=> a+b))).flatten(true),['']) :
			[ι]
	↩ Λ(regex_parse(ι)) }
Number_toFixed ← λ(θ,ι){θ = round(θ/pow(10,-ι))*pow(10,-ι); ↩ ι>0? θ.toFixed(ι) : θ+''}
pretty_time_num ← ι=> new Number(ι)._.assign({inspect:λ(ˣ,opts){ P ← 20; ι←@; [ι,u] ← (ι >= P/1e3? [ι,'s'] : [ι*1e6,'μs']); ↩ opts.stylize(Number_toFixed(ι,-max(-3,floor(log10(ι/P))))+u,'number') }})

E.hook_stdouterr = λ(){
	r ← ['stdout','stderr'].map(λ(stdio){
		o ← process[stdio].write; r ← []; process[stdio].write = λ(ι){r.push(ι)}; ↩ λ(){process[stdio].write = o; ↩ r.join('')}
		}); ↩ ()=> r.map(ι=> ι()) }
E.cn = { log:(…a)=> console.log(
	is_template(a)?
		easy_template(ι=>ι)(…a).map(ι=> Tstr(ι)? ι : util_inspect_autodepth(ι[0],{colors:true})).join('') :
		a.map(ι=> Tstr(ι)? ι : util_inspect_autodepth(ι,{colors:true})).join(' ')
		) }
_(E).assign(_(Math).pick('abs','ceil','exp','floor','log10','log2','max','min','pow','round','sqrt','cos','sin','tan')); _(E).assign({ln:Math.log, π:Math.PI, τ:Math.PI*2})
E.multiline = λ(ι){ ι = (ι+'').split('\n').slice(1,-1); t ← ι.map(ι=> ι.re`^\t*`[0].length)._.min(); ι = ι.map(ι=> ι.slice(t)); ↩ (ι[0]==='' && ι[-1]===''? ι.slice(1,-1) : ι).join('\n') }
E.hrtime = λ(ι){ t ← arguments.length===0? process.hrtime() : process.hrtime([ι|0,(ι-(ι|0))*1e9]); ↩ t[0] + t[1]*1e-9 }
E.busywait = λ(ι){ h←; for(hr←hrtime(); (h=hrtime(hr)) < ι; ι-h > 0.03 && (shᵥ`sleep ${ι-h-0.02}`,1)); }
E.bench = (f,opt={})=>{ TH ← opt.TH || 0.4
	//! really should include a confidence interval or smth
	r←0; I←1; hr←hrtime(); R ← ()=> pretty_time_num(hrtime(hr) / r)
	t←f(); r++
	if( T.Promise(t) ) ↩ Π(yes=>{ t.then(λ Λ(){ if( hrtime(hr) < TH ){ r++; f().then(Λ) }else yes(R()) }) })
	else{ for(;hrtime(hr) < TH;){ for(i←0;i<I;i++) f(); r += I; I = ceil(I*1.5) }; ↩ R() } }
E.bench1 = f=>{ hr ← hrtime(); f(); ↩ pretty_time_num(hrtime(hr)) }
E.GET_L = (ι,within)=> memo_frp(['GET -L', ι+''], within, ()=> shᵥ`curl -sL ${ι}`) //! some requests have short responses; will need more intelligent caching for those 'cause the filesystem can't take too much
E.rand = λ(ι){↩ arguments.length===0? Math.random() : Tnum(ι)? rand()*ι |0 : _.sample(ι) }
E.rand_id = L=> L.map(ι=> rand(az09||(az09=/[0-9a-z]/.genex_0()))).join(''); az09←; //§
E.fs_ipc = {
	emit: λ(port,ι){φ`/tmp/fs_ipc_${port}`.ι = ι; ↩ shᵥ`curl -s -X PUT 127.0.0.1:${port}`+''},
	emit2: λ(port,ι){φ`/tmp/fs_ipc_${port}`.ι = ι; ↩ shᵥ`curl -s 127.0.0.1:${port}`+''},
	on: λ(port,cbₐ){http.createServer(λ(ˣ,res){a←;
		t ← (a=φ`/tmp/fs_ipc_${port}`).ι; a.ι = null; global.ι = (a=φ`/tmp/fs_ipc_${port}_stdin`).ι.replace(/\n$/,''); a.ι = null
		end ← ι=> res.end(ι === undefined? '' : ι+''); r ← hook_stdouterr(); try {cbₐ(t); end(r().join('\n'))} catch(e){end(r().join('\n')+''+(e.stack||e)+"\n")}
		}).listen(port)},
	}
E.catch_ = f=> λ(){ try{ ↩ f.apply(@,arguments) }catch(e){ if ('__catchable' in e) ↩ e.__catchable; else throw e } }
E._↩ = ι=>{ throw {__catchable:ι} }
TimerCons ← λ(a,b){@.a=a;@.b=b}; TimerCons.prototype = {clear:λ(){@.a.clear();@.b.clear()}, ref:λ(){@.a.ref();@.b.ref()}, unref:λ(){@.a.unref();@.b.unref()}}
P(()⇒{
'RegExp.prototype.genex_0':λ(){↩ genex_0(@.source)},
'RegExp.prototype.exec_at':λ(ι,i){ @.lastIndex = i; ↩ @.exec(ι) },
'Number.prototype.map':λ(f){'use strict'; ι←+@; r ← Array(ι); for(i←0;i<ι;i++) r[i] = f(i,i,ι); ↩ r},
'Number.prototype.mapcat':λ(f){↩ @.map(f)._.flatten(true)},
'Array.prototype.mapcat':λ(f){r ← []; for(i←0;i<@.length;i++) {t ← f(@[i],i,@); for (j←0;j<t.length;j++) r.push(t[j])}; ↩ r}, // λ(f){↩ @.map(f)._.flatten(true)}
'Array.prototype.repeat':λ(x){↩ x<=0? [] : x.mapcat(()=> @)},
'Array.prototype.search':λ(f){ r←; if (@.some(λ(ι,i,l){ r = f(ι,i,l); if (r!==undefined) ↩ true })) ↩ r },
'Object.prototype._':{get(){↩ _(@)}},
'(Buffer|Array|String).prototype.chunk':λ(L){↩ _.range(0,@.length,L).map(i=> @.slice(i,i+L)) },

'Set.prototype.filter!':λ(f){ @.forEach(ι=> f(ι) || @.delete(ι)) },
'Set.prototype.pop':λ(){ t ← @.values().next().value; @.delete(t); ↩ t },
'Set.prototype.∪':λ(…a){↩ new Set([@,…a].map(ι=> […ι])._.flatten(true)) },
'Set.prototype.∩':λ(…a){ r ← new Set(@); for(var x of a) for(var ι of r) x.has(ι) || r.delete(ι); ↩ r },
'Set.prototype.-':λ(…a){ r ← new Set(@); for(var t of a) for(var ι of t) r.delete(ι); ↩ r },
'Set.prototype.map':λ(f){↩ […@].map(f) },

'Function.prototype.P':λ(…a1){ ι←@; ↩ λ(…a2){↩ ι.apply(@, a1.concat(a2)) } },
'Function.prototype.X':{get(){ ι←@; ↩ λ(a){↩ ι.call(@,a) } }},
'Function.prototype.defer':λ(){↩ setImmediate(@) },
'Function.prototype.in':λ(time){↩ setTimeout(@,max(0,time||0)*1e3) },
'Function.prototype.every':λ(time,opt){ r ← setInterval(@,max(0,time)*1e3); ↩ !(opt&&opt.leading)? r : new TimerCons(@.in(0),r) },

'stream.Readable.prototype.read_all':λ(){↩ Π(yes=>{ t ← []; @.resume().on('data',ι=> t.push(ι) ).on('end',()=> yes(Buffer.concat(t)) ) })},
'(Array|String|Buffer).prototype.-0':{get(){ },set(ι){ @.push(ι) }},
'(Array|String|Buffer).prototype.-1':{get(){↩ @.length<1? undefined : @[@.length-1] },set(ι){ @.length<1 || (@[@.length-1] = ι) }},
'(Array|String|Buffer).prototype.-2':{get(){↩ @.length<2? undefined : @[@.length-2] },set(ι){ @.length<2 || (@[@.length-2] = ι) }},
'(Array|String|Buffer).prototype.-3':{get(){↩ @.length<3? undefined : @[@.length-3] },set(ι){ @.length<3 || (@[@.length-3] = ι) }},
'(Array|String|Buffer).prototype.-4':{get(){↩ @.length<4? undefined : @[@.length-4] },set(ι){ @.length<4 || (@[@.length-4] = ι) }},

'(Array|String|Buffer).prototype.windows':λ(L){↩ (@.length-L+1).map(i=> @.slice(i,i+L)) },
})
E.Time = λ(ι){ r ← arguments.length===0? new Date() : ι instanceof Date? ι : new Date(Tnum(ι)? ι*1e3 : ι); r.toString = λ(){↩ util.inspect(@) }; ↩ r }
fmt ← λ(a,b){ t ← @.__local? moment(@).format('YYYY-MM-DD[T]HH:mm:ss.SSS') : @.toISOString(); t = t.slice(a,b); if (!@.__local && b > 10) t += 'Z'; ↩ t }
P(()⇒{
'Date.prototype.inspect':λ(d,opts){↩ opts.stylize(isNaN(+@)? 'Invalid Date' : @.getUTCSeconds()!==0? @.ymdhms : @.getUTCMinutes()!==0? @.ymdhm : @.getUTCHours()!==0? @.ymdh : @.ymd, 'date')},
'Date.prototype.local':{get(){↩ new Date(@)._.assign({__local:true})}},
'Date.prototype.i':{get(){↩ +@ / 1e3}},
'Date.prototype.ym':      {get(){↩ fmt.call(@,0,'YYYY-MM'.length)}},
'Date.prototype.ymd':     {get(){↩ fmt.call(@,0,'YYYY-MM-DD'.length)}},
'Date.prototype.ymdh':    {get(){↩ fmt.call(@,0,'YYYY-MM-DDTHH'.length)}},
'Date.prototype.ymdhm':   {get(){↩ fmt.call(@,0,'YYYY-MM-DDTHH:mm'.length)}},
'Date.prototype.ymdhms':  {get(){↩ fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss'.length)}},
'Date.prototype.ymdhmss': {get(){↩ fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.length)}},
'Date.prototype.iso':     {get(){↩ fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.length)}},
'Date.prototype.hms':     {get(){↩ fmt.call(@,'YYYY-MM-DDT'.length,'YYYY-MM-DDTHH:mm:ss'.length)}},
})
hash ← ι=>{t←;↩ JSON.stringify(Object.prototype.toString.call(ι)==='[object Object]'? (t={}, ι._.keys().sort().forEach(k=> t[k]=ι[k]), t) : ι) }
_.mixin({difference_eq:λ(ι,…a){ t ← ι._.groupBy(hash); a.forEach(ι=> ι.forEach(ι=> delete t[hash(ι)])); ↩ t._.values()._.flatten(true) }})
if (NODEp){t←;
Immediate ← Object.getPrototypeOf(t=setImmediate(λ(){})); clearImmediate(t)
Timeout ← Object.getPrototypeOf(t=setTimeout(λ(){},0)); clearTimeout(t)
Immediate.clear = λ(){ clearImmediate(@) }
Timeout.clear = λ(){ @._repeat? clearInterval(@) : clearTimeout(@) }
Immediate.ref = Immediate.unref = λ(){}
}
E.schema = (λ(){
	sc_merge ← λ(a,b){ak ← _.keys(a); bk ← _.keys(b); bk._.difference(ak).forEach(k=> a[k] = b[k]); _.intersection(ak,bk).forEach(k=> a[k] = !Tprim(a[k])? sc_merge(a[k],b[k]) : !Tprim(b[k])? 'error' : a[k]); ↩ a }
	↩ ι=> Tbool(ι)? true : Tstr(ι)? '' : Tnum(ι)? 0 : Tarr(ι)? ι.length===0? [] : [ι.map(schema).reduce(sc_merge)] : _.pairs(ι).map(ι=> [ι[0],schema(ι[1])])._.object()
	})()
E.walk = (ι,f,k,o)=>( Tprim(ι)||ι._.forEach((ι,k,o)=> walk(ι,f,k,o)), f(ι,k,o), ι )
E.walk_reduce = (ι,f,k,o)=> Tprim(ι)? ι : Tarr(ι)? ( ι = ι.map((ι,k,o)=> walk_reduce(ι,f,k,o)), f(ι,k,o) ) : ( ι = _(ι).map((ι,k,o)=> [k,walk_reduce(ι,f,k,o)])._.object(), f(ι,k,o) )
// E.walk_obj_map = (ι,f,k,o)=> Tprim(ι)? ι : Tarr(ι)? ι.map((ι,k,o)=> walk_obj_map(ι,f,k,o)) : ( ι = _(ι).map((ι,k,o)=> [k,walk_obj_map(ι,f,k,o)])._.object(), f(ι,k,o) )
E.util_inspect_autodepth = λ(ι,opt={}){ opt.L || (opt.L = 1e6); last←; for(i←1;;i++){ r ← util.inspect(ι,{maxArrayLength:opt.L/3 |0, depth:i}._.assign(opt)); if (r===last || r.length > opt.L) ↩ last===undefined? '<too large>' : last; last = r } }

E.robot_key_tap = ι=> require_new(φ`~/code/scratch/keyrc/index.ζ`).robot_key_tap(ι)
E.KEY_once = (…a)=> require_new(φ`~/code/scratch/keyrc/index.ζ`).KEY_once(…a)

// ---------------------------------- .ζrc ---------------------------------- //
process.env.PATH = ['./node_modules/.bin','/usr/local/bin',…(process.env.PATH||'').split(':'),'.']._.uniq().join(':')
q0 ← ι=> Tstr(ι)? ι : util.inspect(ι,{depth:null, maxArrayLength:null})
q ← ι=> Tarr(ι)? ι.map(q0).join('\n') : q0(ι)
E.p = λ(ι){↩ arguments.length === 0? shᵥ`pbpaste`+'' : shₐ`${q(ι===undefined? '' : ι)} |`` pbcopy` }
E.sb = λ(ι){↩ arguments.length === 0? sublᵥ`view = sublime.active_window().active_view(); view.substr(Region(0,view.size()))` : shₐ`${q(ι)} |`` open -a 'Sublime Text.app' -f` }
E.nice_url = λ(ι){t←; urijs ← require('urijs'); {sourcemap} ← ι; ι=ι+''
	// very nice google maps urls
	// if url ≈ google.com/maps/
	// fetch short url:
	// 	wait-click $('#searchbox-hamburger')
	// 	wait-click $('[jsaction="settings.share"]')
	// 	wait-check $('#share-short-url')
	// 	t ← $('.widget-share-link-url').val() wait ι=> ι.re`^https?://goo.gl/maps/`
	// 	return t
	// 	$('.modal-container').click()
	// wait-check: if not $`${ι}:checked`; ι.click(); wait for $`${ι}:checked`
	// wait-click: wait for ι.length; ι.click()
	// decode: parse curl https://goo.gl/maps/7s6wKcW8zUC2

	if (t=ι.re`^"(.*)"$`) ↩ '“'+t[1]+'”' //! bad hack

	apply_regexes ← regs=> multiline(regs).split(/\n/g).map(λ(t){ [a,b] ← t.split(/  +/g); ι = ι.replace(RegExp(a),b) })
	URL ← /\b(?:(?:https?|chrome):\/\/|(?:file|mailto):)(?:[^\s“”"<>]*\([^\s“”"<>]*\))?(?:[^\s“”"<>]*[^\s“”"<>)\]}⟩?!,.:;])?/g
	parse_alicetext ← ι=> _.zip(ι.split(URL).map(ι⇒ {type:'text', ι}), (ι.match(URL)||[]).map(ι⇒ {type:'url', ι}))._.flatten(true).filter(ι=> !(ι === undefined || (ι.type === 'text' && ι.ι === '')))

	// ι = parse_alicetext(ι).map(λ(ι){t←; ι.type==='url' && (t=urijs(ι.ι)).domain()+t.path()==='google.com/webhp' && t.path('/search') && (ι.ι = t+''); ↩ ι})._.map('ι').join('')

	if (sourcemap && sourcemap.title && sourcemap.url && (t=urijs(ι.slice(…sourcemap.url)),
		t.domain() in {'github.com':0} ||
		t.domain()+t.path()==='google.com/search'
		)) ι = ι.slice(…sourcemap.url)
	
	ι = ι.replace(/%CE%B6/g,'ζ')
	apply_regexes(λ(){/*
	\bhttps://         http://
	\b(http://)www\.   $1
	\b(http://)(?:mail\.)?(google\.com/mail/)u/0/[?&]?#(?:(?:label|search)/[\w%+]+|\w+)/(\w+)        $1$2#all/$3
	 - Gmail( http://google\.com/mail/)                $1
	 - [\w.]+@gmail\.com( http://google\.com/mail/)    $1
	Fwd: (.* http://google\.com/mail/)                 $1
	\b(http://)en\.(?:m\.)?(wikipedia\.org/)           $1$2
	\b(http://)youtube\.com/watch[?&]v=([\w-_]+)       $1youtu.be/$2
	\b(http://youtu\.be/[\w-_]+)[?&]feature=youtu\.be  $1
	\b(http://youtu\.be/[\w-_]+)&(\S*)$                $1?$2
	 - YouTube( http://youtu\.be/)                     $1
	 \([oO]fficial [vV]ideo\)( http://youtu\.be/)      $1
	\b(http://)smile\.(amazon\.com/)                   $1$2
	\b(http://docs\.google\.com/document/d/[\w_-]+)/edit(?:[?&]ts=\w+)?$  $1
	\b(http://docs\.google\.com/spreadsheets/d/[\w_-]+)/edit(?:#gid=0)?$  $1
	 - Google Docs( http://docs\.google\.com/)         $1
	\b(http://dropbox\.com/\S*)[?&]dl=0$               $1
	\b(http://)facebook(\.com/)                        $1fb$2
	\b(http://fb\.com/)profile\.php\?id=               $1
	\(\d+\) (.* http://fb\.com/)                       $1
	 - Wikipedia, the free encyclopedia( http://wikipedia\.org/)  $1
	 - Album on Imgur( http://imgur\.com/)             $1
	 - Google Maps( http://google\.com/maps/)          $1
	*/})

	ι = parse_alicetext(ι).map(λ(ι){t←;
		if (ι.type === 'url') {
			uri ← urijs(ι.ι)
			switch (uri.domain()) { default: ↩ ι
				break; case 'amazon.com':
					uri.removeSearch(['sa-no-redirect','keywords','qid','ie','s','sr','tag','linkCode','camp','creative','creativeASIN'])
					uri.filename().re`^ref=[\w_]+$` && uri.filename('')
					if (t=uri.resource().re`^/(?:[\w-]+/)?(?:dp|gp)/(?:product/)?(\w+)/?$`) {ι.ι = 'http://amzn.com/'+t[1]; ↩ ι}
				break; case 'fb.com': uri.removeSearch(['fref','hc_location','_rdr','pnref'])
				break; case 'google.com': if (uri.segment()._.isEqual(['search'])){ uri.removeSearch(['gws_rd','aqs','sourceid','es_sm','ie']); uri.hasSearch('q') && uri.removeSearch('oq') }
				}; ι.ι = uri+'' }
		↩ ι})._.map('ι').join('')

	apply_regexes(λ(){/*
	: \d{5,}: Amazon(?:Smile)?: Books( http://amzn.com/)        $1
	*/})

	// --------- todo --------- //
	// http://smile.amazon.com/gp/product/0300078153
	// Seeing like a State http://amzn.com/0300078153

	// https://docs.google.com/spreadsheets/d/1wfFMPo8n_mpcoBCFdsIUUIt7oSm7d__Duex51yejbBQ/edit#gid=0
	// http://goo.gl/0nrUfP

	// generalize the “fix & to ?” to many different things

	// http://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	// A Big Little Idea Called Legibility http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	// http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility
	// http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility (3K words)

	↩ ι}
E.sfx = λ(ss,…ιs){ ι ← ss[0]
	shₐ`afplay ~/code/scratch/dotfiles/${ι}.wav`
	if (ι==='done' && osaᵥ`volume settings`['output muted']){ br ← brightness; br.get().then(old=>{ br.set(0); (()=> br.set(old)).in(0.2) }) }
	}
E._alert = (a,b,c)=> osaₐ`system events: display alert ${a} …${b && osa`message ${b}`} …${c && osa`giving up after ${c}`}` //! design better, then rename to alert
E.browser = ι=>{
	ι = ι.re`^https?://`? ι : 'https://www.google.com/search?q='+encodeURIComponent(ι)
	shₐ`'/Applications/Google Chrome.app/Contents/MacOS/Google Chrome' ${ι}`; osaₐ`chrome: activate` }
def(E,'brightness',λ(){
	br ← hsᵥ? {
		get(){↩Π( hsᵥ`hs.brightness.get()`/100 )},
		set(ι){↩Π( hsᵥ`hs.brightness.set(${ι*100|0})` )},
		ambient(){↩ hsᵥ`hs.brightness.ambient()` },
		} : npm('brightness@3.0.0')
	br.set_overlay = ι=> br.set(ι > 0.5? (ι===1? 1 : ι-1/64) : (ι===0? 0 : ι+1/64)).then(()=> robot_key_tap('⇧⌥FnF'+(ι > 0.5? 2 : 1)) )
	↩ br })
🔅🔆 ← go=>{ ιs ← [0,1,2.5,5.5,10.5,16].map(ι=>ι/16); ↩ brightness.get().then(br=> brightness.set_overlay( ιs[min(max( 0, find_closest_ISU(ιs,br) + go ), ιs.length-1 )] )) }
E.🔅 = ()=> 🔅🔆(-1)
E.🔆 = ()=> 🔅🔆(1)
E.googl = ι=> JSON.parse(shᵥ`curl -s ${'https://www.googleapis.com/urlshortener/v1/url?key='+φ`~/.auth/googl`.text.trim()} -H 'Content-Type: application/json' -d ${JSON.stringify({longUrl:ι})}`+'').id
E.restart_and_keep_alive = prog=>{
	Label ← 'local.'+prog.replace(/\W/g,'_')
	t ← φ`~/Library/LaunchAgents/${Label}.plist`; t.ι = {Label, KeepAlive:true, ProgramArguments:['sh','-c',sh`PATH=${process.env.PATH}; ${prog}`]}
	shᵥ`launchctl unload ${t} &>/dev/null; launchctl load ${t}`
	}
E.moon = ι=>{ ι||(ι=Time()); moons ← […'🌑🌒🌓🌔🌕🌖🌗🌘']; ↩ moons[floor((npm('suncalc@1.7.0').getMoonIllumination(ι).phase * moons.length + 0.5) % moons.length)] }

// ----------------------------- metaprogramming ---------------------------- //
P(()⇒{ 'RegExp.prototype.λ':λ(ι){↩ ι===undefined || ι===null? null : ι.match(@) } })
P(()⇒{ 'RegExp.prototype.g':{get(){↩ RegExp(@.source,@.flags+'g') }} })
P(()⇒{ 'RegExp.prototype.i':{get(){↩ RegExp(@.source,@.flags+'i') }} })
P(()⇒{ 'RegExp.prototype.m':{get(){↩ RegExp(@.source,@.flags+'m') }} })
// --- metaprogramming → runtime macros built on top of template literals --- //
is_template ← E.is_template = ([ss,…ιs])=> ss && Tarr(ss.raw) && ss.raw.length-1 === ιs.length
tmpl_flatten ← (raw2,ιs2)=> _.zip(raw2,ιs2)._.flatten(true).slice(0,-1).filter(ι=> ι!=='')
simple_template ← λ(ss,ιs,filter){ is_template([ss,…ιs]) || ‽
	falsy ← ι=> ι===undefined||ι===null||ι===false
	if (Tarr(filter)){ [root,join] ← filter; filter = ι=> Tarr(ι)? ι.map(ι=> root`${ι}`).join(join) : falsy(ι)? '' : undefined }
	filter_special ← ι=> falsy(ι)? '' : ι+''
	ι ← tmpl_flatten( ss.raw.map(ι=> ι.replace(/\\(?=\$\{|`)/g,'')), ιs.map(ι⇒{raw:ι}) )
	for(i←0;i<ι.length-1;i++) if (Tstr(ι[i]) && !Tstr(ι[i+1])) ι[i] = ι[i].replace(/…$/,λ(){ ι[i+1] = filter_special(ι[i+1].raw); i++; ↩ '' })
	filter && (ι = ι.map(λ(ι){t←; ↩ Tstr(ι)? ι : (t=filter(ι.raw), t===undefined? ι : t) }))
	↩ ι}
easy_template ← E.easy_template = (λ(){
	read ← (ss,ιs)=> tmpl_flatten(ss.raw,ιs.map(ι=>[ι]))
	show ← λ(ι){ raw ← ['']; ιs ← []; ι.forEach(ι=> Tstr(ι)? raw[-1]+=ι : (ιs.push(ι), raw.push('')) ); ↩ [{raw},…ιs] }
	↩ f=> (ss,…ιs)=> f(read(ss,ιs),show)
	})()
E.JSON_pretty = λ(ι,replacer){
	seen ← []
	T ← '  ' // tab
	wrap_width ← 140
	indent_show ← ι=> show(ι).replace(/\n/g,'\n'+T)
	show ← λ(ι){t←;
		if (ι===undefined||ι===null) ↩ 'null'
		replacer && (ι = replacer(ι))
		while (ι.toJSON) ι = ι.toJSON()
		switch (typeof(ι)==='object'? Object.prototype.toString.call(ι) : typeof(ι)) {
			case 'string': case '[object String]': ↩ JSON.stringify(ι)
			case 'boolean': case '[object Boolean]': case 'number': case '[object Number]': ↩ ι+''
			case 'function': ↩ 'null'
			default:
				if (seen.indexOf(ι) !== -1) throw TypeError('Converting circular structure to JSON')
				seen.push(ι)
				if (Tarr(ι)) { [a,b] ← '[]'; ι = ι.map(indent_show); for (i←0;i<ι.length;i++) ι[i]===undefined && (ι[i] = 'null') }
				else { [a,b] ← '{}'; ι = ι._.pairs().filter(ι=> !(ι[1]===undefined || Tfun(ι[1]))).map(ι=> show(ι[0])+': '+indent_show(ι[1])) }
				seen.pop()
				↩ (t=a+ι.join(', ')+b).length <= wrap_width? t : a+'\n'+T+ι.join(',\n'+T)+'\n'+b
				} }
	↩ show(ι) }

E.re = λ(ss,…ιs){ ι ← simple_template(ss,ιs,[(…a)=>re(…a).source,'']); ENC ← ι=> (ι+'').replace(/([.*+?^=!:${}()\[\]|\\])/g, '\\$1'); ↩ RegExp(ι.map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join(''),'u') }
P(()⇒{ 'String.prototype.re':{get(){↩ (ss,…ιs)=> @.match(re(ss,…ιs))}} })

E.js = E.py = λ(ss,…ιs){ ENC ← JSON.stringify; ↩ simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('') }

E.sh = λ(ss,…ιs){ENC ← ι=> "'"+(ι+'').replace(/'/g,"'\\''")+"'"; ↩ simple_template(ss,ιs,[sh,' ']).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('')}
ellipsify ← ι=> util_inspect_autodepth(ι.slice(0,100))+(ι.length>100?'…':'')
if_sh_err ← (name,code,ι)=>{ if (ι.status!==0) throw Error(name+'`'+code+'` → status:'+ι.status+', stderr:'+ellipsify(ι.stderr+''))._.assign(ι._.pick('status','stdout','stderr')) }
E.shᵥ = λ(ss,…ιs){code ← sh(ss,…ιs)
	ι ← child_process.spawnSync(code,{shell:true})
	if_sh_err('shᵥ',code,ι)
	↩ ι.stdout._.assign({ toString(…a){ι ← Buffer.prototype.toString.call(@,…a); ↩ a.length===0? ι.replace(/\n$/,'') : ι} }) }
str_to_fd_stream ← ι=>{ t ← φ`/tmp/${rand_id(20)}`; t.text = ι; fd ← fs.openSync(t+'','r'); ↩ fs.createReadStream(null,{fd}) }
_shₐ ← (ss,ιs,opt={})=>{
	if (ss.length===2 && ss[0]==='' && ss[1].re`^ *\|$`){ opt.stdio && ‽; opt.stdio = [str_to_fd_stream(ιs[0]),,,]; ↩ shₐ2(opt) }
	else ↩ new Promise((yes,no)=>{
		code ← sh(ss,…ιs)
		ι ← child_process.spawn(code,{shell:true}._.assign(opt._.pick('stdio')))
			.on('exit',λ(status){ if_sh_err('shₐ',code,{status}._.assign(ι)); (status===0? yes : no)(ι) })
		}) }
E.shₐ = (ss,…ιs)=> _shₐ(ss,ιs)
E.shₐ2 = opt=>(ss,…ιs)=> _shₐ(ss,ιs,opt)

E.osa = λ(ss,…ιs){t←;
	ι ← simple_template(ss,ιs)
	//! jesus this is a mess
	if (Tstr(ι[0]) && (t=ι[0].re`^(?!tell )([\w ]+):`)) {ι[0] = ι[0].slice(t[0].length); ι = [osa`tell app ${t[1]};`, …ι, '; end tell']}
	if (!Tstr(ι[0]) && Tstr(ι[0].raw) && ι[0].raw.re`^[\w ]+$` && Tstr(ι[1]) && (t=ι[1].re`^ *:`)){ ι[1] = ι[1].slice(t[0].length); ι = [osa`tell app ${ι.shift().raw};`, …ι, '; end tell'] }
	↩ ι.map(ι=> !Tstr(ι)? applescript.print(ι.raw) : ι.replace(/;/g,'\n')).join('') }
E.osaᵥ = λ(ss,…ιs){ ι ← osa(ss,…ιs); ↩ applescript.parse(shᵥ`osascript -ss -e ${ι}`+'') }
E.osaₐ = λ(ss,…ιs){ ι ← osa(ss,…ιs); shₐ`osascript -ss -e ${ι}` }

E.terminal_do_script = λ(a,b){ φ`/tmp/__·`.ι = a; osaᵥ`terminal: do script "·" …${b}` }
E.chrome_simple_osaᵥ = (ι,tab)=> osaᵥ`chrome: execute window 1's …${tab} javascript ${ζ_compile(ι)}`
E.chrome_simple_js_ᵥ = (ι,tab)=> osaᵥ`chrome: tell window 1's …${tab} to set URL to ${'javascript:'+ζ_compile(ι)}`
// E.chromeᵥ = ‡ not actually used ‡ wait, nope, is actually used, but mostly in one-off scripts
	// λ(ι,tab){tab = tab!==undefined? 'tab '+(tab+1) : 'active tab'
	// 	// E.chrome_$ᵥ = λ(ι,tab){r←; $null ← '__$null_'+rand_id(10); fst ← 1; while ((r=chromeᵥ("if (window.jQuery){"+ι+"} else {"+(fst? (fst=0, "t ← document.createElement('script'); t.src = 'https://code.jquery.com/jquery-2.1.4.min.js'; document.getElementsByTagName('head')[0].appendChild(t)") : "")+"; '"+$null+"'}",tab))===$null); ↩ r}
	// // probably add a rand_id(10) call to '#applescript_hack'
	// 	t ← "t ← document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); ι ← (0,eval)("+JSON.stringify(ζ_compile(ι))+"); t ← document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(ι); t2 ← document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); undefined"
	//	chrome_simple_js_ᵥ(t,tab)
	// 	t ← "document.querySelectorAll('#applescript_hack')[0].textContent"
	// 	↩ JSON.parse(chrome_simple_osaᵥ(t,tab) || '""') }

E.sublᵥ = λ(ss,…ιs){
	ENC ← JSON.stringify; ι ← simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('')
	t ← JSON.parse(fs_ipc.emit(34289,ι)); t===null && (t = undefined); ↩ t }
E.sb_editᵥ = view=>(ss,…ιs)=>{ sublᵥ`edit(${view},${py(ss,…ιs)})` }

def(E,'hsᵥ',()=> !(shᵥ`which hs ;:`+'')? undefined : λ(ss,…ιs){
	ENC ← ι=> Tstr(ι) || Tnum(ι)? JSON.stringify(ι) : ‽; ι ← simple_template(ss,ιs).map(ι=> !Tstr(ι)? ENC(ι.raw) : ι).join('')
	// -t       Uses the given argument timeout as the receive timeout, instead of the default of 4 seconds.
	t ← (shᵥ`hs -c ${ι}`+'').split('\n')[-1]; try{↩ JSON.parse(t)[0] }catch(e){↩ t } } )

def(E,'φ',λ(){
	ENC ← ι=> ι.re`/`? ι.replace(/[\/%]/g, encodeURIComponent.X) : ι
	φ['⁻¹'] = ι=> /%2F/i.λ(ι)? ι.replace(/%2[F5]/gi, decodeURIComponent.X) : ι

	existsSync ← ι=>{ try{ fs.accessSync(ι); ↩ true }catch(e){ ↩ false } }
	mkdir_p ← λ Λ(ι){ try{ fs.mkdirSync(ι) }catch(e){ if (e.code==='EEXIST'||e.code==='EISDIR') ↩; t ← path.dirname(ι); if (e.code!=='ENOENT' || ι===t) throw e; Λ(t); fs.mkdirSync(ι) } }
	// walk ← λ*(root,files){root += '/'
	// 	walk_ ← λ*(ι){try {l ← fs.readdirSync(root+ι); for (i←0;i<l.length;i++){t ← ι+l[i]; try{ fs.statSync(root+t).isDirectory()? (yield root+t, yield* walk_(t+'/')) : (files && (yield root+t)) }catch(e){} }} catch(e){} }
	// 	yield* walk_('') }
	read_file ← λ(ι){ try{↩ fs.readFileSync(ι) }catch(e){ if (!(e.code==='ENOENT')) throw e } }
	ensure_exists ← λ(ι,ifdne){ existsSync(ι) || ( mkdir_p(path.resolve(path.dirname(ι))), fs.writeFileSync(ι,ifdne) ) }
	write_file ← λ(ι,data){ try{ fs.writeFileSync(ι,data) }catch(e){ if (!(e.code==='ENOENT')) throw e; ensure_exists(ι,data) } }
	open ← λ(ι,ifdne,f){
		ensure_exists(ι,ifdne); Lc ← new Φ(ι).size
		fd ← fs.openSync(ι,'r+'); f({
			get L(){↩ Lc},
			read(i,L){t ← new Buffer(L); fs.readSync(fd,t,0,L,i) === L || ‽; ↩ t},
			write(ι,i){L ← fs.writeSync(fd,ι,i); Lc = max(Lc, L+i)},
			truncate(L){fs.ftruncateSync(fd,L); Lc = min(Lc,L)},
			indexOf_skipping(from,to,step,find,skip){fl←@
				if (from<0) from += fl.L; if (to<0) to += fl.L; from = min(max(0, from ),fl.L-1); to = min(max(-1, to ),fl.L)
				if (!(step===-1 && from>to)) ‽('TODO')
				d ← fl.read(to+1,from-to)
				for(i←from;i>to;i+=step) {if (d[i-(to+1)]===find) ↩ i; else if (String.fromCodePoint(d[i-(to+1)]).match(skip)); else ↩ null}
				},
			}); fs.closeSync(fd)}
	globmatch ← (glob,ι)=> re`^…${glob._.map(ι=> ι==='*'? '.*' : re`${ι}`.source).join('')}$`.λ(ι)
	def(φ,'cwd',{get(){↩ new Φ(process.cwd()) }, set(ι){ t ← φ(ι+'')._ι; mkdir_p(t); process.chdir(t) }})

	normHs ← λ(ι){if (ι._.isEqual(['~'])) ↩ [process.env.HOME]; Tstr(ι[0]) && (ι[0] = ι[0].replace(/^~(?=\/)/,process.env.HOME)); ↩ ι}
	λ Φ(ι){@._ι = ι}; Φ.prototype = {
		φ,
		toString(){↩ @._ι },
		toJSON(){↩ {type:'φ', ι:@._ι} },
		inspect(ˣ,opts){↩ opts.stylize('φ','special')+opts.stylize(util_inspect_autodepth(@._ι.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') },
		get size(){↩ fs.statSync(@._ι).size },
		get nlink(){↩ fs.statSync(@._ι).nlink },
		get mtime(){↩ fs.statSync(@._ι).mtime },
		get birthtime(){↩ fs.statSync(@._ι).birthtime },
		get url(){↩ encodeURI('file:'+@.root('/')) }, //! should this be part of root
		get is_dir(){ try{↩ fs.statSync(@._ι).isDirectory() }catch(e){↩ false } },
		get name(){↩ path.basename(@._ι) },
		BAD_exists(){↩ existsSync(@._ι) },
		TMP_children(){↩ (λ Λ(ι){↩ φ(ι).is_dir? fs.readdirSync(ι).map(t=> ι+'/'+t).mapcat(Λ) : [ι] })(@._ι) },
		TMP_parents(){ r ← [@.root('/')]; while(r[-1].φ`..`+'' !== r[-1]+'') r.push(r[-1].φ`..`); ↩ r.slice(1) },
		root(x){switch(arguments.length){default: ‽
			case 0: ↩ @._ι[0]==='/'? '/' : '.'
			case 1: ↩ new Φ( x==='/'? path.resolve(@._ι) : x==='.'? path.relative(x,@._ι) : ‽('not yet implemented: nonstandard roots') )
			}},
		ensure_dir(){ @.φ`..`.BAD_exists() || mkdir_p(@.φ`..`+''); ↩ @ },

		// get ι(){↩},
		set ι(ι){
			if (@.is_dir) ‽('TODO')
			if (ι == null){ try{ fs.unlinkSync(@._ι) }catch(e){}; ↩ }
			e ← path.extname(@._ι)
			if (e==='.csv'){ @.csv = ι; ↩ }
			if (e==='.xml'){ @.xml = ι; ↩ }
			if (e==='.plist'){ @.plist = ι; ↩ }
			ι = e==='.json'? JSON_pretty(ι) :
				Tstr(ι)? ι :
				JSON_pretty(ι)
			write_file(@._ι,ι) },
		get buf(){↩ read_file(@._ι) || new Buffer(0) },
		set buf(ι){ write_file(@._ι,ι) },
		get base64(){↩ new Buffer(@.text,'base64') },
		// set base64(ι){},
		get text(){↩ (read_file(@._ι) || '')+'' },
		set text(ι){ write_file(@._ι,ι) },
		get lines(){↩ λ(…ιs){
			d ← ((read_file(@._ι)||'\n')+'').replace(/\n$/,'').split('\n')
			if (ιs.length > 1) ↩ ιs.map(ι=> Tnum(ι)? d[ι] : d.slice(/^(\d+):$/.λ(ι)[1]|0).join('\n')+'\n')
			else if (ιs.length === 0){
				↩ {
					map(…a){↩ d.map(…a)},
					} }
			else ‽('TODO')
			}},
		set lines(ι){ write_file(@._ι, ι.join('\n')+'\n') },
		get json(){↩ JSON.parse(read_file(@._ι) || 'null') },
		set json(ι){ write_file(@._ι, JSON_pretty(ι)) },
		get json2(){ι ← @.json; (λ Λ(ι,k,o){if (ι.type==='Buffer') {
			o[k] = 'data' in ι || 'utf8' in ι? new Buffer(ι.data||ι.utf8) : 'base64' in ι? new Buffer(ι.base64,'base64') : ‽
			} else if (!Tprim(ι)) _(ι).forEach(Λ)})(ι); ↩ ι},
		set json2(ι){
			@.text = JSON_pretty(ι,λ(ι){t←;
			if (Buffer.isBuffer(ι)) ↩ ι.equals(new Buffer(t=ι+''))? {type:'Buffer', utf8:t} : {type:'Buffer', base64:ι.toString('base64')}
			↩ ι})},
		get ini(){↩ npm('ini@1.3.4').parse(@.text) },
		// set ini(ι){},
		// get csv(){↩},
		set csv(ι){ t ← φ`/tmp/csv_${rand_id(25)}`; t.json = ι; shᵥ`ζ ${`npm('csv@0.4.6').stringify(φ(a0).json,λ(e,ι){φ(a1).buf = ι})`} ${t+''} ${@.root('/')+''}` },
		// get xml(){↩ JSON.parse(shᵥ`ζ ${js`npm('xml2js@0.4.17').parseString(φ(${@+''}).text,λ(e,ι){ process.stdout.write(JSON.stringify(ι)) })`}`+'') },
		set xml(ι){ @.text = npm('xmlbuilder@8.2.2').create(ι,{allowSurrogateChars:true}).end({pretty:true}) },
		// get plist(){↩  },
		set plist(ι){ @.text = npm('plist@2.0.1').build(ι) },
		get json_array__synchronized(){↩ λ(…ιs){_ι←@._ι
			if (ιs.length) ‽('TODO')
			d ← JSON.parse((read_file(_ι)||'[]')+'')
			↩ {
			get length(){↩ d.length},
			push(…a){a.map(λ(ι){
				d.push(ι)
				open(_ι,'[]',λ(fl){
					i ← fl.indexOf_skipping(-1,-1e4,-1,']'.codePointAt(),/[ \n\t]/) || ‽('bad file')
					is_0 ← fl.indexOf_skipping(i-1,-1e4,-1,'['.codePointAt(),/[ \n\t]/)!==null
					fl.write((is_0?'':',')+JSON.stringify(ι,null,'  ')+']',i)
					})
				})},
			filter(f){↩ d._.filter(f)},
			} }},
		}
	λ Φs(ι){@._ι = ι}; Φs.prototype = {
		inspect(ˣ,opts){↩ opts.stylize('φ','special')+util.inspect(@._ι,opts)},
		get name_TMP(){↩ @._ι.map(ι=> new Φ(ι).name)}, // fs.readdirSync
		get φs(){↩ @._ι.map(ι=> new Φ(ι))}, // [φ]
		}
	λ φ(ss,…ιs){
		head ← @ instanceof Φ && @._ι
		if (@ instanceof Φs) ‽('not yet implemented')
		tmpl ← is_template([ss,…ιs])
		if (tmpl){ι ← simple_template(ss,ιs,[φ,'/']); if (ι.filter(Tstr).join('').re`\*|\{[^}]*?,`) {
			if (ι.length > 1) ‽('not yet implemented * ** ${}',ι)
			ι = normHs(ι)
			ι = ι[0]
			if (ι.includes('**')) ‽('not yet implemented ** ${}',ι)
			r ← ['.']
			if (ι[0]==='/') r = ['/']
			ι.split('/').forEach(λ(ι){
				if (ι==='')↩;
				r = r.mapcat(λ(r){
					if (ι === '.') ↩ [r]
					if (ι === '..') ↩ [r==='.'? '..' : r.split('/').every(ι=>ι==='..')? r+'/..' : path.dirname(r)]
					↩ fs.readdirSync(r).filter(b=> globmatch(ι,b)).map(b=> r+'/'+b)
					})
				})
			↩ new Φs(r) } }
		else {ι ← ss; if (ιs.length || Tarr(ι)) ‽('not yet implemented'); if (ι instanceof Φs) ‽('not yet implemented')}
		if (tmpl){ι = normHs(ι).map(ι=> !Tstr(ι)? ENC(ι.raw+'') : ι).join('')}
		else if (ι instanceof Φ){↩ head && ι._ι[0]!=='/'? new Φ(head+'/'+ι._ι) : ι}
		else {ι = (ι+'').replace(/^~(?=\/|$)/,process.env.HOME)}
		↩ new Φ(path.normalize(head? head+'/'+ι : ι).replace(/(?!^)\/$/,'')) }
	↩ φ})

// ---------------------------------- main ---------------------------------- //
sh_ify ← (ι,yes)=>
	T.Promise(ι)? ι.then(yes)
	: yes(
		ι===undefined? ''
		: Tstr(ι)? ι
		: Tbool(ι)? (process.exitCode = ι?0:1, '')
		: (λ(){ try{↩ JSON.stringify(ι) }catch(e){↩ ι+'' } })() )
eval_ ← λ ᵃΘΛᴳᶜjεᴺ(ι){ 
	try{ try{ new vm.Script(ι); ↩ (0,eval)(ι) }catch(e){ if (!(e.name==='SyntaxError' && e.message==='Illegal return statement')) throw e; ↩ (0,eval)('(()=>{'+ι+'})()') } }
	catch(e){ e!==undefined && e!==null && Tstr(e.stack) && (e.stack = e.stack.replace(/    at ᵃΘΛᴳᶜjεᴺ[^]*/,'    at <eval>')); throw e }
	}
E.ζ_main = λ(opt){ opt={compile:ζ_compile}._.assign(opt)
	argv ← process.argv
	// if (!opt.server_alive && !( argv.length===2 || argv[2].re`^\.?/` || argv[2]==='--fresh' ) && !argv[1].re`ζλ`)
	// 	restart_and_keep_alive(φ(__dirname+'/../server.ζ')+'')
	argv[0] = 'ζ'
	argv[2]==='--fresh' && argv.splice(2,1)
	if (argv.length===2){ argv[1] = '<repl>'; global.rl = ζ_repl_start(opt) }
	else if (φ(argv[2]).BAD_exists() || argv[2].re`^\.?/`){ argv.splice(1,1); t ← φ(argv[1]).root('/')+''; o←Module._cache;m←Module._resolveFilename(t,null,true);oι←o[m]; o[m] = undefined; Module._load(t,null,true); o[m] = oι }
	else { argv[1] = '<eval>'
		global.require = require; global.code = argv[2]; global.a = argv.slice(3); global.ι = global.a0 = a[0]; global.a1 = a[1]
		t ← eval_(opt.compile(code)); r ← code.re`;\s*$`? undefined : t; sh_ify(r,ι=> process.stdout.write(ι)) }
	}

// ---------------------- finish local metaprogramming ---------------------- //
prop_assign(E,global)
patched ← new WeakSet([global])
module.exports = to=>{ patched.has(to) || (cn.log('\x1b[34m[ζ]\x1b[0m patching'), cn.log(Error('<stack>').stack), patched.add(to), prop_assign(E,to), patches.forEach(ι=> ι(to))) }

// -------------------------------- call main ------------------------------- //
if (!module.parent) E.ζ_main()

// ------------------ really important remaining work for φ ----------------- //
/*
formats include
	image               
	pixels              
	png                 .png
	jpg                 .jpg
	plist               /^<\?xml / && /<\/plist>\s*$/           read: npm::plist.parse(it)     show: npm::plist.build(it)
	xml                 .xml || /^<\?xml /
	base64              .64
	pixels (grey)       
	stdin               fd:0
	FIFO                fd:0...
	:executable         ,/^#!/ | try{fs.accessSync(ι,fs.X_OK); ↩ true} catch(e){↩ false}
	directory relative
	directory absolute
formats are Really stream formats
the formats are complicated to interact with, because
* GET POST PUT have really tangly apis for all sorts of efficiency concerns
* DELETE especially, we want to make some distinctions to make sure we don’t fuck things up accidentally (although trash could help)

// paths can have extensions, which are often meaningful. (basename/filename, ext/suffix. path.basename,dirname,extname)

// we need to be careful with non-atomic transactions
// we need to think about how this interacts with concurrency
// we need to think about how this interacts with distributed machines (e.g. mixing file and http URLs)
// 	“like, it should be caching urls all the time.”

// --------------------- things i need ** globbing to do -------------------- //
scratch/scratch.txt:107:φ`**`.map(ι=> [ι+'',ι.get()])._.groupBy(1)._.values().map(ι=> ι._.map(0)).filter(ι=> ι.length > 1)
scratch/sublime/index.ζ:60:	φ(arg.in).φ`**`.filter(ι=> !ι.dir()).map(λ(ι){ι+=''; t←; ι = ι.slice(arg.in.length).replace(/^\//,'')
scratch/sublime/index.ζ:66:	out ← φ(arg.out).φ`**`.filter(λ(ι){ι+=''; ↩ roots.some(λ(r){↩ ι.indexOf(r) === 0})}).filter(ι=> !ι.dir()).map(ι=> ι+'')
*/

// i'd like that to be #!/usr/bin/env node --max_old_space_size=10000 
// Sequence.prototype.map = λ(f){ for (var ι of @) yield f(ι) }

// ---------------------------------- cruft --------------------------------- //

// // ------------------------------ browser fixes ----------------------------- //
// BROWSERp ← typeof window!=='undefined'
// if (BROWSERp) if (!module.parent) module.parent = '<browser>'
// if (BROWSERp) typeof Buffer!=='undefined' && (window.Buffer = require('buffer').Buffer)
// if (BROWSERp) E.cn = { log:λ(…a){ console.log(…a); window.__ = a[-1] } }

// 'Function.prototype.at':lazy('at',λ(){priorityqueuejs ← require('priorityqueuejs')
// 	// https://github.com/Automattic/kue
// 	// https://github.com/rschmukler/agenda
// 	// robust to setTimeout taking extra time
// 	//! not robust to the process failing ! should use redis or something instead !
// 	//! wth is up with the { hrtime() <-> time } comparison
// 	qu ← new priorityqueuejs((a,b)=> b.time-a.time)
// 	P←; ensure ← λ(){if (P) ↩; P = true; (λ Λ(){t←;
// 		qu.size() === 0? (P = false) : qu.peek().time < hrtime()? (t=qu.deq(), t.ι&&t.ι.in(), Λ()/*nxt*/) : Λ.in(0.1)/*poll*/
// 		})() }
// 	↩ λ(time){ t ← {time, ι:@}; ↩ time < hrtime()? (t.ι.in(), λ(){}) : (qu.enq(t), ensure(), λ(){t.ι = null}) } }),
// 'Function.prototype._1':{get(){↩ _.once(@) }},
// 'Function.prototype.XX':{get(){ ι←@; ↩ λ(a,b){↩ ι.call(@,a,b) } }},

// E._imgur = ι=> shᵥ`curl -sH 'Authorization: Client-ID 3e7a4deb7ac67da' -F image=@${ι} 'https://api.imgur.com/3/upload' | jq -r .data.link`+''
// E._sc_imgur = (…a)=>{ t ← φ`/tmp/sc_${rand_id(9)}.png`; _sc(…a,t); _alert('uploading to imgur','...',1.5); ι ← _imgur(t); browser(ι); p(googl(ι)+'#imgur'); shᵥ`rm ${t}` }
// ⌘⇧⌥3  ; _sc_imgur(     ) // i suspect this is outdated
// ⌘⇧⌥4  ; _sc_imgur('-io') // also this
