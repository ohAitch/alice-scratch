#!/usr/bin/env node

# hey, if you're gonna break this, keep a previous stable version ready this time. weve spent entirely too much time rescuing our configurations.

# odd synonym: k, name(, id)(, i?)

#################################### prelude ###################################
'use strict'; require('module').wrapper[0] += `'use strict';` # enable strict mode everywhere
_ â† require('underscore') # lodash is better than underscore except for _()
_.mixin({ '<-':Î»(â€¦a){â†© @ .assign (â€¦a) } })
Reflect_ownEntries â† Î¹=> Reflect.ownKeys(Î¹).map(k=> [k,Î¹[k]])

Î» Descriptor(Î¹){ _(@) <- (Î¹) }
define_properties_in â† (o,names,Î¹)=>{ t â† o; for(var k of names.slice(0,-1)) t = (t[k] ||( t[k] = {} )); t[names[names.length-1]] = Î¹ ;â†© o }
assign_properties_in â† (o,Î¹)=>{ Reflect_ownEntries(Object.getOwnPropertyDescriptors(Î¹)).forEach(([k,{value:Î¹}])=> Î¹ instanceof Descriptor? def(o,k,Î¹) : assign_properties_in(o[k] ||( o[k] = {} ),Î¹) ) ;â†© o }
# ! does that need Object.getOwnPropertyDescriptors at all?

########################## local metaprogramming utils #########################
properties_tree_formalify â† Î¹=>
	_(_(Î¹).map((Î¹,names)=> genex_simple(names).map(k=> [k,Î¹]))).flatten(âœ“)
		.reduce((r,[name,Î¹])=> define_properties_in(r,
			name.split('.').map(Î¹=>{tâ†; â†© (t=Î¹.match(/^@@(.*)/))? Symbol[t[1]] : Î¹ }),
			new Descriptor( Tfun(Î¹)? { value:Î¹, enumerable:âœ“ } : Î¹ )
			), {})

# mixin_forever â† (to,from)=>{}
# mixin_forever_informal â† (to,from)=>{}
E_ â† {}
patched â† new Set([E_,global])
E â† new Proxy({},{ # exports
	# get(           self,k){  },
	# getOwnPropertyDescriptor()
	set(           self,k,Î¹){ [â€¦patched].forEach(o=> o[k] = Î¹ ) ;â†© âœ“ },
  defineProperty(self,k,Î¹){ [â€¦patched].forEach(o=> def(o,k,Î¹) ) ;â†© âœ“ },
	})
assign_properties_in_E_informal â† Î¹=>{ Î¹ = properties_tree_formalify(Î¹); [â€¦patched].forEach(o=> assign_properties_in(o,Î¹)) }
module.exports = to=>{ patched.has(to) || ( cn.log('\x1b[34m[Î¶]\x1b[0m patching'), cn.log(Error('<stack>').stack), patched.add(to), assign_properties_in(to,E_) ) }

#################################### prelude ###################################
E.catch_union = f=>{ try{ r â† f(); bad â† T.Error(r); if (!bad) â†© r }catch(e){ r â† e; T.Error(r) || â€½ ;â†© r }; bad && â€½ }
E.catch_Î¹ = f=>{ try{ r â† f(); bad â† r===âˆ…; if (!bad) â†© r }catch(e){}; bad && â€½ }
E.catch_ = f=> Î»(){ try{ â†© f.apply(@,arguments) }catch(e){ if ('__catchable' in e) â†© e.__catchable; else throw e } }
E.return_ = Î¹=>{ throw {__catchable:Î¹} }

E.T = Î¹=>{ 
	ty â† typeof Î¹; if (ty!=='object') â†© ty; if (Î¹===null) â†© 'null'
	p â† Object.getPrototypeOf(Î¹); if (p===Object.prototype || p===null) â†© 'object'
	for (var t of is_l) if (t[1](Î¹)) â†© t[0]
	â†© 'object' }
b_util â† catch_Î¹(=> process.binding('util') )
is_l â† [
	, ['Array',Array.isArray]
	# , ['Error',Î¹=> Object.prototype.toString.call(Î¹)==='[object Error]' || Î¹ instanceof Error]
	,â€¦ ['Error','String','Boolean','Number'].map(ty=> [ty,Î¹=> Object.prototype.toString.call(Î¹)==='[object '+ty+']'])
	,â€¦ (!b_util? [] : ['ArrayBuffer','DataView','Date','Map','MapIterator','Promise','RegExp','Set','SetIterator','TypedArray'].map(Î¹=> [Î¹,x=> b_util['is'+Î¹](x)]) )
	]
# would like to be using âˆˆ instead
_(T) <- (_(is_l).object(),{
	,symbol: Î¹=> typeof Î¹ === 'symbol'
	,boolean: Î¹=> typeof Î¹ === 'boolean'
	,string: Î¹=> typeof Î¹ === 'string'
	,number: Î¹=> typeof Î¹ === 'number'
	,function: Î¹=> typeof Î¹ === 'function'
	,primitive: Î¹=>{ switch(typeof(Î¹)){case 'undefined': case 'boolean': case 'number': case 'string': case 'symbol': â†© âœ“; case 'object': â†© Î¹===null; default: â†© âœ—} }
	,boxed: Î¹=>{ if (Î¹===null || typeof Î¹!=='object') â†© âœ—; t â† Object.getPrototypeOf(Î¹); t = t.constructor&&t.constructor.name ;â†© (t==='Boolean'||t==='String'||t==='Number') && /^\[object (Boolean|String|Number)\]$/.test(Object.prototype.toString.call(Î¹)) }
	,â„¤: Number.isInteger
	,'-0': Î¹=> Î¹===0 && 1/Î¹ < 0
	,NaN: Number.isNaN
	})
_(E) <- ({ Tstr:T.string, Tnum:T.number, Tfun:T.function, Tarr:T.Array, Tprim:T.primitive, Tbox:T.boxed, })
T.primitive.Î¹ = new Set(['undefined','boolean','number','string','symbol','null'])
T.boxed.Î¹ = new Set(['Boolean','String','Number'])

E.def = (o,name,Î¹)=>{
	Tfun(Î¹) &&( Î¹ = lazy(name,Î¹) )
	'configurable' in Î¹ ||( Î¹.configurable = âœ“ )
	if( !Î¹.configurable ){ if( 'value' in Î¹ ) Î¹.writable = âœ— }
	else{
		if( 'value' in Î¹ ) 'writable' in Î¹ ||( Î¹.writable = âœ“ )
		else if( Î¹.writable ){ delete Î¹.writable; Î¹.set && â€½; Î¹.set = Î»(Î¹){ def(@,name,{ value:Î¹, enumerable:âœ“, }) } }
		}
	â†© Object.defineProperty(o,name,Î¹) } # = â†© o
lazy â† (name,Î¹)â‡’ { writable:âœ“, get(){â†© @[name] = Î¹() } }

/* prefix hook*/ E.ğ…«ğ…®ğ…ªğ…°ğ…ƒ = (=>{ ğ…­ğ…©ğ…ğ…‹ğ…© â† def({ f:âˆ… },'Î¹',{ set(Î¹){ @.f(Î¹) } }); â†© f=>{ ğ…­ğ…©ğ…ğ…‹ğ…©.f = f; â†© ğ…­ğ…©ğ…ğ…‹ğ…© } })()
/*postfix pipe*/ def(Object.prototype,'ğ…­ğ…‹ğ…®ğ…œğ…‹',{ ,enumerable:âœ— ,value:Î»(â€¦f){â†© f.reduce((Î¹,f)=> f(Î¹),@) } })

################################### requires ###################################
;[ ,['events','EventEmitter'],['fs'],['http'],['https'],['module','Module'],['net'],['os'],['querystring'],['readline'],['stream'],['util'],['vm'],['zlib'],['underscore','_'],['lodash','lo'],['highland','h']
	].map(([Î¹,n])=> def(E, n||Î¹, => require(Î¹)) )
E._ = _
path â† require('path')
fs â† require('fs')
def(E,'robot',lazy('robot',=> npm`robotjs@0.4.5` ))
def(E,'require_new',lazy('require_new',=>{ t â† npm`require-uncached@1.0.3` ;â†© Î¹=> t((Î¹+'').replace(/^\.(?=\/)/,Ï†.cwd)) }))
_.mixin({ isEqual:lo.isEqual })

#################################### Î¶ infra ###################################
E.Property = Î»(o,name){ ;this.o = o ;this.name = name }
def(Property.prototype,'Î¹',{ get(){â†© @.o[@.name] }, set(Î¹){ @.o[@.name] = Î¹ } })
Property.prototype.def = Î»(Î¹){ def(@.o,@.name,Î¹) ;â†© @ }
Property.prototype.delete = Î»(){ delete @.o[@.name] ;â†© @ }
Property.prototype.map! = Î»(f){ @.Î¹ = f(@.Î¹,@.name,@.o) ;â†© @ }
def(Property.prototype,'bind',{get(){â†© @.o[@.name].bind(@.o) }})
def(Property.prototype,'âˆƒ',{get(){â†© @.name in @.o }})
# Property.prototypeâ€˜.bind <- { ,get(){â†© @.o[@.name].bind(@.o) } }
# â€˜. = Property

new Property(eval,'Â·').def({ enumerable:âœ“, get(){ @(Î¶_compile(Ï†`/tmp/__Â·`.text).replace(/^#!.*/,'')) }, })
lazy_fn â† f=>{tâ†; â†© Î»(){â†© (t||(t=f())).apply(@,arguments) } } # ! slotify and then detect and merge slots

;[#persist_here ~/code/declare/npm]
E.npm = Î¹=>{ Tarr(Î¹) && (Î¹ = Î¹[0]); APP â† '\x1b[34m[npm]\x1b[0m'
	[Ë£,name,version,sub] â† Î¹.re`^(.*?)(?:@(.*?))?(/.*)?$`
	abs_name â† => name+'@'+version
	if (version){
		cache â† Ï†`~/.npm/${name}/${version}`; final â† cache.Ï†`/node_modules/${name}`+(sub||'')
		try{ â†© require(final) }catch(e){ if (!(e.code==="MODULE_NOT_FOUND")) throw e }
		cache.BAD_exists() || sháµ¥`cd ~; npm cache add ${abs_name()}`
		aâ†;bâ†; (a=cache.Ï†`package.json`).Î¹ = {description:'-',repository:1,license:'ISC'}; (b=cache.Ï†`README`).Î¹ = ''; sháµ¥`cd ${cache} && npm --cache-min=Infinity i ${abs_name()}`; a.Î¹ = b.Î¹ = âˆ…
		â†© require(final) }
	else {
		sfx`ack`
		version = sháµ¥`npm show ${Î¹} version`+''
		process.stderr.write(APP+' latest: '); process.stdout.write(Î¹.replace(/-/g,'_')+' â† npm`'+abs_name()+'`'); process.stderr.write('\n')
		} }
E.js_tokenize = code=>{
	tok â† npm`babylon@6.14.1`.parse(code,{allowReturnOutsideFunction:âœ“}).tokens
	â†© _.zip( tok.map(Î¹=> code.slice(Î¹.start,Î¹.end)), tok.windows(2).map(([a,b])=> code.slice(a.end,b.start) ) )._.flatten(âœ“).filter(Î¹=>Î¹) }
E.uses_this = f=> (f+'').match(/\bthis\b/) && js_tokenize('('+f+')').includes('this')? 'maybe' : âœ—
E.Î¶_compile = lazy_fn(=>{ ğ…­ğ…‹ğ…¦ğ…ğ…œâ†; ğ…¨ğ…‹ğ…¦ğ…œğ…¦â†; ğ…œğ…¦ğ…©ğ…ğ…ƒâ†; ğ…‚ğ…‚ğ…ƒğ…ğ…¦â†; ğ…¨ğ…‚ğ…«ğ…¯ğ…ƒâ†; ğ…©ğ…«ğ…ƒğ…¬ğ…ƒâ†; ğ…‹ğ…‚ğ…­ğ…‚ğ…¦â†; ğ…œğ…¯ğ…©ğ…ªğ…ƒâ†; ğ…ğ…©ğ…­ğ…ªğ…ƒâ†; ğ…­ğ…­ğ…ƒğ…ªğ…ƒâ†; ğ…­ğ…¦ğ…«ğ…©ğ…â†;
	word_extra â† re`â™ˆ-â™“ğŸ”…ğŸ”†ğŸ”’â€¡â§«Â§`
	word â† re`A-Za-z0-9_$Ê°-Ê¸Ë¡-Ë£Î‘-Î¡Î£-Ï‰á´¬-áµ›áµ¢-áµ¥á¶œá¶ á¶»â°â±â¿â‚-â‚“â‚•-â‚œâ„‚â„•â„šâ„â„¤â±¼â±½âš“ğ…‚ğ…ƒğ…‹ğ…œğ…ğ…ğ…¦ğ…¨ğ…©ğ…ªğ…«ğ…¬ğ…­ğ…®ğ…¯ğ…°${word_extra}`
	Î¶_parse â† E.Î¶_parse = (=>{
		P â† require('./parsimmon2.js')
		ident â† P(re`(?![0-9])[${word}]+|@`)
		comment â† re`(//.*|/\*[^]*?(\*/|$)|#[\s#].*)+`
		simple_js â† P(=> P.alt(
			P(comment).T`comment`,
			P.seq( P('{'), simple_js, P('}') ),
			P.seq( P.alt(
				P(/(['"])(((?!\1)[^\\]|\\.)*?\1)/).T`string`,
				ident,
				P.seq( P('`').T`template`, tmpl_Î¹.many(), P('`').T`template` ),
				P(/[)\]0-9]/)
				), P.alt( P(re`[ \t]*(?!${comment})/`), P.of('') ) ),
			P(/\[#persist_here .*?\]/),
			P(re`/((?:[^/\\\[]|(?:\\.)|\[(?:[^\\\]]|(?:\\.))*\])*)/([a-z]*)`).T`regex`,
			P(re`[^{}/#'"â€¦${'`'})@\[\]${word}]+|[^}]`)
			).many() )
		tmpl_Î¹ â† P.alt( P.seq( P('${').T`template`, simple_js, P('}').T`template` ), P(/(?:\\[^]|(?!`|\$\{)[^])+/).T`template` )
		js_file â† P.seq( P(/(#!.*\n)?/).T`shebang`, simple_js )
		â†© code=>{
			Î¹ â† js_file.parse(code)._.flatten()
			r â† []; for(var t of Î¹) t.T? r.push(t) : r[-1]&&r[-1].T? r.push(t) : (r[-1]+=t)
			â†© r } })()
	s_or â† Î¹=> re`(?:â€¦${Î¹.split(' ').map(Î¹=> re`${Î¹}`.source).join('|')})`
	id_c â† 'filter! mapâ€¦ map! â»Â¹declare_uniq thenâš“ â»Â¹ âˆª! âˆ©! -! ?? *? +? âˆª âˆ© âŠ• â‰ˆ â€– âš“ -= += Î & Î | ? * + - & | âˆƒ âˆ‹'
	Î¶_compile_nonliteral â† Î¹=> Î¹
		.replace(/âœ“/g,'true')
		.replace(/âœ—/g,'false')
		.replace(/âˆ…/g,'undefined')
		.replace(ğ…œğ…¯ğ…©ğ…ªğ…ƒ||(ğ…œğ…¯ğ…©ğ…ªğ…ƒ= re`ğŸ·([${word}]+)(\s*)â†`.g ),(Ë£,Î¹,s)=> js`â€¦${Î¹+s}â† ğ…«ğ…®ğ…ªğ…°ğ…ƒ(__name(${Î¹})).Î¹=`) # an initial try; probably .name inference needs another form
		.replace(/\|>/g,'.ğ…­ğ…‹ğ…®ğ…œğ…‹')
		.replace(/â€½(?=(\(|`)?)/g,(Ë£,callp)=> `!Î»(â€¦a){throw Error(__err_format(â€¦a))}${callp? `` : `('â€½')`}` )
		.replace(ğ…¨ğ…‹ğ…¦ğ…œğ…¦||(ğ…¨ğ…‹ğ…¦ğ…œğ…¦= re`(\[[${word},â€¦]+\]|\{[${word},:â€¦]+\}|[${word}]+)(\s*)â†(;?)`.g ),(Ë£,name,ws,end)=> 'var '+name+ws+(end?';':'=') )
		.replace(/Î»(?=\*?(?:[ \t][^\(=â†]*)?\([^\)]*\)[ \t]*\{)/g,'function')
		.replace(ğ…‚ğ…‚ğ…ƒğ…ğ…¦||(ğ…‚ğ…‚ğ…ƒğ…ğ…¦= re`\.?@@([${word}]+)`.g ),'[Symbol.$1]')
		.replace(ğ…œğ…¦ğ…©ğ…ğ…ƒ||(ğ…œğ…¦ğ…©ğ…ğ…ƒ= re`\.(${s_or('-0 '+id_c)})`.g ),(Ë£,Î¹)=> js`[${Î¹}]`)
		.replace(ğ…ğ…©ğ…­ğ…ªğ…ƒ||(ğ…ğ…©ğ…­ğ…ªğ…ƒ= re`(${s_or(id_c)}):`.g ),(Ë£,Î¹)=> js`${Î¹}:`)
		.replace(/â€¦/g,'...')
		.replace(/\[(['"])map\.\.\.\1\]/g,'["mapâ€¦"]') # ! this is going to be really hard to take out
		.replace(/@/g,'this')
		.replace(/âˆ/g,'Infinity')
		.replace(/â‡’(\s*([:{]))?/g,(Ë£,x,Î¹)=> '=>'+({ ':':'0?0', '{':'0?0:', }[Î¹]||â€½)+x )
		.replace(ğ…­ğ…¦ğ…«ğ…©ğ…||(ğ…­ğ…¦ğ…«ğ…©ğ…= re`(^|[^\s\)${word}]\s*)=>`.g ),(Ë£,t)=> t+'()=>' )
		.replace(/â†© ?/g,'return ')
		.replace(ğ…©ğ…«ğ…ƒğ…¬ğ…ƒ||(ğ…©ğ…«ğ…ƒğ…¬ğ…ƒ= re`(â€¦${'<-'.split(' ').map(Î¹=> re`${Î¹}`.source).join('|')})`.g ),(Ë£,Î¹)=> '['+util_inspect_autodepth(Î¹)+']')
		.replace(ğ…¨ğ…‚ğ…«ğ…¯ğ…ƒ||(ğ…¨ğ…‚ğ…«ğ…¯ğ…ƒ= re`#swap ([${word}]+) ([${word}]+)`.g ),(Ë£,a,b)=>{ t â† 't_'+random_id(9) ;â†© Î¶_compile_nonliteral(`for(;;){ ${t} â† ${a}; ${a} = ${b}; ${b} = ${t} ;break}`) }) # why not just [a,b] = [b,a]?
		.replace(/\[#persist_here (.*?)\]/g,(Ë£,Î¹)=> '('+json2_read+js`)(${json2_show(Ï†(Î¹).buf)})`)
		.replace(/\[#Q/g,'new Property(') # Quote
		.replace(ğ…‹ğ…‚ğ…­ğ…‚ğ…¦||(ğ…‹ğ…‚ğ…­ğ…‚ğ…¦= re`\.(\s*)([${word}]+)(\s*)#Q\]`.g ), `,$1'$2'$3)`)
		.replace(ğ…­ğ…‹ğ…¦ğ…ğ…œ||(ğ…­ğ…‹ğ…¦ğ…ğ…œ= re`[${word_extra}]+`.g ), unicode_names.X) # ! eventually, remove the thing with two underscores next to each other __
		.replace(/([{([]\s*),/g,'$1')
		.replace(ğ…­ğ…­ğ…ƒğ…ªğ…ƒ||(ğ…­ğ…­ğ…ƒğ…ªğ…ƒ= re`return\s+var\s+([${word}]+)`.g ), (Ë£,Î¹)=> `var ${Î¹}; return ${Î¹}`)
	# Î¶_compile_nonliteral_tree â† Î¹=>{
	# 	Î¹ = Î¹.mapâ€¦(Î¹=> Î¹.T? [Î¹] : Î¹.split(/(?=[{([\])}])/g).mapâ€¦(Î¹=> Î¹.match(/^([{([\])}]?)([^]*)$/).slice(1)).filter(Î¹=>Î¹.â€–) )
	# 	@ other_bracket â† i=>{ at â† {'[':0,'{':0,'(':0}; dir â† Î¹[i] in at? 1 : -1; for(;;){ for(var [a,b] of ['[]','()','{}']){ Î¹[i]===a && at[a]++; Î¹[i]===b && at[a]-- }; if( _(at).every(Î¹=>Î¹===0) ) break; i += dir; if (!(0<=i&&i<Î¹.â€–)) â†©; } ;â†© i }
	# 	â†© Î¹.map(Î¹=> Î¹.T? Î¹.Î¹ : Î¹) }
	â†© code=>{
		t â† code; t = /^(\{|Î»\s*\()/.test(t)? '0?0: '+t : t; if( /^(\{|Î»\s*\()/.test(t) ) t = '0?0: '+t # ! it is a clumsy hack to put this on all of these code paths
		â†© Î¶_parse(t).map(Î¹â‡’
			: Î¹.T==='comment'? Î¹.Î¹.replace(/^#/,'//')
			: Î¹.T? Î¹.Î¹
			: Î¶_compile_nonliteral(Î¹)
			).join('') } })
Î¶_compile.â»Â¹ = Î¹=> Î¹.replace(/\b(?:function|return|this)\b(?!['"])|\bvar \s*([\w_$Î‘-Î¡Î£-Î©Î±-Ï‰]+)(\s*)(=?)|\.\.\./g, (Î¹,name,s,eq)â‡’ {'function':'Î»','return':'â†©','this':'@','...':'â€¦'}[Î¹] || (eq==='='? name+s+'â†' : name+s+'â†;') )
E.__name = name=> Î¹=> [#Q Î¹.name #Q].def({ value:name })
E.__err_format = (â€¦a)=> Error(a.map(Î¹=> Tstr(Î¹)? Î¹ : util_inspect_autodepth(Î¹)).join(' '))

if( require.extensions && !require.extensions['.Î¶'] )(=>{
	require.extensions['.Î¶'] = (module,Î¹)=> module._compile(Î¶_compile(fs.readFileSync(Î¹,'utf8')),Î¹)
	super_ â† require.extensions['.js']; require.extensions['.js'] = (module,Î¹)=>{ (path.extname(Î¹)==='' && fs.readFileSync(Î¹,'utf8').re`#!/usr/bin/env Î¶\s`? require.extensions['.Î¶'] : super_)(module,Î¹) }
	})()

#################################### prelude ###################################
E.protos = Î»*(Î¹){ for(;!( Î¹===null || Î¹===undefined ); Î¹ = Object.getPrototypeOf(Î¹)) yield Î¹ }
E.simple_hash_str = Î¹â‡’
	: Tfun(Î¹)? T(Î¹)+Î¹
	: JSON.stringify(Î¹, (k,Î¹)=>{ if (Tprim(Î¹)||Tarr(Î¹)) â†© Î¹; else{ râ†{}; _(Î¹).keys().sort().forEach(k=> r[k]=Î¹[k]) ;â†© r } })
E.fromUInt32BE = Î¹=>{ t â† Buffer.alloc(4); t.writeUIntBE(Î¹,0,4) ;â†© t }
E.b36 = Î¹=> npm`base-x@1.0.4`([â€¦/[0-9a-z]/].join('')).encode(Î¹).replace(/^0+(?!$)/,'')
E.simple_hash = Î¹=> b36( require('crypto').createHash('sha256').update(simple_hash_str(Î¹)).digest() )
memo_frp â† (names,within,f)=>{
	dir â† Ï†`~/.memo_frp/${names}`
	if( within ){
		try{ t â† fs.readdirSync(dir+'') }catch(e){ if (!(e.code==='ENOENT')) throw e; t â† [] }
		now â† Time().i; t = t.sort().filter(Î¹=> Time(Î¹.re`^\S+`[0]).i >= now - within )[-1]
		if( t ) â†© dir.Ï†(t).json2.Î¹ }
	a â† Time().iso; Î¹ â† f(); b â† Time().iso
	dir.Ï†`${a} ${random_id(10)}`.json2 = { ,names ,date:[a,b] ,Î¹ } ;â†© Î¹ }
E.memoize_persist = f=>{
	store â† Ï†`/tmp/Î¶persist_${simple_hash(f)}`; store_Î¹ â† store.json||{}
	â†© (â€¦a)=>{ t â† new Property(store_Î¹,simple_hash(a)) ;â†© t.âˆƒ? t.Î¹ : ( t.Î¹ = f(â€¦a), store.json = store_Î¹, store_Î¹ = store.json, t.Î¹ ) } }
# frp will remove the last use(s) of slot_persist
E.slot_persist = name=>{ o â† Ï†`/tmp/Î¶persist_${name}` ;â†© def({name},'Î¹',{get(){â†© o.json },set(Î¹){ o.json = Î¹ }}) }
# E.memoize = f=>{ cache â† new WeakMap() ;â†© _(Î¹=>{ if( cache.has(Î¹) ) â†© cache.get(Î¹); Tprim(Î¹) && â€½; r â† f(Î¹); cache.set(Î¹,r) ;â†© r }) <- ({cache}) }

E.unicode_names = Î¹=> [â€¦Î¹].map(memoize_persist(Î¹=>
	(ğ…©ğ…©ğ…©ğ…ğ…‹||(ğ…©ğ…©ğ…©ğ…ğ…‹= (=>{
		unicode_data â† 'Cc Cf Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs'.split(' ').mapâ€¦(Î¹=> _(npm('unicode@0.6.1/category/'+Î¹)).values() )
		â†© unicode_data.filter(Î¹=> !/^</.test(Î¹.name)).map(Î¹=> [parseInt(Î¹.value,16), '_'+Î¹.name.replace(/[- ]/g,'_').toLowerCase()+'_'])._.object()
		})() ) )[ord(Î¹)]).X).join(''); ğ…©ğ…©ğ…©ğ…ğ…‹â†;

regex_parse â† lazy_fn(=>{tâ†; # status: output format unrefined
	P â† require('./parsimmon2.js')
	dehex â† Î¹=> chr(parseInt(Î¹,16))
	ESCAPE â† P('\\').then(P.alt( P(/x([0-9a-fA-F]{2})/,1).map(dehex), P(/u\{([0-9a-fA-F]+)\}/,1).map(dehex), P(/u([0-9a-fA-F]{4})/,1).map(dehex), P(/./).map(Î¹=> '.[|^$()*+?{}\\/'.includes(Î¹)? Î¹ : P.T('escape',Î¹) ) ))
	s1 â† P.alt(
		, P(/[^.()[\]^$|\\]/)
		, ESCAPE
		, P`.`.T`any`
		, P`(?:${=>OR_or_SEQ})`
		, P`(?=${=>OR_or_SEQ})`.T`lookahead`
		, P`(?!${=>OR_or_SEQ})`.T`nlookahead`
		, P`(${=>OR_or_SEQ})`.T`capture`
		, P`[${[ /\^?/, ( t= ESCAPE.or(/[^\]]/), P([ t.skip('-'), t ]).or(t) ).many() ]}]`.map(Î¹=> P.T(Î¹[0]? 'nset' : 'set', Î¹[1]))
		)
	TIMES â† P([ s1, P.alt('*','+','?',/\{([0-9]+)(?:(,)([0-9]*))?\}/,P.of())
		.map(Î¹=> Î¹ = !Î¹? Î¹ : Î¹==='*'? [0,âˆ] : Î¹==='+'? [1,âˆ] : Î¹==='?'? [0,1] : (=>{ [Ë£,a,two,b] â† Î¹.match(/\{([0-9]+)(?:(,)([0-9]*))?\}/) ;â†© [a|0,b? b|0 : two? âˆ : a|0] })() )
		]).map(([Î¹,for_])=> !for_? Î¹ : {T:'times', Î¹, for:for_} )
	s2 â† P.alt( P('^').T`begin`, P('$').T`end`, TIMES )
	OR_or_SEQ â† P.sep_by(s2.many().T`seq`, '|').map(Î¹=> Î¹.â€– > 1? P.T('or',Î¹) : Î¹[0])
	# t1 â† regex_parse(/^(foo)(?:bep){2,7}\baz(?:\\b.ar|[a-c-e()}][^\s]|b|baz(?=gremlin)(?!groblem)|)*/i)
	â†© Î¹â‡’ {Î¹:OR_or_SEQ.parse(Î¹.source), flags:Î¹.flags} })
E.applescript = {
	parse: lazy_fn(=>{
	  P â† require('./parsimmon2.js')
	  ws â† Î¹=> ws_.then(Î¹).skip(ws_); ws_ â† P(/[ \t\n\r]*/)
	  value â† P(=> P.alt(false_,true_,number,object,array,string,raw) )
	  false_ â† P('false').map(=> âœ—)
	  true_ â† P('true').map(=> âœ“)
	  number â† P(/-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][-+]?[0-9]+)?/).map(Î¹=> +Î¹)
	  _member â† P.seq(P(/[ a-z0-9-]+/i).skip(ws(P(':'))), value)
	  object â† ws(P('{')).then(P.sep_by(_member,ws(P(',')))).skip(ws(P('}'))).map(Î¹=> Î¹.â€–? _.object(Î¹) : [])
	  array â† ws(P('{')).then(P.sep_by(value,ws(P(',')))).skip(ws(P('}')))
	  _char â† P(/[\n\t\x20-\x21\x23-\x5B\x5D-\u{10FFFF}]|\\(["\\\/bfnrt]|u[0-9a-fA-F]{4})/u).map(Î¹=> Î¹[0]!=='\\'? Î¹ : {'"':'"','\\':'\\','/':'/',b:'\b',f:'\f',n:'\n',r:'\r',t:'\t'}[Î¹[1]] || chr(parseInt(Î¹.slice(2),16)) )
	  string â† P('"').then( _char.many().map(Î¹=> Î¹.join('')) ).skip(P('"'))
	  raw â† P(/[^,}"]+/).or(string.map_js((Î¹,[i0,i1],l)=> l.slice(i0,i1))).many().map(Î¹=>{ Î¹=Î¹.join('') ;â†© Î¹==='missing value'? âˆ… : {T:'raw',Î¹} })
	  â†© Î¹=> Î¹===''? âˆ… : ws(value).parse(Î¹) }),
	print: Î¹=> Tnum(Î¹)? Î¹+'' : Tstr(Î¹)? '"'+Î¹.replace(/["\\]/g,'\\$&')+'"' : Tarr(Î¹)? '{'+Î¹.map(applescript.print.X).join(',')+'}' : â€½,
	}
# E.lenient_json_parse = (=>{
# 	P â† require('./parsimmon2.js')

# 	whitespace â† P(/\s*/m)
# 	escapes â† { b:'\b', f:'\f', n:'\n', r:'\r', t:'\t', }
# 	un_escape â† (str)=> str.replace(/\\(u[0-9a-fA-F]{4}|[^u])/, (Ë£,escape)=> escape[0]==='u'? chr(parseInt(escape.slice(1),16)) : escapes[escape[0]] || escape[0] )
# 	comma_sep â† (parser)=> P.sepBy(parser, token(P(',')))
# 	token â† p=> p.skip(whitespace)

# 	l_null â† token(P('null')).map(=> null)
# 	l_t â† token(P('true')).map(=> âœ“)
# 	l_f â† token(P('false')).map(=> âœ—)
# 	l_str â† token(P(/"((?:\\.|.)*?)"/, 1)).map(un_escape).desc('string')
# 	l_num â† token(P(/-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/)).map(Number).desc('number')

# 	json â† P.lazy(=> whitespace.then(P.alt( object, array, l_str, l_num, l_null, l_t, l_f )) )
# 	array â† token(P('[')).then(comma_sep(json)).skip(token(P(']')))
# 	pair â† P.seq(l_str.skip(token(P(':'))), json)
# 	object â† token(P('{')).then(comma_sep(pair)).skip(token(P('}'))).map(Î¹=> _.object(Î¹))
# 	â†© Î¹=> json.parse(Î¹).value })()
E.JSON_pretty = (Î¹,replacer)=>{
	seen â† []
	T â† '  ' # tab
	wrap_width â† 140
	indent_show â† Î¹=> show(Î¹).replace(/\n/g,'\n'+T)
	show â† Î¹=>{tâ†;
		if (Î¹===âˆ…||Î¹===null) â†© 'null'
		replacer && (Î¹ = replacer(Î¹))
		while (Î¹.toJSON) Î¹ = Î¹.toJSON()
		switch (typeof(Î¹)==='object'? Object.prototype.toString.call(Î¹) : typeof(Î¹)) {
			case 'string': case '[object String]': â†© JSON.stringify(Î¹)
			case 'boolean': case '[object Boolean]': case 'number': case '[object Number]': â†© Î¹+''
			case 'function': â†© 'null'
			default:
				if (seen.indexOf(Î¹) !== -1) throw TypeError('Converting circular structure to JSON')
				seen.push(Î¹)
				if (Tarr(Î¹)) { [a,b] â† '[]'; Î¹ = Î¹.map(indent_show); for (iâ†0;i<Î¹.â€–;i++) Î¹[i]===âˆ… && (Î¹[i] = 'null') }
				else { [a,b] â† '{}'; Î¹ = _(Î¹).pairs().filter(Î¹=> !(Î¹[1]===âˆ… || Tfun(Î¹[1]))).map(Î¹=> show(Î¹[0])+': '+indent_show(Î¹[1])) }
				seen.pop()
				â†© (t=a+Î¹.join(', ')+b).â€– <= wrap_width? t : a+'\n'+T+Î¹.join(',\n'+T)+'\n'+b
				} }
	â†© show(Î¹) }
genex_simple â† Î¹=>{ P â† require('parsimmon')
	unit â† P.lazy(=> P.alt( P.noneOf('()|'), P.string('(').then(s_or).skip(P.string(')')).map(Î¹â‡’{T:'capture',Î¹}) ) )
	s_or â† P.sepBy(unit.many(),P.string('|')).map(Î¹=> Î¹.length > 1? {T:'or',Î¹:Î¹} : Î¹[0])
	Î› â† Î¹=> Î¹.T==='or'? Î¹.Î¹.map(Î›) : Î¹.T==='capture'? Î›(Î¹.Î¹) : Tarr(Î¹)? cartesian_str(Î¹.map(Î›)) : [Î¹]
	â†© Î›(P.alt( P.string('|'), unit ).many().parse(Î¹).value) }
genex â† Î» Î›(Î¹){â†©0,
	Tstr(Î¹)? [Î¹] :
	Î¹.flags!==âˆ…?( Î¹.flags.replace(/u/,'') && â€½, Î›(Î¹.Î¹) ):
	Î¹.T==='capture'? Î›(Î¹.Î¹) :
	Î¹.T==='escape'? â€½ :
	Î¹.T==='or'? Î¹.Î¹.mapâ€¦(Î›) :
	Î¹.T==='seq'? cartesian_str(Î¹.Î¹.map(Î›)) :
	# Î¹.T==='times'? # Î›(Î¹.Î¹).mapâ€¦(x=> _.range(Î¹.for[0],Î¹.for[1]+1).map(i=> x.repeat(i)) ) :
	# 	Î¹s â† Î›(Î¹.Î¹)
	Î¹.T==='set'? Î¹.Î¹.mapâ€¦(Î¹=>
		Tarr(Î¹)? _.range(ord(Î¹[0]),ord(Î¹[1])+1).map(chr) :
		Î¹.T==='escape'? â€½ :
			[Î¹] ):
		â€½(Î¹) }

_(E) <- (_(Math).pick('abs','ceil','exp','floor','log10','log2','max','min','round','sqrt','cos','sin','tan')); _(E) <- ({ln:Math.log, Ï€:Math.PI, Ï„:Math.PI*2, e:Math.E, 'âŸ':Math.log, })
E.multiline = Î»(Î¹){ Î¹ = (Î¹+'').split('\n').slice(1,-1); t â† Î¹.map(Î¹=> Î¹.re`^\t*`[0].â€–)._.min(); Î¹ = Î¹.map(Î¹=> Î¹.slice(t)) ;â†© (Î¹[0]==='' && Î¹[-1]===''? Î¹.slice(1,-1) : Î¹).join('\n') }
E.sleep = Î¹=>{ hâ†; for(hrâ†hrtime(); (h=hrtime(hr)) < Î¹; Î¹-h > 0.03 && (sháµ¥`sleep ${Î¹-h-0.02}`,1)); }
E.bench = (f,opt={})=>{ var {TH=0.4} = opt
	# ! really should include a confidence interval or smth
	râ†0; Iâ†1; hrâ†hrtime(); R â† => Unit(hrtime(hr) / r,'s')
	tâ†f(); r++
	if( T.Promise(t) ) â†© Î (yes=>{ t.then(Î» Î›(){ if( hrtime(hr) < TH ){ r++; f().then(Î›) }else yes(R()) }) })
	else{ for(;hrtime(hr) < TH;){ for(iâ†0;i<I;i++) f(); r += I; I = ceil(I*1.5) } ;â†© R() } }
E.bench1 = f=>{ hr â† hrtime(); f() ;â†© Unit(hrtime(hr),'s') }
E.GET_L = (Î¹,within)=> memo_frp(['GET -L', Î¹+''], within, => sháµ¥`curl -sL ${Î¹}`) # ! some requests have short responses; will need more intelligent caching for those 'cause the filesystem can't take too much
E.random = Î»(Î¹){â†© arguments.length===0? Math.random() : Tnum(Î¹)? random()*Î¹ |0 : _.sample(Î¹) }
E.random_id = L=> L.map(=> random(ğ…­ğ…ğ…¯ğ…©ğ…ª||(ğ…­ğ…ğ…¯ğ…©ğ…ª= [â€¦/[0-9a-z]/]))).join(''); ğ…­ğ…ğ…¯ğ…©ğ…ªâ†;
random_id.braille = L=> L.map(=> random(ğ…©ğ…ğ…‚ğ…œğ…¯||(ğ…©ğ…ğ…‚ğ…œğ…¯= [â€¦re`[â -â£¿]`] ))).join(''); ğ…©ğ…ğ…‚ğ…œğ…¯â†;
random_id.greek = L=> L.map(=> random(ğ…‹ğ…ƒğ…ƒğ…°ğ…°||(ğ…‹ğ…ƒğ…ƒğ…°ğ…°= [â€¦'ğ…‚ğ…ƒğ…‹ğ…œğ…ğ…ğ…¦ğ…¨ğ…©ğ…ªğ…«ğ…¬ğ…­ğ…®ğ…¯ğ…°'] ))).join(''); ğ…‹ğ…ƒğ…ƒğ…°ğ…°â†;

E.ord = Î¹=> Tnum(Î¹)? Î¹ : Î¹.codePointAt()
E.chr = Î¹=> Tstr(Î¹)? Î¹ : String.fromCodePoint(Î¹)
process.stdio = [ process.stdin,process.stdout,process.stderr ]
E.â™“_on_exits = f=> (ğ…°ğ…ğ…œğ…¯ğ…¨||(ğ…°ğ…ğ…œğ…¯ğ…¨= require('signal-exit') ))((i,sig)=>{
	if( i===null ) i = 128+{ ,SIGHUP:1,SIGINT:2,SIGQUIT:3,SIGTRAP:5,SIGABRT:6,SIGIOT:6,SIGSYS:12,SIGALRM:14,SIGTERM:15,SIGXCPU:24,SIGXFSZ:25,SIGVTALRM:26,SIGUSR2:31 }[sig]
	f(i,sig) }); ğ…°ğ…ğ…œğ…¯ğ…¨â†;
E.pad_r = (Î¹,s)=> [Î¹,s.slice(Î¹.â€–)].fold(Tstr(Î¹)? (a,b)=> a+b : Tarr(Î¹)? (a,b)=> [â€¦a,â€¦b] : â€½)

find_closest_ISU â† (Î¹s,Î¹)=>{ for(iâ†0;i<Î¹s.â€–;i++) if( Î¹ <= Î¹s[i] ) â†© i===0? i : abs(Î¹s[i]-Î¹) < abs(Î¹s[i-1]-Î¹)? i : i-1 ;â†© Î¹s.â€–-1 }
cartesian_str â† Î¹=> Î¹.reduce((a,b)=>{ r â† []; a.forEach(a=> b.forEach(b=> r.push(a+b))) ;â†© r }, [''])
E.copy_deep = Î¹â‡’
	: Tprim(Î¹)? Î¹
	: T.Map(Î¹)? new Map(Î¹)
	: T.Set(Î¹)? new Set(Î¹)
	: (=>{
		r â† new Î¹.constructor()
		for(var k in Î¹) if( Object.prototype.hasOwnProperty.call(Î¹,k) ) r[k] = copy_deep(Î¹[k])
		â†© r })()
E.seq = Î¹=>{ tâ† Object.create(seq.prototype); t.Î¹ = Î¹ ;â†© t }
seq.prototype = {
	,next_Î¹:Î»(){ t â†Â @.Î¹; if(! t.next ) t = t.@@iterator() ;â†© t.next().value }
	# ,map(){}
	# ,'mapâ€¦':Î»(){}
	# ,fold(){}
	# ,repeat(){}
	# ,filter(){}
	# ,clone(){}
	# ,pin(){}
	# ,find_(){}
	# ,slice(){}
	# ,'â€–':Î»(){}
	# ,some(){}
	# ,every(){}
	}
assign_properties_in_E_informal({
,'(Array|Set|Map).prototype._':{ get(){â†© _(@)} }

,'(Array|Buffer|String|Function).prototype.â€–':{ get(){â†© @.length } }
,'(Set|Map).prototype.â€–':{ get(){â†© @.size } }

# 'Array.prototype.map'
# ,'Buffer.prototype.map':Î»(f){ r â† Buffer.alloc(@.â€–); for(iâ†0;i<@.â€–;i++) r.push(f(@[i])) ;â†© r } does not even work
,'Set.prototype.map':Î»(f){â†© [â€¦@].map(f) }
,'Map.prototype.map':Î»(f){â†© [â€¦@.entries()].map(([i,v])=> f(v,i,@)) }
,'Number.prototype.map':Î»(f){'use strict'; Î¹â†+@; r â† Array(Î¹); for(iâ†0;i<Î¹;i++) r[i] = f(i,i,Î¹) ;â†© r }

,'Array.prototype.mapâ€¦':Î»(f){ r â† []; for(iâ†0;i<@.â€–;i++){ t â† f(@[i],i,@); for (jâ†0;j<t.â€–;j++) r.push(t[j]) } ;â†© r }
# ,'Buffer.prototype.mapâ€¦':Î»(f){â†© Buffer.concat(@.map(f)) }
,'(Set|Map|Number).prototype.mapâ€¦':Î»(f){â†© @.map(f)._.flatten(âœ“) }

,'Array.prototype.fold':Array.prototype.reduce

,'Array.prototype.repeat':Î»(x){â†© x<=0? [] : x.mapâ€¦(=> @) }
,'Buffer.prototype.repeat':Î»(x){â†© Buffer.concat(x<=0? [] : x.map(=> @)) }

,'Set.prototype.join':Î»(Î¹){â†© [â€¦@].join(Î¹) }

,'(Array|Buffer|String|Set).prototype.count':Î»(){ r â† new Map(); for (var t of @) r.set(t, (r.has(t)? r.get(t) : 0)+1 ) ;â†© r }
,'(Array|Buffer|String|Set).prototype.group':Î»(f){ f||(f = Î¹=>Î¹); r â† new Map(); for (var t of @){ t2 â†Â f(t); r.set(t2, (r.get(t2)||new Set()).âˆª([t])) } ;â†© r }

,'Map.prototype.zip':Î»(â€¦a){ a.unshift(@); r â†Â new Map(); a.forEach((Î¹,i)=> Î¹.forEach((Î¹,k)=>{ t â†Â r.get(k) || [âˆ…].repeat(a.â€–); t[i] = Î¹; r.set(k,t) })) ;â†© r }

,'(Array|Buffer|String).prototype.chunk':Î»(L){â†© _.range(0,@.â€–,L).map(i=> @.slice(i,i+L)) }
,'(Array|Buffer|String).prototype.windows':Î»(L){â†© (@.â€–-L+1).map(i=> @.slice(i,i+L)) }
,'(Array|Buffer|String).prototype.-1':{get(){â†© @.â€–<1? âˆ… : @[@.â€–-1] },set(Î¹){ @.â€–<1 || (@[@.â€–-1] = Î¹) }}
,'(Array|Buffer|String).prototype.-2':{get(){â†© @.â€–<2? âˆ… : @[@.â€–-2] },set(Î¹){ @.â€–<2 || (@[@.â€–-2] = Î¹) }}
,'(Array|Buffer|String).prototype.-3':{get(){â†© @.â€–<3? âˆ… : @[@.â€–-3] },set(Î¹){ @.â€–<3 || (@[@.â€–-3] = Î¹) }}
,'(Array|Buffer|String).prototype.-4':{get(){â†© @.â€–<4? âˆ… : @[@.â€–-4] },set(Î¹){ @.â€–<4 || (@[@.â€–-4] = Î¹) }}

,'(Array|Set).prototype.âˆª':Î»(â€¦a){â†© new Set([@,â€¦a].mapâ€¦(Î¹=> [â€¦Î¹])) }
,'(Array|Set).prototype.âˆ©':Î»(â€¦a){ r â† new Set(@); for(var x of a){ x = T.Set(x)? x : new Set(x); for(var Î¹ of r) x.has(Î¹) || r.delete(Î¹) } ;â†© r }
,'(Array|Set).prototype.-':Î»(â€¦a){ r â† new Set(@); for(var t of a) for(var Î¹ of t) r.delete(Î¹) ;â†© r }
,'(Array|Set).prototype.âŠ•':Î»(b){aâ†@; â†© a.-(b).âˆª(b.-(a)) }

,'(Set|Map).prototype.filter!':Î»(f){ @.forEach((Î¹,i)=> f(Î¹,i,@) || @.delete(i)) }
,'Set.prototype.pop':Î»(){ t â† @[0]; @.delete(t) ;â†© t }
,'Set.prototype.0':{get(){â†© seq(@).next_Î¹() }}
,'(Array|Set).prototype.-eq':Î»(â€¦a){ t â† _([â€¦@]).groupBy(simple_hash_str); a.forEach(Î¹=> Î¹.forEach(Î¹=> delete t[simple_hash_str(Î¹)])) ;â†© _(t).values()._.flatten(âœ“) }

,'Map.prototype.â»Â¹declare_uniq':{get(){â†© new Map([â€¦@.entries()].map(Î¹=>[Î¹[1],Î¹[0]])) }}
,'Map.prototype.â»Â¹':{get(){â†© [â€¦@.keys()].group(Î¹=> @.get(Î¹)) }}

,'Array.prototype.find_':Î»(f){ râ†; if (@.some(Î»(Î¹,i,o){tâ†; if( (t= f(Î¹,i,o))!==âˆ… ){ r = [i,Î¹,t] ;â†© âœ“ } })) â†© r }
,'Array.prototype.find_index_deep':Î»(f){
	for(iâ†0;i<@.â€–;i++){ Î¹ â† @[i]
		if (Tarr(Î¹)){ t â† Î¹.find_index_deep(f); if (t) â†© [i,â€¦t] }
		else{ if (f(Î¹)) â†© [i] }
		} }
,'Array.prototype.Î &':{get(){â†© Î .&(@) }}
,'Array.prototype.Î |':{get(){â†© Î .|(@) }}
,'Array.prototype.seq':{get(){ Î¸ â† Î»*(){ for(;Î¸.i<Î¸.Î¹.â€–;) yield Î¸.Î¹[Î¸.i++] }(); _(Î¸) <- ({ Î¹:@, i:0, clone(){â†© _(@.Î¹.seq) <- (@) } }) ;â†© Î¸ }}
,'Array.prototype.find_last_index':Î»(f){ for(iâ†@.â€–-1;i>=0;i--) if( f(@[i],i,@) ) â†© i }

# ,'Set.prototype.@@iterator':Set.prototype.values
# ,'Map.prototype.@@iterator':Map.prototype.entries
,'RegExp.prototype.@@iterator':Î»*(){yield* genex(regex_parse(@)) }
,'RegExp.prototype.exec_at':Î»(Î¹,i){ @.lastIndex = i ;â†© @.exec(Î¹) }

,'Promise.prototype.status':{writable:âœ“, get(){ [s,v] â† b_util.getPromiseDetails(@); r â† [âˆ…,âœ“,âœ—][s]; if( r!==âˆ… ){ [@.status,@.Î¹] = [r,v] ;â†© r } }}
,'Promise.prototype.Î¹':{writable:âœ“, get(){ if( @.status!==âˆ… ) â†© @.Î¹ }}

,'stream.Readable.prototype.pin':Î»(){â†© Î (yes=>{ t â† []; @.resume(); @.on('data',Î¹=> t.push(Î¹) ).on('end',=> yes(Buffer.concat(t)) ) })}
,'Buffer.prototype.pipe':Î»(to,opt){ t â†Â new stream.Duplex(); t.push(@); t.push(null) ;â†© t.pipe(to,opt) }
})

TimerCons â† Î»(a,b){@.a=a;@.b=b}; TimerCons.prototype = {clear:Î»(){@.a.clear();@.b.clear()}, ref:Î»(){@.a.ref();@.b.ref()}, unref:Î»(){@.a.unref();@.b.unref()}}
E.Î  = Î¹â‡’
	: !Tfun(Î¹)?( T.Error(Î¹)? Promise.reject(Î¹) : Promise.resolve(Î¹) )
	: /^(yes|\(yes,no\))=>/.test(Î¹+'')? new Promise(Î¹)
	: (=>{ # type union of new.Promise(nodeback) and Promise.resolve(object)
		type â† '?'
		r â† (â€¦a)=>{ type==='?' &&( type = 'nodeback' ) ;â†© type==='object'? Î¹(â€¦a) : Î ((yes,no)=> Î¹(â€¦a,(e,Î¹)=>{ e? no(e) : yes(Î¹) })) }
		for(var name of ['then','catch'])
			r[name] = (â€¦a)=>{ type==='?' &&( type = 'object', Î¹ = Promise.resolve(Î¹) ) ;â†© Î¹[name](â€¦a) }
		â†© r })()
Î .& = Î¹=> Promise.all(Î¹)
Î .| = Î¹=> Promise.race(Î¹)
assign_properties_in_E_informal({
,'Function.prototype.P':Î»(â€¦a){â†© @.bind(âˆ…,â€¦a) }
,'Function.prototype.X':{get(){â†© Î¹=> @(Î¹) }}
,'Function.prototype.defer':Î»(){â†© setImmediate(@) }
,'Function.prototype.in':Î»(time){â†© setTimeout(@,max(0,time||0)*1e3) }
,'Function.prototype.every':Î»(time,opt){ r â† setInterval(@,max(0,time)*1e3) ;â†© !(opt&&opt.leading)? r : new TimerCons(@.in(0),r) }
# ,'Function.prototype.Î ':Î»(){ ... }
})

;[Set,Map].map(Seq=>
	_(Object.getPrototypeOf( new Seq().entries() )) <- ({
		,map(f){â†© [â€¦@].map(f) }
		}) )
tâ†; _(Object.getPrototypeOf( (t=setImmediate(=>{}), clearImmediate(t), t) )) <- ({
	,clear(){ clearImmediate(@) }
	,ref(){} ,unref(){}
	})
tâ†; _(Object.getPrototypeOf( (t=setTimeout(=>{},0), clearTimeout(t), t) )) <- ({
	,clear(){ @._repeat? clearInterval(@) : clearTimeout(@) }
	})

E.walk = (Î¹,f,k,o)=>( Tprim(Î¹)||_(Î¹).forEach((Î¹,k,o)=> walk(Î¹,f,k,o)), Î¹!==âˆ… && Î¹!==null && f(Î¹,k,o), Î¹ )
E.walk_graph = (Î¹,f,seen=[])=> !( Tprim(Î¹) || seen.includes(Î¹) ) && ( seen.push(Î¹), _(Î¹).forEach(Î¹=> walk_graph(Î¹,f,seen)), seen.pop(), Î¹!==âˆ… && Î¹!==null && f(Î¹), Î¹ )
E.walk_both_obj = (Î¹,fáµƒ,fáµ‡,fseen,seen=[])=> fseen && seen.includes(Î¹)? fseen(Î¹) : !( Tprim(Î¹) || Tfun(Î¹) || seen.includes(Î¹) ) && ( fáµƒ(Î¹), seen.push(Î¹), _(Î¹).forEach(Î¹=> walk_both_obj(Î¹,fáµƒ,fáµ‡,fseen,seen)), seen.pop(), fáµ‡(Î¹), Î¹ )
E.walk_fold = (Î¹,f,k,o)=> Tprim(Î¹)? Î¹ : Tarr(Î¹)? ( Î¹ = Î¹.map((Î¹,k,o)=> walk_fold(Î¹,f,k,o)), f(Î¹,k,o) ) : ( Î¹ = _(Î¹).map((Î¹,k,o)=> [k,walk_fold(Î¹,f,k,o)])._.object(), f(Î¹,k,o) )
E.walk_obj_edit = (Î¹,f)=> Tprim(Î¹) || Tfun(Î¹)? Î¹ : Tarr(Î¹)? Î¹.map(Î¹=> walk_obj_edit(Î¹,f)) : (=>{ for (var k in Î¹) if (Object.prototype.hasOwnProperty.call(Î¹,k)) Î¹[k] = walk_obj_edit(Î¹[k],f) ;â†© f(Î¹) })()
E.search_obj = (Î¹,f)=>{ râ†[]; walk(Î¹,(Î¹,k,o)=> Î¹!==âˆ… && Î¹!==null && f(Î¹,k,o) && r.push(Î¹)) ;â†© r }
E.search_graph = (Î¹,f)=>{ râ†[]; walk_graph(Î¹,Î¹=> Î¹!==âˆ… && Î¹!==null && f(Î¹) && r.push(Î¹)) ;â†© r }
# the right name for walk is going to be along the lines of
# f /@ x       x.map(f)
# f //@ x      postwalk(x,f) # MapAll
# it could be a data structure that you can fmap over

E.hrtime = Î»(Î¹){ t â† arguments.length===0? process.hrtime() : process.hrtime([Î¹|0,(Î¹-(Î¹|0))*1e9]) ;â†© t[0] + t[1]*1e-9 }
E.Time = Î»(Î¹){ r â† arguments.length===0? new Date() : Î¹ instanceof Date? Î¹ : new Date(Tnum(Î¹)? Î¹*1e3 : Î¹); r.toString = Î»(){â†© util.inspect(@) } ;â†© r }
fmt â† Î»(a,b){ t â† @.__local? npm`moment@2.18.1`(@).format('YYYY-MM-DD[T]HH:mm:ss.SSS') : @.toISOString(); t = t.slice(a,b); if (!@.__local && b > 10) t += 'Z' ;â†© t }
assign_properties_in_E_informal({
,'Date.prototype.local':{get(){â†© _(new Date(@)) <- ({__local:âœ“})}}
,'Date.prototype.i':{get(){â†© +@ / 1e3}}
,'Date.prototype.ym':      {get(){â†© fmt.call(@,0,'YYYY-MM'.â€–)}}
,'Date.prototype.ymd':     {get(){â†© fmt.call(@,0,'YYYY-MM-DD'.â€–)}}
,'Date.prototype.ymdh':    {get(){â†© fmt.call(@,0,'YYYY-MM-DDTHH'.â€–)}}
,'Date.prototype.ymdhm':   {get(){â†© fmt.call(@,0,'YYYY-MM-DDTHH:mm'.â€–)}}
,'Date.prototype.ymdhms':  {get(){â†© fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss'.â€–)}}
,'Date.prototype.ymdhmss': {get(){â†© fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.â€–)}}
,'Date.prototype.iso':     {get(){â†© fmt.call(@,0,'YYYY-MM-DDTHH:mm:ss.SSS'.â€–)}}
,'Date.prototype.hms':     {get(){â†© fmt.call(@,'YYYY-MM-DDT'.â€–,'YYYY-MM-DDTHH:mm:ss'.â€–)}}
})

E.schema = (=>{
	sc_merge â† Î»(a,b){ak â† _.keys(a); bk â† _.keys(b); bk.-(ak).forEach(k=> a[k] = b[k]); ak.âˆ©(bk).forEach(k=> a[k] = !Tprim(a[k])? sc_merge(a[k],b[k]) : !Tprim(b[k])? 'error' : a[k]) ;â†© a }
	â†© Î¹=> T.boolean(Î¹)? âœ“ : Tstr(Î¹)? '' : Tnum(Î¹)? 0 : Tarr(Î¹)? !Î¹.â€–? [] : [Î¹.map(schema).fold(sc_merge)] : _.pairs(Î¹).map(Î¹=> [Î¹[0],schema(Î¹[1])])._.object()
	})()

[#Q E.brightness #Q].def(=>{
	br â† hsáµ¥? {
		get(){â†©Î ( hsáµ¥`hs.brightness.get()`/100 )},
		set(Î¹){â†©Î ( hsáµ¥`hs.brightness.set(${Î¹*100|0})` )},
		} : npm`brightness@3.0.0`
	br.set_overlay = Î¹=> br.set(Î¹ > 0.5? (Î¹===1? 1 : Î¹-1/64) : (Î¹===0? 0 : Î¹+1/64)).then(=> robot_key_tap('â‡§âŒ¥FnF'+(Î¹ > 0.5? 2 : 1)) )
	â†© br })

E.os_daemon = (cmd,opt)=>{ cmd+=''; {once} â†Â opt||{}
	job â† {
		,[once?'RunAtLoad':'KeepAlive']:âœ“
		,Label:`Î¶.${Ï†(cmd).name}.${simple_hash(cmd).slice(0,8)}`
		,ProgramArguments:['sh','-c',sh`export anon_tns7w=${cmd}; PATH="/usr/local/bin:$PATH"; ${cmd}`]
		,StandardOutPath  :Ï†`~/Library/Caches/Î¶.logic/${simple_hash(cmd)}.out`.ensure_dir()+''
		,StandardErrorPath:Ï†`~/Library/Caches/Î¶.logic/${simple_hash(cmd)}.err`.ensure_dir()+''
		}
	job_path â†Â Ï†`~/Library/LaunchAgents/${job.Label}.plist`; job_path.BAD_exists() ||( job_path.Î¹ = job ); _.isEqual( job_path.plist, job ) || â€½
	â†© { ,cmd ,job_path ,restart(){ t â†Â @.job_path; sháµ¥`launchctl unload ${t} &>/dev/null; launchctl load ${t}` } } }
[#Q os_daemon.this #Q].def(=> process.env.anon_tns7w && os_daemon(process.env.anon_tns7w) )

E.if_main_do = f=>{ if( !module.parent ) f(â€¦process.argv.slice(2)) }

E.robot_key_tap = Î¹=> require_new(Ï†`~/code/scratch/keyrc/index.Î¶`).robot_key_tap(Î¹)
E.KEY_once = (â€¦a)=> require_new(Ï†`~/code/scratch/keyrc/index.Î¶`).KEY_once(â€¦a)

json_socket â†Â socket=>{ ğ…‚ğ…¦ğ…®ğ…ƒğ…°â†; ğ…®ğ…°ğ…®ğ…‚ğ…‚â†; â†© {
	,to(Î¹){ tâ†; (ğ…‚ğ…¦ğ…®ğ…ƒğ…°||(ğ…‚ğ…¦ğ…®ğ…ƒğ…°=( t= npm`ndjson@1.5.0`.stringify(), t.pipe(socket), t ) )).write(Î¹) }
	,on(f){ (ğ…®ğ…°ğ…®ğ…‚ğ…‚||(ğ…®ğ…°ğ…®ğ…‚ğ…‚= socket.pipe(npm`ndjson@1.5.0`.parse()) )).on('data',f) }
	} }
ipc_wait â† f=>{Hâ†; (H= new net.Server()).listen(0,'localhost').on('connection',socket=> json_socket(socket).on(_.once(Î¹=>{ socket.destroy(); H.close(); f(Î¹) })) ) ;â†© Î (yes=> H.on('listening',yes.P(H)) ) }
E.notify = Î¹=>{ Tstr(Î¹) &&( Î¹ = Î¹.re`\n`? Î¹.re`^(.*?)\n([^]*)`.slice(1) : Î¹.re` `? Î¹.re`^(.*?) ([^]*)`.slice(1) : [Î¹] )
	â†© Î (yes=> ipc_wait(yes).then(H=>
		hsáµ¥`hs.notify.new(
			function(x) x:withdraw(); hs.socket.new():connect('localhost',${H.address().port}):write(hs.json.encode({ at=x:actualDeliveryDate() })..'\n') end
			,{ title=${Î¹[0]}, informativeText=${Î¹[1]||''}, otherButtonTitle='\u{2063}', actionButtonTitle='\u{2063}', }
			):send()`
		) ) }
E.fn_wrap_lits = (eval_,f)=> code=> eval_('('+Î¶_parse(code+'').map(Î¹=> Î¹.T==='shebang'? '' : Î¹.T==='string'||Î¹.T==='regex'? f(Î¹.Î¹) : Î¹ ).join('')+')')

E.normal_PDF = x=>{ Î¼ â† 0; Ïƒ â† 1; v â† Ïƒ**2 ;â†© 1/sqrt(v*Ï„)*exp(-((x-Î¼)**2)/(2*v)) }
E.normal_CDF = x=>{ Î¼ â† 0; Ïƒ â† 1 ;â†© (1 + npm`math-erf@1.0.0`( (x-Î¼) / (Ïƒ*sqrt(2)) ))/2 }
E.invert_specific = f=> fx=>{ t â† 0; while (f(t) > fx) t+=0.01 ;â†© t }

##################################### .Î¶rc #####################################
process.env.PATH = ['./node_modules/.bin','/usr/local/bin',â€¦(process.env.PATH||'').split(':'),'.'].âˆª([]).join(':')
E.nice_url = Î»(Î¹){tâ†; Uri â† npm`urijs@1.18.12`; {sourcemap} â† Î¹; Î¹=Î¹+''
	# very nice google maps urls
	# if url â‰ˆ google.com/maps/
	# fetch short url:
	# 	# @2016-08-18 wait-click $('#searchbox-hamburger')
	# 	wait-click $('[guidedhelpid="searchbox_hamburger"]')
	# 	wait-click $('[jsaction="settings.share"]')
	# 	wait-check $('#share-short-url')
	# 	t â† $('.widget-share-link-url').val() wait Î¹=> Î¹.re`^https?://goo.gl/maps/`
	# 	return t
	# 	$('.modal-container').click()
	# wait-check: if not $`${Î¹}:checked`; Î¹.click(); wait for $`${Î¹}:checked`
	# wait-click: wait for Î¹.â€–; Î¹.click()
	# decode: parse curl https://goo.gl/maps/7s6wKcW8zUC2

	if (t=Î¹.re`^"(.*)"$`) â†© 'â€œ'+t[1]+'â€' # ! bad hack

	apply_regexes â† regs=> multiline(regs).split(/\n/g).map(Î»(t){ [a,b] â† t.split(/  +/g); Î¹ = Î¹.replace(RegExp(a),b) })
	URL â† /\b(?:(?:https?|chrome):\/\/|(?:file|mailto):)(?:[^\sâ€œâ€"<>]*\([^\sâ€œâ€"<>]*\))?(?:[^\sâ€œâ€"<>]*[^\sâ€œâ€"<>)\]}âŸ©?!,.:;])?/g
	parse_alicetext â† Î¹=> _.zip(Î¹.split(URL).map(Î¹â‡’ {type:'text', Î¹}), (Î¹.match(URL)||[]).map(Î¹â‡’ {type:'url', Î¹}))._.flatten(âœ“).filter(Î¹=> !(Î¹ === âˆ… || (Î¹.type === 'text' && Î¹.Î¹ === '')))

	# Î¹ = parse_alicetext(Î¹).map(Î»(Î¹){tâ†; Î¹.type==='url' && (t=Uri(Î¹.Î¹)).domain()+t.path()==='google.com/webhp' && t.path('/search') && (Î¹.Î¹ = t+'') ;â†© Î¹})._.map('Î¹').join('')

	if (sourcemap && sourcemap.title && sourcemap.url && (t=Uri(Î¹.slice(â€¦sourcemap.url)),
		t.domain() in {'github.com':0} ||
		t.domain()+t.path()==='google.com/search'
		)) Î¹ = Î¹.slice(â€¦sourcemap.url)
	
	Î¹ = Î¹.replace(/%CE%B6/g,'Î¶')
	apply_regexes(Î»(){/*
	\bhttps://         http://
	\b(http://)www\.   $1
	\b(http://)(?:mail\.)?(google\.com/mail/)u/0/[?&]?#(?:(?:label|search)/[\w%+]+|\w+)/(\w+)        $1$2#all/$3
	 - Gmail( http://google\.com/mail/)                $1
	 - [\w.]+@gmail\.com( http://google\.com/mail/)    $1
	Fwd: (.* http://google\.com/mail/)                 $1
	\b(http://)en\.(?:m\.)?(wikipedia\.org/)           $1$2
	\b(http://)youtube\.com/watch[?&]v=([\w-_]+)       $1youtu.be/$2
	\b(http://youtu\.be/[\w-_]+)[?&]feature=youtu\.be  $1
	\b(http://youtu\.be/[\w-_]+)&(\S*)$                $1?$2
	 - YouTube( http://youtu\.be/)                     $1
	 \([oO]fficial [vV]ideo\)( http://youtu\.be/)      $1
	\b(http://)smile\.(amazon\.com/)                   $1$2
	\b(http://docs\.google\.com/document/d/[\w_-]+)/edit(?:[?&]ts=\w+)?$  $1
	\b(http://docs\.google\.com/spreadsheets/d/[\w_-]+)/edit(?:#gid=0)?$  $1
	 - Google Docs( http://docs\.google\.com/)         $1
	\b(http://dropbox\.com/\S*)[?&]dl=0$               $1
	\b(http://)facebook(\.com/)                        $1fb$2
	\b(http://fb\.com/)profile\.php\?id=               $1
	\(\d+\) (.* http://fb\.com/)                       $1
	 - Wikipedia, the free encyclopedia( http://wikipedia\.org/)  $1
	 - Album on Imgur( http://imgur\.com/)             $1
	 - Google Maps( http://google\.com/maps/)          $1
	*/})

	Î¹ = parse_alicetext(Î¹).map(Î¹=>{tâ†;
		if (Î¹.type === 'url') {
			u â† Uri(Î¹.Î¹)
			switch (u.domain()) { default: â†© Î¹
				break; case 'amazon.com':
					u.removeSearch(['sa-no-redirect','keywords','qid','ie','s','sr','tag','linkCode','camp','creative','creativeASIN'])
					u.filename().re`^ref=[\w_]+$` && u.filename('')
					if (t=u.resource().re`^/(?:[\w-]+/)?(?:dp|gp)/(?:product/)?(\w+)/?$`) {Î¹.Î¹ = 'http://amzn.com/'+t[1] ;â†© Î¹}
				break; case 'fb.com': u.removeSearch(['fref','hc_location','_rdr','pnref'])
				break; case 'google.com': if(_.isEqual( u.segment(),['search'] )){ u.removeSearch(['gws_rd','aqs','sourceid','es_sm','ie']); u.hasSearch('q') && u.removeSearch('oq') }
				}; Î¹.Î¹ = u+'' }
		â†© Î¹}).map(Î¹=>Î¹.Î¹).join('')

	apply_regexes(Î»(){/*
	: \d{5,}: Amazon(?:Smile)?: Books( http://amzn.com/)        $1
	*/})

	Î¹ = parse_alicetext(Î¹).map(Î¹=>{tâ†;
		if (Î¹.type === 'url') {
			u â† Uri(Î¹.Î¹)
			if( Î¹.Î¹.re`\)$` && u.hash()==='' ) Î¹.Î¹ += '#'
			}
		â†© Î¹}).map(Î¹=>Î¹.Î¹).join('')

	#################################### todo ####################################
	# http://smile.amazon.com/gp/product/0300078153
	# Seeing like a State http://amzn.com/0300078153

	# https://docs.google.com/spreadsheets/d/1wfFMPo8n_mpcoBCFdsIUUIt7oSm7d__Duex51yejbBQ/edit#gid=0
	# http://goo.gl/0nrUfP

	# generalize the â€œfix & to ?â€ to many different things

	# http://www.ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	# A Big Little Idea Called Legibility http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility/
	# http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility
	# http://ribbonfarm.com/2010/07/26/a-big-little-idea-called-legibility (3K words)

	# decodeURI('https://www.google.com/search?q=%28cos%28x%29-x%2F%2810*%CF%80%29%29%5E2%2C+cos%28x%29%5E2%2C+2*%28-x%2F%2810*%CF%80%29%29*cos%28x%29%2C+%28-x%2F%2810*%CF%80%29%29%5E2&oq=%28cos%28x%29-x%2F%2810*%CF%80%29%29%5E2%2C+cos%28x%29%5E2%2C+2*%28-x%2F%2810*%CF%80%29%29*cos%28x%29%2C+%28-x%2F%2810*%CF%80%29%29%5E2&gs_l=psy-ab.3...106740.118625.0.119014.18.18.0.0.0.0.163.1395.16j1.17.0....0...1.1.64.psy-ab..2.0.0.9dJSX0MrIe0')
	# https://www.google.com/search?q=(cos(x)-x%2F(10*Ï€))^2%2C+cos(x)^2%2C+2*(-x%2F(10*Ï€))*cos(x)%2C+(-x%2F(10*Ï€))^2&oq=(cos(x)-x%2F(10*Ï€))^2%2C+cos(x)^2%2C+2*(-x%2F(10*Ï€))*cos(x)%2C+(-x%2F(10*Ï€))^2&gs_l=psy-ab.3...106740.118625.0.119014.18.18.0.0.0.0.163.1395.16j1.17.0....0...1.1.64.psy-ab..2.0.0.9dJSX0MrIe0
	# https://www.google.com/search?q=(cos(x)-x%2F(10*Ï€))^2%2C+cos(x)^2%2C+2*(-x%2F(10*Ï€))*cos(x)%2C+(-x%2F(10*Ï€))^2&oq=(cos(x)-x%2F(10*Ï€))^2%2C+cos(x)^2%2C+2*(-x%2F(10*Ï€))*cos(x)%2C+(-x%2F(10*Ï€))^2
	# https://www.google.com/search?q=(cos(x)-x/(10*Ï€))^2,+cos(x)^2,+2*(-x/(10*Ï€))*cos(x),+(-x/(10*Ï€))^2&oq=(cos(x)-x/(10*Ï€))^2,+cos(x)^2,+2*(-x/(10*Ï€))*cos(x),+(-x/(10*Ï€))^2

	â†© Î¹}
E.sfx = Î»(ss,â€¦Î¹s){ Î¹ â† ss[0]
	shâ‚`afplay ~/code/scratch/dotfiles/${Î¹}.wav`
	if (Î¹==='done' && osaáµ¥`get volume settings`['output muted']){ br â† brightness; br.get().then(old=>{ br.set(0); (=> br.set(old)).in(0.2) }) }
	}
ğŸ”…ğŸ”† â† go=>{ Î¹s â† [0,1,2.5,5.5,10,16].map(Î¹=>Î¹/16) ;â†© brightness.get().then(br=> brightness.set_overlay( Î¹s[min(max( 0, find_closest_ISU(Î¹s,br) + go ), Î¹s.â€–-1 )] )) }
E.ğŸ”… = => ğŸ”…ğŸ”†(-1)
E.ğŸ”† = => ğŸ”…ğŸ”†(1)
E.moon = Î¹=>{ Î¹||(Î¹=Time()); moons â† [â€¦'ğŸŒ‘ğŸŒ’ğŸŒ“ğŸŒ”ğŸŒ•ğŸŒ–ğŸŒ—ğŸŒ˜'] ;â†© moons[floor((npm`suncalc@1.7.0`.getMoonIllumination(Î¹).phase * moons.â€– + 0.5) % moons.â€–)] }
[#Q E.anon #Q].def({ ,get(){tâ†; â†© [t=random_id.greek(5),t+'â†;'] }})
[#Q E.now #Q].def({ ,get(){ t â†Â Time(); â†© [t.ymdhm,t.ymdhms,t.ymdhmss] }})
[#Q E.day #Q].def({ ,get(){â†© Time().local.ymd }})

E.github_url = Î¹=>{
	github_remote_origin â† file=>{
		Î¹ â† Ï†(file).root('/')
		root â† Î¹; while( root+''!=='/' && !root.Ï†`.git`.BAD_exists() ) root = root.Ï†`..`
		if( root+''==='/' ) throw _(Error()) <- ({ human:'did not find github remote origin for '+(file||'<anon>') })
		Î¹ = (Î¹+'').slice((root+'/').â€–)
		name â† root.Ï†`.git/config`.ini['remote "origin"'].url.match(/github\.com[:/](.+)\/(.+)\.git/).slice(1).join('/')
		commit â†Â /*jet[*/ catch_Î¹(=> root.Ï†`.git/HEAD`.text.trim()==='ref: refs/heads/master' && root.Ï†`.git/refs/heads/master`.text.trim() ) /*]*/ || sháµ¥`cd ${root}; git rev-parse HEAD`+''
		â†© encodeURI('http://github.com/'+name+'/blob/'+commit+'/'+Î¹) }
	[file,h] â† sbáµ¥`view = deserialize(${Î¹}); s = view.sel(); [ view.file_name(), [view.rowcol(Î¹) for Î¹ in [s[0].begin(), s[-1].end()]] ]`
	fm â† Î¹=> 'L'+(Î¹+1)
	â†© github_remote_origin(file||'')+( _.isEqual(h[0],h[1])? '' : '#'+(h[0][0]===h[1][0]? fm(h[0][0]) : fm(h[0][0])+'-'+fm(h[1][0])) ) }
E.go_to = (â€¦a)=>{ # synonyms: go_to, open, search?
	opt â† !Tprim(a[-1])? a.pop() : {}
	type â† a.â€–===1? âˆ… : a.shift()
	Î¹ â† a[0]
	{new:new_,focus,in_app,sb_view_file_name} â† _({new:âœ—, focus:âœ“, in_app:âˆ…, sb_view_file_name:âˆ…}) <- (opt)

	is_url â† Î¹=> Î¹.re`^((https?|chrome-extension)://|file:|mailto:)`
	searchify â† Î¹=> 'https://www.google.com/search?q='+encodeURIComponent(Î¹)

	in_app && (in_app = in_app.toLowerCase())

	if (!focus) sfx`ack`

	# windows_in_current_space_in_app â† app=> hsáµ¥`hs.fnutils.imap( hs.window.filter.new(false):setAppFilter(${app},{visible=true,currentSpace=true}):getWindows(), function(x) return x:id() end)`
	# apps_with_windows_in_current_space â† => hsáµ¥`hs.fnutils.imap( hs.window.filter.new(false):setAppFilter('default',{visible=true,currentSpace=true}):getWindows(), function(x) return x:application():name() end)`

	############################ go to specific chrome ###########################
	# 	wnd â† 1
	# 	is_chromeapp_active â† is_chromeapp_exist && osaáµ¥`tell app "System Events"; get name of menu bar items of menu bar 1 of process (name of app ${app}); end tell`[1] !== 'Chrome'
	# 	# System Events got an error: osascript is not allowed assistive access
	# 	# compile_mapping(M('c','; '+js`terminal_do_script(${sh`Î¶ --fresh ${js`(â€¦${osa_activate_thingáµ¥+''})('chrome')`}; exit`})`)).Î¹,
	# 	if (is_chromeapp_active){ osaáµ¥`tell app "System Events"; activate app "sublime text"; click menu item â€¦${Tnum(wnd)? osa`(name of window ${wnd} of a)` : osa`${wnd}`} of menu 1 of menu bar item "Window" of menu bar 1 of process (name of app ${app}); end tell; activate app ${app}` ;â†© }
	#  
	# 	t â† [2,1]; chrome_simple_js_áµ¥(`alert('foo')`,{window:t[0],tab:t[1]})

	if (!type){ !new_ || â€½
		if (!is_url(Î¹)) Î¹ = searchify(Î¹)
		if (!in_app && Î¹.re`^file:`){
			file â† decodeURI(Î¹).replace(re`^file:(//)?`,'')
			if (file[0]!=='/') file = require('path').normalize(require('path').join( Ï†(sb_view_file_name||â€½).Ï†`..`+'', file ))
			if (Ï†(file).is_dir) in_app = 'path finder'
			else if (['.pdf','.m4a','.epub','.mobi'].includes(require('path').extname(file)));
			else if (['.png','.jpg'].includes(require('path').extname(file))) in_app = '#ql'
			else in_app = 'sublime text'
			[Ë£,p,r] â† decodeURI(Î¹).re`^(.*?:)([^]*)`; Î¹ â† p+r.replace(/[^\/]+/g,encodeURIComponent.X)
			}
		if (in_app==='#ql') shâ‚`( &>/dev/null qlmanage -p ${file} &)`
		else{
			in_app ||( in_app = 'chrome' )
			if (in_app==='chrome'){
				t â† osaáµ¥`chrome: URL of tabs of windows`.find_index_deep(t=> t===Î¹); if (t)
					{ [window_,tab] â† t; osaâ‚`chrome: set active tab index of window ${window_+1} to ${tab+1}`; osaâ‚`chrome: activate` ;â†© } }
			if (Î¹.re`^chrome-extension://`) sháµ¥`duti -s com.google.Chrome chrome-extension` # bug workaround
			sháµ¥`open â€¦${in_app && sh`-b ${in_app |> (memoize_persist(Î¹=> catch_Î¹(=> osaáµ¥`id of app ${Î¹}`) ))}`} ${!focus && '-g'} ${Î¹}`
			}
		if (focus && in_app==='path finder') osaâ‚`${in_app}: activate`
		}
	else if (type==='app'){ ( !new_ && focus && !in_app )||â€½; app â† Î¹
		# ! should gather most of this information periodically async & record it. should use FRP.
		hint_screen â† {'sublime text':2, 'path finder':3, 'github desktop':4}
		isnt_standalone â† {ibooks:1, preview:1}
		if( app==='chrome' && (sháµ¥`ps -x -o comm`+'').includes('/Chrome Apps.localized/') ){ ['âŒ˜â£',â€¦'chromeâ†©'].map(robot_key_tap) ;â†© }
		hint_screen[app] && robot_key_tap('^'+hint_screen[app])
		isnt_standalone[app]? osaáµ¥`${app}: if it is running then; activate; end if` : osaáµ¥`${app}: activate`
		}
	else if (type==='screen'){ ( !new_ && focus && !in_app && /^[1-9]$/.test(Î¹+'') )||â€½; robot_key_tap('^'+Î¹) }
	else if (type==='path'){ ( !new_ && focus )||â€½
		# ! i think this might be a pretty badly designed type
		new_ = âœ“
		if (Î¹.re`^(?:code|consume|documents|history|notes|pix)/.{1,80}:\d+:`){ !in_app || â€½ # ! duplication with munge_stuff.py:FIND_RESULT
			# in_app = 'sublime text'
			[Ë£,Î¹,line] â† Î¹.re`^(.+):(\d+):$`
			Î¹ = Ï†('~/file/'+Î¹)
			sháµ¥`'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' ${Î¹}:${line}` ;â†© }
		if (in_app==='terminal'){
			here â† hsáµ¥`hs.fnutils.imap( hs.window.filter.new(false):setAppFilter('Terminal',{visible=true,currentSpace=true}):getWindows(), function(x) return x:id() end)`
			unbusy â† => osaáµ¥`terminal: id of windows where busy = false`
			available â† here.âˆ©(unbusy())[0]
			terminal_do_script( sh`cd ${Î¹}; â€¦${!available && sh.clear}`, osa`â€¦${!!available && osa`in (window 1 whose id = ${available})`}; â€¦${focus && 'activate'}` ) ;â†© }
		else go_to(encodeURI('file:'+Ï†(Î¹).root('/')),{in_app,focus,sb_view_file_name})
		}
	else â€½ }

###### metaprogramming â†’ runtime macros built on top of template literals ######
# to design this correctly, (ss,â€¦Î¹s) => (s,â€¦a) or maybe (`s${a}`) lol no
# existing semistandard usage is in
# 	im_autowhite
# 	scratch.txt
# 	Î¶/index.Î¶
# s is interned, so use it as a memoization key for things
E.is_template = ([ss,â€¦Î¹s])=> ss && Tarr(ss.raw) && ss.raw.â€–-1 === Î¹s.â€–
tmpl_flatten â† (raw2,Î¹s2)=> _.zip(raw2,Î¹s2)._.flatten(âœ“).slice(0,-1).filter(Î¹=> Î¹!=='')
E.simple_template = Î»(ss,Î¹s,filter){ is_template([ss,â€¦Î¹s]) || â€½
	falsy â† Î¹=> Î¹===âˆ…||Î¹===null||Î¹===âœ—
	if( filter && !Tfun(filter) ){ [root,join] â† filter; filter = Î¹=> Tarr(Î¹)? Î¹.map(Î¹=> root`${Î¹}`).join(join) : falsy(Î¹)? '' : âˆ… }
	filter_special â† Î¹=> falsy(Î¹)? '' : Î¹+''
	Î¹ â† tmpl_flatten( ss.raw.map(Î¹=> Î¹.replace(/\\(?=\$\{|`)/g,'')), Î¹s.map(Î¹â‡’{raw:Î¹}) )
	for(iâ†0;i<Î¹.â€–-1;i++) if (Tstr(Î¹[i]) && !Tstr(Î¹[i+1])) Î¹[i] = Î¹[i].replace(/â€¦$/,=>{ Î¹[i+1] = filter_special(Î¹[i+1].raw); i++ ;â†© '' })
	filter && (Î¹ = Î¹.map(Î»(Î¹){tâ†; â†© Tstr(Î¹)? Î¹ : (t=filter(Î¹.raw), t===âˆ…? Î¹ : t) }))
	â†© Î¹}
E.easy_template = (=>{
	read â† (ss,Î¹s)=> tmpl_flatten(ss.raw,Î¹s.map(Î¹=>[Î¹]))
	show â† Î»(Î¹){ raw â† ['']; Î¹s â† []; Î¹.forEach(Î¹=> Tstr(Î¹)? raw[-1]+=Î¹ : (Î¹s.push(Î¹), raw.push('')) ) ;â†© [{raw},â€¦Î¹s] }
	â†© f=> Î»(ss,â€¦Î¹s){â†© f.call(@,read(ss,Î¹s),show) }
	})()

E.clipboard = def({},'Î¹',{ get(){â†© sháµ¥`pbpaste`+'' }, set(Î¹){ shâ‚`${sb.encode(Î¹)} |`` pbcopy` }, })
E.sb = Î» self(){â†© self._call() } # let personal concepts use sb as callable
[#Q sb.tab #Q].def({
	get(){
		r â† sbáµ¥`[serialize(Î¹) for Î¹ in (Î¹.view() for Î¹ in sublime.windows() for Î¹ in Î¹.sheets()) if Î¹]`
		r.active = sbáµ¥`serialize(sublime.active_window().active_sheet().view())`
		;[â€¦r,r.active].map(Î¹=> Î¹ && [#Q Î¹.Î¹ #Q].def({ enumerable:âœ—,
			get(){â†© sbáµ¥` view = deserialize(${@}); view.substr(Region(0,view.size())) ` },
			set(Î¹){ sb_editáµ¥(@)` view.replace(edit,Region(0,view.size()),${Î¹}) ` },
			}) )
		[#Q r.push #Q].def({ enumerable:âœ—, value:
			Î»(Î¹){ shâ‚`${sb.encode(Î¹)} |`` open -a 'Sublime Text.app' -f`; @.â€– = 0; (=> _(@) <- (sb.tab) ).in(0.02) } # ! wtf async/sync mix
			})
		â†© r },
	})

fs_ipc_emit â† (port,Î¹)=>{ Ï†`/tmp/fs_ipc_${port}`.Î¹ = Î¹ ;â†© sháµ¥`curl -s -X PUT localhost:${port}`+'' }

E.sbáµ¥ = Î»(ss,â€¦Î¹s){
	ENC â† JSON.stringify; Î¹ â† simple_template(ss,Î¹s).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('')
	t â† JSON.parse(fs_ipc_emit(34289,Î¹)); t===null &&( t = âˆ… ) ;â†© t }
E.sb_editáµ¥ = view=>(ss,â€¦Î¹s)=>{ sbáµ¥`edit(${view},${py(ss,â€¦Î¹s)})` }

# sublime/sb
# 	tab
# 	view

E.re = Î»(ss,â€¦Î¹s){
	# would like to embed regex in [] and have that be ok; ie re`[${/[a-z]/}]` = /[a-z]/
	Î¹ â† simple_template(ss,Î¹s,[(â€¦a)=>re(â€¦a).source,''])
	ENC â† Î¹=> T.RegExp(Î¹)? ( Î¹.flags.replace(/[gy]/g,'')==='u' || â€½, Î¹.source ) : (Î¹+'').replace(/([.*+?^${}()\[\]|\\])/g, '\\$1')
	â†© RegExp( Î¹.map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join(''), 'u' ) }
assign_properties_in_E_informal({
'RegExp.prototype.Î»':Î»(Î¹){â†© Î¹===âˆ… || Î¹===null? null : Î¹.match(@) },
'RegExp.prototype.g':{get(){â†© RegExp(@.source,@.flags.replace(/g/,'')+'g') }},
'RegExp.prototype.i':{get(){â†© RegExp(@.source,@.flags.replace(/i/,'')+'i') }},
'RegExp.prototype.m':{get(){â†© RegExp(@.source,@.flags.replace(/m/,'')+'m') }},
'RegExp.prototype.u':{get(){â†© RegExp(@.source,@.flags.replace(/u/,'')+'u') }},
'RegExp.prototype.y':{get(){â†© RegExp(@.source,@.flags.replace(/y/,'')+'y') }},
'String.prototype.re':{get(){â†© (ss,â€¦Î¹s)=> @.match(re(ss,â€¦Î¹s))}},
})

E.js = E.py = Î»(ss,â€¦Î¹s){ ENC â† JSON.stringify ;â†© simple_template(ss,Î¹s).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('') }

E.sh = Î»(ss,â€¦Î¹s){ ENC â† Î¹=> "'"+(Î¹+'').replace(/'/g,"'\\''")+"'" ;â†© simple_template(ss,Î¹s,[sh,' ']).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('') }
sh.clear = "/usr/bin/clear && printf %s $'\\e[3J'"
ellipsify â† Î¹=> util_inspect_autodepth(Î¹.slice(0,100))+(Î¹.slice(100).â€–?'â€¦':'')

if_sh_err â† (name,code,Î¹)=>{ if (Î¹.status!==0) throw _(Error(name+'`'+code+'` â†’ status:'+Î¹.status+', stderr:'+ellipsify(Î¹.stderr+''))) <- (_(Î¹).pick('status','stdout','stderr')) }
E.sháµ¥ = Î»(ss,â€¦Î¹s){ code â† sh(ss,â€¦Î¹s)
	# Î¹ â† process_spawn('/bin/sh',{ ,args:['-c',code] ,âš“:1 })
	Î¹ â† require('child_process').spawnSync(code,{shell:âœ“})
	if_sh_err('sháµ¥',code,Î¹)
	â†© _(Î¹.stdout) <- ({ toString(â€¦a){ Î¹ â† Buffer.prototype.toString.call(@,â€¦a) ;â†© a.â€–? Î¹ : Î¹.replace(/\n$/,'') } }) }
_shâ‚ â† (ss,Î¹s,opt={})=>{
	if (ss.â€–===2 && ss[0]==='' && ss[1].re`^ *\|$`){ opt.stdio && â€½; opt.stdio = [Ï†.fd.from(Î¹s[0]),'pipe','pipe',] ;â†© shâ‚2(opt) }
	else{ code â† sh(ss,â€¦Î¹s)
		# Î¹ â† process_spawn('/bin/sh',_({ ,args:['-c',code] }) <- (opt))
		# Î¹.exit.then(exit=>{ if_sh_err('shâ‚',code,_(Î¹) <- ({exit})) })
		Î¹ â† require('child_process').spawn(code,_({shell:âœ“}) <- (_(opt).pick('stdio','detached')))
			.on('exit',Î»(status){ if_sh_err('shâ‚',code,_({status}) <- (Î¹)) })
		â†© Î¹ } }
E.shâ‚ = (ss,â€¦Î¹s)=> _shâ‚(ss,Î¹s)
E.shâ‚2 = opt=>(ss,â€¦Î¹s)=> _shâ‚(ss,Î¹s,opt)

E.osa = Î»(ss,â€¦Î¹s){tâ†;
	Î¹ â† simple_template(ss,Î¹s)
	# ! this is such a mess
	if (Tstr(Î¹[0]) && (t=Î¹[0].re`^(?!tell )([\w ]+):`)){ Î¹[0] = Î¹[0].slice(t[0].â€–); Î¹ = [osa`tell app ${t[1]};`, â€¦Î¹, '; end tell'] }
	if (!Tstr(Î¹[0]) && Tstr(Î¹[0].raw) && Î¹[0].raw.re`^[\w ]+$` && Tstr(Î¹[1]) && (t=Î¹[1].re`^ *:`)){ Î¹[1] = Î¹[1].slice(t[0].â€–); Î¹ = [osa`tell app ${Î¹.shift().raw};`, â€¦Î¹, '; end tell'] }
	â†© Î¹.map(Î¹=> !Tstr(Î¹)? applescript.print(Î¹.raw) : Î¹.replace(/;/g,'\n') ).join('') }
E.osaáµ¥ = Î»(ss,â€¦Î¹s){ Î¹ â† osa(ss,â€¦Î¹s) ;â†© applescript.parse(sháµ¥`osascript -ss -e ${Î¹}`+'') }
E.osaâ‚ = Î»(ss,â€¦Î¹s){ Î¹ â† osa(ss,â€¦Î¹s); shâ‚`osascript -ss -e ${Î¹}` }

E.terminal_do_script = Î»(a,b){ Ï†`/tmp/__Â·`.Î¹ = a; osaáµ¥`terminal: do script "Â·" â€¦${b}` } # ~/.bashrc.Î¶ :: E['Â·']
E.chrome_simple_osaáµ¥ = (Î¹,{tab,window=0})=> osaáµ¥`chrome: execute window â€¦${window+1}'s tab â€¦${tab+1} javascript ${Î¶_compile(Î¹)}`
E.chrome_simple_js_áµ¥ = (Î¹,{tab,window=0})=> osaáµ¥`chrome: tell window â€¦${window+1}'s tab â€¦${tab+1} to set URL to ${'javascript:'+Î¶_compile(Î¹)}`
# E.chromeáµ¥ = â€¡ not actually used â€¡ wait, nope, is actually used, but mostly in one-off scripts
	# Î»(Î¹,tab){tab = tab!==âˆ…? 'tab '+(tab+1) : 'active tab'
	# 	# E.chrome_$áµ¥ = Î»(Î¹,tab){râ†; $null â† '__$null_'+random_id(10); fst â† 1; while ((r=chromeáµ¥("if (window.jQuery){"+Î¹+"} else {"+(fst? (fst=0, "t â† document.createElement('script'); t.src = 'https://code.jquery.com/jquery-3.1.1.min.js'; document.getElementsByTagName('head')[0].appendChild(t)") : "")+"; '"+$null+"'}",tab))===$null) ;â†© r}
	# # probably add a random_id(10) call to '#applescript_hack'
	# 	t â† "t â† document.querySelectorAll('#applescript_hack')[0]; t && t.parentNode.removeChild(t); Î¹ â† (0,eval)("+JSON.stringify(Î¶_compile(Î¹))+"); t â† document.createElement('div'); t.id = 'applescript_hack'; t.style = 'display:none;'; t.textContent = JSON.stringify(Î¹); t2 â† document.querySelectorAll('head')[0]; t2.insertBefore(t,t2.firstChild); âˆ…"
	# 	chrome_simple_js_áµ¥(t,tab)
	# 	t â† "document.querySelectorAll('#applescript_hack')[0].textContent"
	# 	â†© JSON.parse(chrome_simple_osaáµ¥(t,tab) || '""') }

E.which = _.memoize((â€¦a)=> !is_template(a)? which`${a[0]}` : catch_Î¹(=> sháµ¥`which â€¦${sh(â€¦a)}`+'')) # ! should use FRP to background-recompute hash values after certain amounts of time and discard hash values after certain amounts of time

[#Q E.hsáµ¥ #Q].def(=> which('hs') && Î»(ss,â€¦Î¹s){
	ENC â† Î¹=> Tstr(Î¹) || Tnum(Î¹)? JSON.stringify(Î¹) : â€½; Î¹ â† simple_template(ss,Î¹s).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('')
	# t â† sháµ¥`hs -c ${Î¹}`
	t â† sháµ¥`/usr/local/bin/hs -c ${Î¹}`
	# t â† child_ process.spawnSync(which('hs'),['-c',Î¹]).stdout
	t â† (t+'').split('\n')[-1]; r â† catch_Î¹(=> JSON.parse(t)[0]) ;â†© r!==âˆ…?r: t } )

E.tsáµ¥ = Î»(ss,â€¦Î¹s){
	ENC â† JSON.stringify; Î¹ â† simple_template(ss,Î¹s).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw) : Î¹).join('')
	Î¹ = 'require "totalspaces2"; TS = TotalSpaces2; '+Î¹
	PORT = 34290
	R â† => JSON.parse(fs_ipc_emit(PORT,Î¹))[0]
	launch_serv â† =>{
		(sháµ¥`gem list`+'').re`(^|\n)totalspaces2 ` || â€½
		t â† Ï†`/tmp/evalserv_${random_id(9)}.rb`; t.text = String.raw`#!/usr/bin/env ruby
			require "socket"; require "json"
			server = TCPServer.new("localhost",${PORT})
			loop do
			  t = server.accept
			  r = JSON.generate([eval(File.read("/tmp/fs_ipc_#{${PORT}}"))])
			  t.print "HTTP/1.1 200 OK\r\n"+"Content-Type: text/plain\r\n"+"Content-Length: #{r.bytesize}\r\n"+"Connection: close\r\n"+"\r\n"+r
			  t.close
			end`
		sháµ¥`chmod +x ${t}`
		require('child_process').spawn(t,{shell:âœ“,detached:âœ“,stdio:'ignore'}).unref()
		# process_spawn('/bin/sh',{ ,args:['-c',t+''] ,child:âœ— })
		}
	try{ â†© R() }catch(e){ if( e.status===7 ) launch_serv(); sleep(0.1) ;â†© R() } }

# such hack
json2_read â† Î¹=>{ r â† JSON.parse(Î¹); (Î» Î›(Î¹,k,o){if( Î¹.type==='Buffer' ){
	t â† 'data' in Î¹ || 'utf8' in Î¹? Buffer.from(Î¹.data||Î¹.utf8) : 'base64' in Î¹? Buffer.from(Î¹.base64,'base64') : â€½
	if( o===âˆ… ) r = t; else o[k] = t
	} else if(! Tprim(Î¹) ) _(Î¹).forEach(Î›)})(r) ;â†© r }
json2_show â† Î¹=> JSON_pretty(Î¹,Î»(Î¹){tâ†;
	if (Buffer.isBuffer(Î¹)) â†© Î¹.equals(Buffer.from(t=Î¹+''))? {type:'Buffer', utf8:t} : {type:'Buffer', base64:Î¹.toString('base64')}
	â†© Î¹})

[#Q E.Ï† #Q].def(=>{
	ENC â† Î¹=> Î¹.re`/`? Î¹.replace(/[\/%]/g, encodeURIComponent.X) : Î¹
	Ï†.â»Â¹ = Î¹=> /%2F/i.test(Î¹)? Î¹.replace(/%2[F5]/gi, decodeURIComponent.X) : Î¹
	Ï†.fd = {}; Ï†.fd.from = Î¹=> fs.createReadStream(âˆ…,{ fd:fs.openSync(_(Ï†`/tmp/${random_id(20)}`) <- ({Î¹}) +'','r') })

	existsSync â† Î¹=> !T.Error(catch_union(=> fs.accessSync(Î¹)))
	mkdir_p â† Î» Î›(Î¹){ try{ fs.mkdirSync(Î¹) }catch(e){ if (e.code==='EEXIST'||e.code==='EISDIR') â†©; t â† path.dirname(Î¹); if (e.code!=='ENOENT' || Î¹===t) throw e; Î›(t); fs.mkdirSync(Î¹) } }
	# walk â† Î»*(root,files){root += '/'
	# 	walk_ â† Î»*(Î¹){try {l â† fs.readdirSync(root+Î¹); for (iâ†0;i<l.â€–;i++){t â† Î¹+l[i]; try{ fs.statSync(root+t).isDirectory()? (yield root+t, yield* walk_(t+'/')) : (files && (yield root+t)) }catch(e){} }} catch(e){} }
	# 	yield* walk_('') }
	read_file â† Î»(Î¹){ try{â†© fs.readFileSync(Î¹) }catch(e){ if (!(e.code==='ENOENT')) throw e } }
	ensure_exists â† Î»(Î¹,ifdne){ existsSync(Î¹) || ( mkdir_p(path.resolve(path.dirname(Î¹))), fs.writeFileSync(Î¹,ifdne) ) }
	write_file â† Î»(Î¹,data){ try{ fs.writeFileSync(Î¹,data) }catch(e){ if (!(e.code==='ENOENT')) throw e; ensure_exists(Î¹,data) } }
	open â† Î»(Î¹,ifdne,f){
		ensure_exists(Î¹,ifdne); Lc â† new Î¦(Î¹).â€–
		fd â† fs.openSync(Î¹,'r+'); f({
			get L(){â†© Lc},
			read(i,L){t â† Buffer.allocUnsafe(L); fs.readSync(fd,t,0,L,i) === L || â€½ ;â†© t},
			write(Î¹,i){L â† fs.writeSync(fd,Î¹,i); Lc = max(Lc, L+i)},
			truncate(L){fs.ftruncateSync(fd,L); Lc = min(Lc,L)},
			indexOf_skipping(from,to,step,find,skip){flâ†@
				if (from<0) from += fl.L; if (to<0) to += fl.L; from = min(max(0, from ),fl.L-1); to = min(max(-1, to ),fl.L)
				if (!(step===-1 && from>to)) â€½('TODO')
				d â† fl.read(to+1,from-to)
				for(iâ†from;i>to;i+=step) {if (d[i-(to+1)]===find) â†© i; else if (chr(d[i-(to+1)]).match(skip)); else â†© âˆ…}
				},
			}); fs.closeSync(fd)}
	globmatch â† (glob,Î¹)=> Î¹.re`^â€¦${_(glob).map(Î¹=> Î¹==='*'? '.*' : re`${Î¹}`.source).join('')}$`
	[#Q Ï†.cwd #Q].def({get(){â†© new Î¦(process.cwd()) }, set(Î¹){ t â† Ï†(Î¹+'')._Î¹; mkdir_p(t); process.chdir(t) }})

	normHs â† Î»(Î¹){ if(_.isEqual( Î¹,['~'] )) â†© [process.env.HOME]; Tstr(Î¹[0]) && (Î¹[0] = Î¹[0].replace(/^~(?=\/)/,process.env.HOME)) ;â†© Î¹ }
	Î» Î¦(Î¹){@._Î¹ = Î¹}; Î¦.prototype = {
		Ï†,
		toString(){â†© @._Î¹ },
		toJSON(){â†© {type:'Ï†', Î¹:@._Î¹} },
		inspect(Ë£,opts){â†© opts.stylize('Ï†','special')+opts.stylize(util_inspect_autodepth(@._Î¹.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') },
		get nlink(){â†© fs.statSync(@._Î¹).nlink },
		get mtime(){â†© fs.statSync(@._Î¹).mtime },
		get birthtime(){â†© fs.statSync(@._Î¹).birthtime },
		get url(){â†© encodeURI('file:'+@.root('/')) }, # ! should this be part of root
		get is_dir(){â†© !!catch_Î¹(=> fs.statSync(@._Î¹).isDirectory()) },
		get name(){â†© path.basename(@._Î¹) },
		BAD_exists(){â†© existsSync(@._Î¹) },
		TMP_children(){â†© @._Î¹ |> (Î» Î›(Î¹){â†© Ï†(Î¹).is_dir? fs.readdirSync(Î¹).map(t=> Î¹+'/'+t).mapâ€¦(Î›) : [Î¹] }) },
		TMP_parents(){ r â† [@.root('/')]; while(r[-1].Ï†`..`+'' !== r[-1]+'') r.push(r[-1].Ï†`..`) ;â†© r.slice(1) },
		root(x){switch(arguments.length){default: â€½
			case 0: â†© @._Î¹[0]==='/'? '/' : '.'
			case 1: â†© new Î¦( x==='/'? path.resolve(@._Î¹) : x==='.'? path.relative(x,@._Î¹) : â€½('not yet implemented: nonstandard roots') )
			}},
		ensure_dir(){ @.Ï†`..`.BAD_exists() || mkdir_p(@.Ï†`..`+'') ;â†© @ },

		# get Î¹(){â†©},
		set Î¹(Î¹){
			if (@.is_dir) â€½('TODO')
			if (Î¹===âˆ…||Î¹===null){ catch_union(=> fs.unlinkSync(@._Î¹) ) ;â†© }
			e â† path.extname(@._Î¹)
			if (e==='.csv'){ @.csv = Î¹ ;â†© }
			if (e==='.xml'){ @.xml = Î¹ ;â†© }
			if (e==='.plist'){ @.plist = Î¹ ;â†© }
			Î¹ = e==='.json'? JSON_pretty(Î¹) :
				Tstr(Î¹)? Î¹ :
				Î¹ instanceof Buffer? Î¹ :
				JSON_pretty(Î¹)
			write_file(@._Î¹,Î¹) },
		get buf(){â†© read_file(@._Î¹) || Buffer.alloc(0) },
		set buf(Î¹){ write_file(@._Î¹,Î¹) },
		get base64(){â†© Buffer.from(@.text,'base64') },
		# set base64(Î¹){},
		get text(){â†© (read_file(@._Î¹) || '')+'' },
		set text(Î¹){ write_file(@._Î¹,Î¹) },
		get lines(){â†© Î»(â€¦Î¹s){
			d â† ((read_file(@._Î¹)||'\n')+'').replace(/\n$/,'').split('\n')
			if (Î¹s.â€– > 1) â†© Î¹s.map(Î¹=> Tnum(Î¹)? d[Î¹] : d.slice(Î¹.re`^(\d+):$`[1]|0).join('\n')+'\n')
			else if (Î¹s.â€– === 0){
				â†© {
					map(â€¦a){â†© d.map(â€¦a)},
					} }
			else â€½('TODO')
			}},
		set lines(Î¹){ write_file(@._Î¹, Î¹.join('\n')+'\n') },
		get json(){â†© JSON.parse(read_file(@._Î¹) || 'null') },
		set json(Î¹){ write_file(@._Î¹, JSON_pretty(Î¹)) },
		get json2(){â†© json2_read(@.text) },
		set json2(Î¹){ @.text = json2_show(Î¹) },
		get ini(){â†© npm`ini@1.3.4`.parse(@.text) },
		# set ini(Î¹){},
		# get csv(){â†©},
		set csv(Î¹){ t â† Ï†`/tmp/csv_${random_id(25)}`; t.json = Î¹; sháµ¥`Î¶ ${'npm`csv@0.4.6`.stringify('+js`Ï†(${t+''}).json,Î»(e,Î¹){ Ï†(${@.root('/')+''}).buf = Î¹ })`}` },
		# get xml(){â†© JSON.parse(sháµ¥`Î¶ ${js`npm`xml2js@0.4.17`.parseString(Ï†(${@+''}).text,Î»(e,Î¹){ process.stdout.write(JSON.stringify(Î¹)) })`}`+'') },
		set xml(Î¹){ @.text = npm`xmlbuilder@8.2.2`.create(Î¹,{allowSurrogateChars:âœ“}).end({pretty:âœ“}) },
		get plist(){tâ†; buf â† @.buf ;â†© 0?0
			# in case bplist-parser has bugs, this is available:
			# : which('plutil')? npm`plist@2.1.0`.parse(sháµ¥`plutil -convert xml1 -o - ${@.root('/')+''}`+'')
			: buf.slice(0,6)+''==='bplist'? ( t= Ï†`/tmp/plist_${random_id(25)}`, sháµ¥`Î¶ ${'npm`bplist-parser@0.1.1`.parseFile('+js`${@.root('/')+''},Î»(e,Î¹){ Ï†(${t+''}).plist = Î¹ })`}`, t.plist )
			: npm`plist@2.1.0`.parse(@.text)
			},
		set plist(Î¹){ @.text = npm`plist@2.1.0`.build(Î¹) },
		get json_array__synchronized(){â†© Î»(â€¦Î¹s){_Î¹â†@._Î¹
			if (Î¹s.â€–) â€½('TODO')
			d â† JSON.parse((read_file(_Î¹)||'[]')+'')
			â†© {
			push(â€¦a){a.map(Î»(Î¹){
				d.push(Î¹)
				open(_Î¹,'[]',Î»(fl){
					i â† fl.indexOf_skipping(-1,-1e4,-1,ord(']'),/[ \n\t]/) || â€½('bad file')
					is_0 â† fl.indexOf_skipping(i-1,-1e4,-1,ord('['),/[ \n\t]/)!==âˆ…
					fl.write((is_0?'':',')+JSON.stringify(Î¹,âˆ…,'  ')+']',i)
					})
				})},
			filter(f){â†© d.filter(f)},
			get length(){â†© d.â€–},
			get ['â€–'](){â†© d.â€–},
			} }},

		get size(){â†© fs.statSync(@._Î¹).size },
		get ['â€–'](){â†© fs.statSync(@._Î¹).size },
		}
	Î» Î¦s(Î¹){@._Î¹ = Î¹}; Î¦s.prototype = {
		inspect(Ë£,opts){â†© opts.stylize('Ï†','special')+util.inspect(@._Î¹,opts)},
		get name_TMP(){â†© @._Î¹.map(Î¹=> new Î¦(Î¹).name)}, # fs.readdirSync
		get Ï†s(){â†© @._Î¹.map(Î¹=> new Î¦(Î¹))}, # [Ï†]
		}
	Î» Ï†(ss,â€¦Î¹s){
		head â† @ instanceof Î¦ && @._Î¹
		if (@ instanceof Î¦s) â€½('not yet implemented')
		tmpl â† is_template([ss,â€¦Î¹s])
		if (tmpl){Î¹ â† simple_template(ss,Î¹s,[Ï†,'/']); if (Î¹.filter(Tstr).join('').re`\*|\{[^}]*?,`) {
			Î¹.â€– <= 1 || â€½('not yet implemented * ** ${}',Î¹)
			Î¹ = normHs(Î¹)
			Î¹ = Î¹[0]
			Î¹.includes('**') && â€½('not yet implemented ** ${}',Î¹)
			r â† ['.']
			if (Î¹[0]==='/') r = ['/']
			Î¹.split('/').forEach(Î»(Î¹){
				if (Î¹==='')â†©;
				r = r.mapâ€¦(r=>{
					if (Î¹ === '.') â†© [r]
					if (Î¹ === '..') â†© [r==='.'? '..' : r.split('/').every(Î¹=>Î¹==='..')? r+'/..' : path.dirname(r)]
					â†© fs.readdirSync(r).filter(b=> globmatch(Î¹,b)).map(b=> r+'/'+b)
					})
				})
			â†© new Î¦s(r) } }
		else {Î¹ â† ss; if (Î¹s.â€– || Tarr(Î¹)) â€½('not yet implemented'); if (Î¹ instanceof Î¦s) â€½('not yet implemented')}
		if (tmpl){Î¹ = normHs(Î¹).map(Î¹=> !Tstr(Î¹)? ENC(Î¹.raw+'') : Î¹).join('')}
		else if (Î¹ instanceof Î¦){â†© head && Î¹._Î¹[0]!=='/'? new Î¦(head+'/'+Î¹._Î¹) : Î¹}
		else {Î¹ = (Î¹+'').replace(/^~(?=\/|$)/,process.env.HOME)}
		â†© new Î¦(path.normalize(head? head+'/'+Î¹ : Î¹).replace(/(?!^)\/$/,'')) }
	â†© Ï† })

############################### personal concepts ##############################
sb._call = => sb.tab.active.Î¹
E.p = Î»(Î¹){ t â† clipboard ;â†© arguments.length===0? t.Î¹ :( t.Î¹ = Î¹ ) }

#################################### Î¶ infra ###################################
_(util.inspect.styles) <- ({null:'grey',quote:'bold'})
;[process,module].map(Î¹=> Î¹.inspect = Î»(){â†© '{'+Object.getOwnPropertyNames(@).map(Î¹=> Î¹+':').join(', ')+'}' }) # â€¡ hack, like the [1] * 5 thing in Î¶_repl_start. clean up by: can we override builtin inspects without problems? then: defining solid inspect functions for more things. otherwise: figure out something else.
;['global','Object'].map(Î¹=>{
global[Î¹].inspect = Î»(d,opt){â†© opt.stylize(Î¹,'quote') }
})
# Number_toFixed â† Î»(Î¸,Î¹){ Î¸ = round(Î¸ / 10**-Î¹) * 10**-Î¹ ;â†© Î¹>0? Î¸.toFixed(Î¹) : Î¸+'' }
# E.pretty_time_num = Î¹=> _(new Number(Î¹)) <- ({inspect:Î»(Ë£,opt){ P â† 20; Î¹â†@; [Î¹,u] â† (Î¹ >= P/1e3? [Î¹,'s'] : [Î¹*1e6,'Î¼s']) ;â†© opt.stylize(Number_toFixed(Î¹,-max(-3,floor(log10(Î¹/P))))+u,'number') }})
# E.pretty_time_num = Î¹=> Unit(Î¹,'s')
Unit â† (Î¹,u)=>{ ;r â† {Î¹,u} ;[#Q r.valueOf #Q].def({ value(){â†© @.Î¹ } }) ;[#Q r.inspect #Q].def({ value(Ë£,opt){â†© util.inspect(@.Î¹,opt)+opt.stylize(@.u,'number') } }) ;â†© r }
assign_properties_in_E_informal({
,'Number.prototype.inspect':Î»(d,opt){'use strict'; Î¹ â† @; if(! Tprim(Î¹) ) â†© Î¹ ;â†© opt.stylize( Object.is(Î¹,-0)? '-0' : Î¹===âˆ? 'âˆ' : Î¹===-âˆ? '-âˆ'
	: Number.isSafeInteger(Î¹)? ''+Î¹
	: Î¹.toExponential().replace('+','').replace(/(\.\d\d)\d+/,'$1').replace('e0','')
	,'number') }
,'Boolean.prototype.inspect':Î»(d,opt){'use strict' ;â†© opt.stylize( @?'âœ“':'âœ—','boolean' ) }
,'Date.prototype.inspect':Î»(d,opt){â†© opt.stylize(isNaN(+@)? 'Invalid Date' : @.getUTCSeconds()!==0? @.ymdhms : @.getUTCMinutes()!==0? @.ymdhm : @.getUTCHours()!==0? @.ymdh : @.ymd, 'date')}
# ,'Function.prototype.inspect':Î»(rec,ctx){t â† Î¶_compile.â»Â¹(@+'').replace(/^Î» \(/,'Î»(').match(/^.*?\)/) ;â†© ctx.stylize('['+(t?t[0]:'Î» ?(?)')+']', 'special')}
# ,'Buffer.prototype.inspect':Î» Î›(){â†© Î›.super.call(@).replace(/(^<\w+)/,'$1['+@.â€–+']')}
# ,inspect(Ë£,opt){â†© opt.stylize('Ï†','special')+opt.stylize(util.inspect(@._Î¹.replace(re`^${process.env.HOME}(?=/|$)`,'~')).replace(/^'|'$/g,'`'),'string') }
})
sb.encode = (=>{
	line â† Î¹â‡’
		: Tstr(Î¹)? Î¹
		# : util.inspect(Î¹,{ depth:âˆ…, maxArrayLength:âˆ…, })
		: util_inspect_autodepth(Î¹)
	â†© Î¹â‡’
		: Î¹===âˆ…? ''
		: Tarr(Î¹)? Î¹.map(line).join('\n')
		: line(Î¹) })()
# EventEmitter.prototype.inspect

E.cn = { log:(â€¦a)=> console.log(
	is_template(a)?
		easy_template(Î¹=>Î¹)(â€¦a).map(Î¹=> Tstr(Î¹)? Î¹ : util_inspect_autodepth(Î¹[0],{colors:âœ“})).join('') :
		a.map(Î¹=> Tstr(Î¹)? Î¹ : util_inspect_autodepth(Î¹,{colors:âœ“})).join(' ')
		) }
E.util_inspect_autodepth = Î»(Î¹,opt={}){ opt.L || (opt.L = 1e6); lastâ†; for(iâ†1;;i++){ r â† util.inspect(Î¹,_({maxArrayLength:opt.L/3 |0, depth:i}) <- (opt)); if (r===last || r.â€– > opt.L) â†© last===âˆ…? '<too large>' : last; last = r } }

E.â€¡_repl_start = => Î¶_repl_start({
	# i know how to make the good repl for ct. i want to, but im tired
	prompt:'\x1b[30m\x1b[100mâ€¡\x1b[0m ',
	compile:Î¹=>{tâ†;
		lock â† 0?0
			: ['ct','chrome_tabs','ps2','d','bookmarks'].âˆª([]).has(Î¹)? 'require_new(Ï†`~/.bashrc.Î¶`).'+Î¹+'()'
			: (t= Î¹.re`^f(?: (.+))?$` )? js`go_to('path',${t[1]||'.'})`
			: Î¹
		lock===Î¹ || cn.log('â›“  '+lock)
		â†© Î¶_compile(lock) }, })
ğ…©ğ…ğ…‹ğ…¦ğ…©â†;
E.Î¶_repl_start = opt=>{ opt = _({compile:Î¶_compile, prompt:'\x1b[30m\x1b[42mÎ¶\x1b[0m '}) <- (opt)
	my_eval â† code=>{ # ! can be refactored further
		t â† opt.compile(code)
		try{ t = new vm.Script(t,{ filename:'repl', displayErrors:âœ— }) }
		catch(e){ if( e.name==='SyntaxError' ) â†© {parse_error:e}; e.stack = e.name+': '+e.message+'\n    at <repl>' ;â†© {error:e} }
		try{ â†© {v:t.runInThisContext()} }
		catch(e){ e && Tstr(e.stack) &&( e.stack = e.stack.replace(/^([^]*)at repl:(.*)[^]*?$/,'$1at <repl:$2>') ) ;â†© {error:e} }
		}
	q â† (Î¹,opt={})=> util_inspect_autodepth(Î¹,_(opt).pick('colors'))
	promise_watch â† Î¹=>{ if(! Î¹.id ){
		Î¹.id = b36(fromUInt32BE([#Q (ğ…©ğ…ğ…‹ğ…¦ğ…©||(ğ…©ğ…ğ…‹ğ…¦ğ…©= [0] )).0 #Q].Î¹++))
		hr â† hrtime(); Î¹.then(x=>{ x â† my_inspect(x); hrtime(hr) < 5 && x.â€– && hsáµ¥`hs.alert(${`Promise #${Î¹.id} = ${x.slice(0,200)}`},12)` }) } }
	my_inspect â† (Î¹,opt={})â‡’
		: Î¹===âˆ…? ''
		: T.Promise(Î¹)? 0?0
			: Î¹.status? 'Î  '+q(Î¹.Î¹,opt)
			: Î¹.status===âˆ…?( promise_watch(Î¹), `Î  #${Î¹.id} { <pending> }` )
			: q(Î¹,opt)
		: Tarr(Î¹) && Î¹.â€– > 1 && Î¹.every(t=> t===Î¹[0]) && _.range(Î¹.â€–).every(t=> t in Î¹)
			? q([Î¹[0]],opt)+' Ã— '+q(Î¹.â€–,opt)
		: q(Î¹,opt)
	â†© (f=> f.call( require('repl').start(_({useGlobal:âœ“}) <- (_(opt).pick('prompt'))) ))(Î»(){
	@.In = []; @.Out = []
	super_ â† @.completer; @.completer = Î»(line,cb){ line.trim()===''? cb(âˆ…,[]) : super_.call(@,line,cb) }
	@.removeAllListeners('line').on('line',Î»(line){
		@.context.rl = @
		@.context.E = @.context
		if( @.bufferedCommand ){ Î¹ â† @.history; Î¹.reverse(); t â† Î¹.pop(); Î¹[-1] += '\n'+t; Î¹.reverse() }
		code â† @.bufferedCommand+line
		{parse_error,error,v} â† my_eval(code)
		if( parse_error ){ @.bufferedCommand = code+'\n'; @.outputStream.write('    ') ;â†© }
		@.bufferedCommand = ''
		if( code ){
			Ï†`~/.archive_Î¶`.text = Ï†`~/.archive_Î¶`.text + JSON.stringify({time:Time(), code}) + '\n'
			@.In.push(code); @.Out.push(error || v)
			}
		if( error ) @._domain.emit('error', error.err || error)
		else{
			if( T.Promise(v) ) [#Q @.context.__ #Q].def({get(){â†© v.status? @.__ = v.Î¹ : v }, writable:âœ“})
			else if( v!==âˆ… ) @.context.__ = v
			try{ t â† my_inspect(v,{colors:@.useColors}) }catch(e){ t â† '<repl inspect failed>:\n'+(e&&e.stack) }
			@.outputStream.write(t && t+'\n') }
		@.displayPrompt()
		})
	@.removeAllListeners('SIGINT').on('SIGINT',Î»(){
		is_line â† @.bufferedCommand+@.line
		@.clearLine()
		if( is_line ){ @.bufferedCommand = ''; @.displayPrompt() } else @.close()
		})
	delete @.context._; @.context._ = _
	â†© @
	}) }

##################################### main #####################################
sh_ify â† Î¹=>{tâ†; â†© Î ( 0?0
	: T.Promise(Î¹)? Î¹.then(sh_ify.X)
	: Î¹===âˆ…? {}
	: Tstr(Î¹)? {out:Î¹}
	: T.boolean(Î¹)? {code:Î¹?0:1}
	: (t=catch_union(=> JSON.stringify(Î¹)), !T.Error(t))? {out:t}
	: {out:Î¹+''} )}
eval_ â† Î» __53gt7j(Î¹){
	try{
		try{ new vm.Script(Î¹) ;â†© (0,eval)(Î¹) }catch(e){ if(!( e.name==='SyntaxError' && e.message==='Illegal return statement' )) throw e ;â†© (0,eval)('(()=>{'+Î¹+'})()') }
	}catch(e){ e!==âˆ… && e!==null && Tstr(e.stack) && (e.stack = e.stack.replace(/    at __53gt7j[^]*/,'    at <eval>')); throw e }
	}
E.Î¶_main = ({a})=>{Î¹â†;
	a[0]==='--fresh' && a.shift()
	if( !a.â€– ) Î¶_repl_start()
	else if( Î¹=a[0], Ï†(Î¹).BAD_exists() || Î¹.re`^\.?/` ){ process.argv = [process.argv[0],â€¦a]; t â† Ï†(Î¹).root('/')+''; oâ†Module._cache;mâ†Module._resolveFilename(t,âˆ…,âœ“);oÎ¹â†o[m]; o[m] = âˆ…; Module._load(t,âˆ…,âœ“); o[m] = oÎ¹ }
	else {
		global.require = require; global.code = a.shift(); global.a = a; [global.a0,global.a1] = a; global.Î¹ = a[0]
		code = code.replace(/;\s*$/,'; âˆ…')
		sh_ify(eval_(Î¶_compile(code)))
			.then(Î¹=>{ Î¹.out && process.stdout.write(Î¹.out); Î¹.code &&( process.exitCode = Î¹.code ) })
		}
	}
if_main_do((â€¦a)=>Î¶_main({a}))
# inject as .bashrc
# 	sh` Î¶(){ if [[ $# = 0 || $1 =~ ^\.?/ || $1 = --fresh ]]; then /usr/local/bin/Î¶ "$@"; else Î¶Î» "$@"; fi; } `

############################# remaining work for Ï† #############################
# https://www.npmjs.com/package/glob-to-regexp
/*
formats include
	image               
	pixels              
	png                 .png
	jpg                 .jpg
	plist               /^<\?xml / && /<\/plist>\s*$/           read: npm::plist.parse(it)     show: npm::plist.build(it)
	xml                 .xml || /^<\?xml /
	base64              .64
	pixels (grey)       
	stdin               fd:0
	FIFO                fd:0...
	:executable         ,/^#!/ | try{fs.accessSync(Î¹,fs.X_OK) ;â†© âœ“} catch(e){â†© âœ—}
	directory relative
	directory absolute
formats are Really stream formats
the formats are complicated to interact with, because
* GET POST PUT have really tangly apis for all sorts of efficiency concerns
* DELETE especially, we want to make some distinctions to make sure we donâ€™t fuck things up accidentally (although trash could help)

# paths can have extensions, which are often meaningful. (basename/filename, ext/suffix. path.basename,dirname,extname)

# we need to be careful with non-atomic transactions
# we need to think about how this interacts with concurrency
# we need to think about how this interacts with distributed machines (e.g. mixing file and http URLs)
# 	â€œlike, it should be caching urls all the time.â€

######################## things i need ** globbing to do #######################
scratch/scratch.txt:107:Ï†`**`.map(Î¹=> [Î¹+'',Î¹.get()])._.groupBy(1)._.values().map(Î¹=> Î¹._.map(0)).filter(Î¹=> Î¹.â€– > 1)
scratch/sublime/index.Î¶:60:	Ï†(arg.in).Ï†`**`.filter(Î¹=> !Î¹.dir()).map(Î»(Î¹){Î¹+=''; tâ†; Î¹ = Î¹.slice(arg.in.â€–).replace(/^\//,'')
scratch/sublime/index.Î¶:66:	out â† Ï†(arg.out).Ï†`**`.filter(Î»(Î¹){Î¹+='' ;â†© roots.some(Î»(r){â†© Î¹.indexOf(r) === 0})}).filter(Î¹=> !Î¹.dir()).map(Î¹=> Î¹+'')
*/

# i'd like that to be #!/usr/bin/env node --max_old_space_size=10000 
