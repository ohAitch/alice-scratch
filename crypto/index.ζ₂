#!/usr/bin/env ζ₂

crypto ← require('crypto')

Buffer.prototype.toArray = λ(){↩ Array.prototype.slice.call(@)}
Buffer.prototype.bits = λ(){↩ @.toArray().ζ2_mapcat(λ(v){↩ [(v&0x01)>>0,(v&0x02)>>1,(v&0x04)>>2,(v&0x08)>>3,(v&0x10)>>4,(v&0x20)>>5,(v&0x40)>>6,(v&0x80)>>7]})}
Buffer.prototype.partition = λ(len){r←[]; for(i←0;i<@.length;i+=len) r.push(@.slice(i,i+len)); ↩ r}
Buffer.prototype.str = λ(){↩ @.toString('binary')}
String.prototype.buf = λ(){↩ Buffer(@+'','binary')}
Array.prototype.windows = λ(len){r←[]; for(i←0;i<=@.length-len;i++) r.push(@.slice(i,i+len)); ↩ r}
Array.prototype.transpose = λ(){↩ _.zip.apply(_,@)}

hex ← {}
hex.read = λ(str){↩ Buffer(str.match(/../g).map(λ(v){↩ parseInt(v,16)}))}
hex.show = λ(buf){↩ buf.toString('hex')}

base64 ← {}
base64.read = λ(str){↩ Buffer(str,'base64')}
base64.show = λ(buf){↩ buf.toString('base64')}

xor ← λ(a,b){
	ia ← Buffer.isBuffer(a); ib ← Buffer.isBuffer(b)
	if (!ia && !ib) ↩ a ^ b
	if (!ia && ib) {t ← a; a = b; b = t}
	if (ib && b.length > a.length) {t ← a; a = b; b = t}
	r ← Buffer(a.length)
	if (!ib) for (i←0;i<r.length;i++) r[i] = a[i] ^ b
	else     for (i←0;i<r.length;i++) r[i] = a[i] ^ b[i % b.length]
	↩ r}

add ← λ(a,b){↩ a + b}
rand ← λ(a,b){↩ a==null? Math.random() : Array.isArray(a)? _.sample(a) : _.random(a,b)}

p_english ← (λ(){
	// oops, this doesn't actually sum to 1.
	small ← -15.424948
	t ← [,,,,,,,,,-4.60517,-4.60517,,,,,,,,,,,,,,,,,,,,,,-1.755724,-9.538844,-6.008407,-8.622554,-7.478685,-8.734106,-8.39056,-6.006375,-6.122941,-6.097714,-7.366621,-8.440232,-4.90196,-4.281349,-4.185013,-6.463711,-5.193597,-5.376495,-5.700587,-6.287716,-6.602479,-6.393137,-6.759335,-6.871423,-6.848543,-6.877226,-5.430022,-6.707266,-6.698305,-8.381789,-6.684612,-6.513014,-9.525051,-5.759401,-6.129807,-5.538607,-5.753393,-5.918214,-6.553583,-6.271708,-6.059315,-5.734654,-6.355596,-7.275925,-6.268009,-5.640244,-6.166771,-6.29041,-5.940391,-8.053459,-5.977562,-5.514237,-5.700587,-7.107426,-7.01534,-5.974411,-7.971966,-8.091925,-9.484777,-9.349602,-11.042922,-9.326874,-12.716898,-6.753319,-11.618286,-2.952309,-4.579405,-3.850599,-3.679563,-2.449578,-4.282,-4.154158,-3.589106,-3.00904,-7.043575,-4.991274,-3.443364,-4.101732,-2.995232,-2.845985,-4.161575,-7.194105,-3.149723,-3.124225,-2.747061,-3.856777,-4.765691,-4.333694,-6.233281,-4.473791,-7.418581,-10.557414,-11.8696,-10.557414,-12.716898]
	for (i←0;i<0x80;i++) t[i] || (t[i] = small)
	english_frequency ← λ(v){↩ v < 0x80? t[v] : small}
	↩ λ(buf){↩ buf.toArray().map(english_frequency).reduce(add)} })()

hamming ← λ(a,b){↩ _.zip(a.bits(),b.bits()).filter(λ(v){↩ v[0] !== v[1]}).length}

solve_single_byte_xor ← λ(buf){↩ _.range(0x100).map(λ(key){↩ {key:key, out:xor(buf,key)}})._.max(λ(v){↩ p_english(v.out)})}

// aaa padding
bad_encrypt_ecb ← λ(buf,key){t ← crypto.createCipheriv('aes-128-ecb',key,''); buf.length % key.length === 0 && t.setAutoPadding(false); ↩ Buffer.concat([t.update(buf), t.final()])}
bad_decrypt_ecb ← λ(buf,key){
	// doesn't remove padding !
	t ← crypto.createDecipheriv('aes-128-ecb',key,''); t.setAutoPadding(false); ↩ Buffer.concat([t.update(buf), t.final()])}
bad_encrypt_cbc ← λ(buf,key,iv){
	t ← buf.length % key.length; t > 0 && (buf = PKCS_7(buf, buf.length-t+key.length))
	↩ Buffer.concat(buf.partition(key.length).reduce(λ(r,v){r.push(bad_encrypt_ecb(xor(r[-1],v),key)); ↩ r},[iv]).slice(1)) }
bad_decrypt_cbc ← λ(buf,key,iv){
	// doesn't remove padding !
	↩ Buffer.concat([iv].concat(buf.partition(key.length)).windows(2).map(λ(v){↩ xor(bad_decrypt_ecb(v[1],key),v[0])})) }

bad_keygen ← λ(len){↩ Buffer(_.range(len).map(rand.P(0,0xff)))}

PKCS_7 ← λ(buf,len){len -= buf.length; len < 0 && (len = 0); len <= 0xff || err('‽'); ↩ Buffer.concat([buf, Buffer(len).fill(len)])}
PKCS_7.show = λ(buf,bsize){↩ PKCS_7(buf, ceil((buf.length+1)/bsize)*bsize)}
// PKCS_7.read = λ(buf,bsize){buf.length % bsize === 0 || err('invalid buffer alignment')
PKCS_7.read = λ(buf){
	buf[-1] > 0 || err('invalid padding')
	buf.slice(-buf[-1]).toArray().every(λ(v){↩ v === buf[-1]}) || err('invalid padding')
	↩ buf.slice(0,-buf[-1]) }

detect_ecb ← λ(buf,bsize){t ← buf.partition(bsize); ↩ t.some(λ(a,i){↩ t.slice(i+1).some(λ(b){↩ a.equals(b)})}) }
detect_ecb_cbc ← λ(oracle,bsize){↩ detect_ecb(oracle(Buffer(bsize*4).fill(0)),bsize) }

find_bsize ← λ(oracle){a ← oracle(Buffer(0).fill(0)).length; for (i←1;;i++) {t ← oracle(Buffer(i).fill(0)).length - a; if (t > 0) ↩ t} }
find_prefix_len__ecb_cbc ← λ(oracle,bsize) {
	t ← _.range(0,bsize+2).map(λ(v){↩ oracle(Buffer(v).fill(0)).partition(bsize)}).windows(2).map(λ(v,i){
		↩ _.zip(v[0],v[1])._.findIndex(λ(v){↩ !v[0].equals(v[1])})
	}).windows(2).map(λ(v,i){if (v[0] !== v[1]) ↩ [i+1,v[1]]}).filter(λ(v){↩ v})[0]
	↩ t[1]*bsize - t[0] }

decode_ecb_postfix__prefix_safe ← λ(oracle){
	bsize ← find_bsize(oracle)
	detect_ecb_cbc(oracle,bsize) || err('‽')
	prefix_len ← find_prefix_len__ecb_cbc(oracle,bsize); prefix_len_ceil ← ceil(prefix_len/bsize)*bsize
	extra ← Buffer(prefix_len_ceil-prefix_len).fill(0)
	got ← Buffer(0)
	done: for(block←0;;block++){
		for(i←bsize-1;i>=0;i--){
			q ← Buffer(i).fill(0)
			t ← oracle(Buffer.concat([extra,q])).slice(prefix_len_ceil).slice(bsize*block).slice(0,bsize)
			got = Buffer.concat([got,Buffer(1)])
			out: for(;;){
				for(j←0;j<0x100;j++){got[-1] = j; if (oracle(Buffer.concat([extra,q,got])).slice(prefix_len_ceil).slice(bsize*block).slice(0,bsize).equals(t)) break out}
				got = got.slice(0,-1); break done}
			} }
	↩ got}

print('--- begin ---')

// http://cryptopals.com/sets/2/challenges/16

key ← bad_keygen(16); iv ← bad_keygen(16) // private
encrypt_thing ← λ(v){
	t ← "comment1=cooking%20MCs;wat;userdata="+v.str().replace(/[;=]/g,'').buf()+";comment2=%20like%20a%20pound%20of%20bacon"
	// t ← "comment1=cooking%20MCs;userdata="+v.str().replace(/[;=]/g,'').buf()+";comment2=%20like%20a%20pound%20of%20bacon"
	↩ bad_encrypt_cbc(PKCS_7.show(t.buf(),16), key, iv)}
is_thing_admin ← λ(buf){↩ PKCS_7.read(bad_decrypt_cbc(buf, key, iv)).split(';')._.contains('admin=true')}

// goal: find input to is_thing_admin that returns true. no ability to crack the key.

// You`re relying on the fact that in CBC mode, a 1-bit error in a ciphertext block:
// * Completely scrambles the block the error occurs in
// * Produces the identical 1-bit error/edit in the next ciphertext block.

// Stop and think for a second.
// Before you implement this attack, answer this question: why does CBC mode have this property?

// https://en.wikipedia.org/wiki/File:CBC_encryption.svg https://en.wikipedia.org/wiki/File:CBC_decryption.svg

an_edit_cbc_hack ← λ(oracle){
	bsize ← find_bsize(oracle)
	!detect_ecb_cbc(oracle,bsize) || err('‽')
	prefix_len ← find_prefix_len__ecb_cbc(oracle,bsize); prefix_len_ceil ← ceil(prefix_len/bsize)*bsize
	
}

// 13
// profile_for ← λ(v){↩ k_v.show({email:v.replace(/[=&]/g,''), uid:10, role:'user'})}
// encrypt_profile ← λ λ(v){λ.key || (λ.key = bad_keygen(16)); ↩ bad_encrypt_ecb(Buffer(profile_for(v)), λ.key)}
// decrypt_profile ← λ(v){↩ k_v.read(PKCS_7.read(bad_decrypt_ecb(v, encrypt_profile.key))+'')}
//
// cipher ← encrypt_profile('xxxxxxxxxx'+PKCS_7('admin'.buf(),16).str()).slice(16,32)
// t ← encrypt_profile('haxxxxxxxxxx0351528'+'@gmail.com'); cipher.copy(t,48)
// print(decrypt_profile(t))

print(an_edit_cbc_hack(encrypt_thing)+'')

// ---------------------------------- past ---------------------------------- //

// print(q.map(hex.read).ζ2_mapcat(λ(v){↩ _.range(0x100).map(xor.P(v))})._.max(p_english)+'')

// print(_.range(0x100).map(λ(i){↩ xor(hex.read('1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'),i)})._.max(p_english)+'')

// print(q.map(hex.read).ζ2_mapcat(λ(v){↩ _.range(0x100).map(xor.P(v))})._.max(p_english)+'')
// print(q.map(hex.read).map(solve_single_byte_xor)._.max(p_english)+'') eesh, duplicate work

// print(
// 	xor(Buffer("Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal"), Buffer("ICE"))
// 	.equals(
// 	hex.read("0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f")
// 	))

// print(hamming(Buffer('this is a test'),Buffer('wokka wokka!!!')),'= 37')
// buf ← base64.read(f6)
// keysizes ← _.range(1,41)._.sortBy(λ(keysize){
// 	t ← _.range(5).map(λ(i){↩ buf.slice(keysize*i).slice(0,keysize)}).windows(2)
// 	↩ t.map(λ(v){↩ hamming(v[0],v[1])}).reduce(add) / t.length / keysize
// 	}).slice(0,5)
// t ← keysizes.map(λ(keysize){
// 	t ← buf.partition(keysize).map(λ(v){↩ v.toArray()}).transpose().map(λ(v){↩ solve_single_byte_xor(Buffer(v))})
// 	↩ {
// 		key: Buffer(t.map(λ(v){↩ v.key})),
// 		out: Buffer(t.map(λ(v){↩ v.out.toArray()}).transpose().ζ2_mapcat(λ(v){↩ v}))
// 		} })._.max(λ(v){↩ p_english(v.out)})
// print(t.out+'')
// print('--------------------------')
// print('key:',hex.show(t.key))

// print([PKCS_7(Buffer("YELLOW SUBMARINE"),20).str()])

// f10 ← base64.read(fs('data/10.txt').$)
// key ← "YELLOW SUBMARINE"
// iv ← Buffer(key.length).fill(0)
// print(bad_decrypt_cbc(bad_encrypt_cbc(bad_decrypt_cbc(f10,key,iv),key,iv),key,iv)+'')

// tea ← Buffer(fs('data/tea.txt').$)
// ls ← tea.partition(500).map(encryption_oracle)

// encryption_oracle ← λ(buf){ // 11
// 	buf = Buffer.concat([bad_keygen(rand(5,10)),buf,bad_keygen(rand(5,10))])
// 	key ← bad_keygen(16)
// 	↩ (rand() > 0.5? bad_encrypt_ecb : bad_encrypt_cbc)(buf,key,bad_keygen(16)) }

// secret ← base64.read('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')
// encryption_oracle ← λ λ(buf){λ.key || (λ.key = bad_keygen(16))
// 	↩ bad_encrypt_ecb(Buffer.concat([buf,secret]),λ.key) }
// print(decode_ecb_postfix__prefix_safe(encryption_oracle)+'') // 12

// k_v ← {} // 13
// k_v.read = λ(v){↩ v.split('&').map(λ(v){↩ v.split('=')})._.object()}
// k_v.show = λ(v){↩ _.pairs(v).map(λ(v){↩ v[0]+'='+v[1]}).join('&')}
// 13
// profile_for ← λ(v){↩ k_v.show({email:v.replace(/[=&]/g,''), uid:10, role:'user'})}
// encrypt_profile ← λ λ(v){λ.key || (λ.key = bad_keygen(16)); ↩ bad_encrypt_ecb(Buffer(profile_for(v)), λ.key)}
// decrypt_profile ← λ(v){↩ k_v.read(PKCS_7.read(bad_decrypt_ecb(v, encrypt_profile.key))+'')}
//
// cipher ← encrypt_profile('xxxxxxxxxx'+PKCS_7('admin'.buf(),16).str()).slice(16,32)
// t ← encrypt_profile('haxxxxxxxxxx0351528'+'@gmail.com'); cipher.copy(t,48)
// print(decrypt_profile(t))

// 14
// encryption_oracle ← (λ(){
// 	key ← bad_keygen(16)
// 	prefix ← bad_keygen(rand(10,60))
// 	secret ← base64.read('Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')
// 	↩ λ(buf){↩ bad_encrypt_ecb(Buffer.concat([prefix,buf,secret]),key)}
// 	})()
// print(decode_ecb_postfix__prefix_safe(encryption_oracle)+'')
