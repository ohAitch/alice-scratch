#!/usr/bin/env Î¶
APP â† '\x1b[34m[keyrc]\x1b[0m'
KB â† '/Applications/Karabiner.app/Contents/Library/bin/karabiner'

################################################################################
char16hex â† Î¹=> ('000'+ord(Î¹).toString(16)).slice(-4)
take_while â† Î»(l,f){ iâ†0; for(Î¹â† of l) if (f(Î¹)) i++; else break; â†© Î¹.slice(0,i) }
drop_while â† Î»(l,f){ iâ†0; for(Î¹â† of l) if (f(Î¹)) i++; else break; â†© Î¹.slice(i) }
split_with â† Î»(l,f){ iâ†0; for(Î¹â† of l) if (f(Î¹)) i++; else break; â†© [l.slice(0,i), l.slice(i)] }

_alert â† (a,b,c)=> osaâ‚`system events: display alert ${a} â€¦${b && osa`message ${b}`} â€¦${c && osa`giving up after ${c}`}` # ! design better, then rename to alert

multiline â† Î¹=> lines(Î¹+'').map(.replace(/^\t*/,'')).join('\n')

################################################################################
M â† Î»(a,b,c){ r â† {trigger:a, output:b}; c && (r.if = c); â†© r }
M2 â† Î»(a,b,c){ r â† {name:a, identifier:a, autogen:b}; c && (r.only = c); â†© r }
transpose_str â† Î¹=> _.zip(â€¦Î¹.split('\n').map(Î¹=>[â€¦Î¹])).map(.join('')).join('\n')

macros â† {}
parse_boards0 â† Î¹=>
	transpose_str(Î¹).split(/\n(?: +\n)+/u).map(transpose_str).map(Î»(Î¹){Î¹ = Î¹.split('\n'); â†© {
		root: (Î¹[0].match(/^â”Œâ”€+ (\S+) â”€+â”$/u)||[âˆ…,''])[1],
		keys: Î¹.slice(1,-1).map(Î¹=> /^â”‚(.+)â”‚$/u.exec(Î¹)[1]).map(Î¹=> /\S\S?/gu.exec(Î¹)),
		} })
builtin_keys â† parse_boards0(multiline`
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ [homoiconic] â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚ â‹ F1F2F3F4F5F6F7F8F9FaFbFc â» â”‚
	â”‚ \` 1 2 3 4 5 6 7 8 9 0 - = âŒ«  â”‚
	â”‚  â‡¥ q w e r t y u i o p [ ] \\ â”‚
	â”‚  â‡ª a s d f g h j k l ; '  â†©  â”‚
	â”‚  â‡§L z x c v b n m , . /  â‡§R  â”‚
	â”‚ Fn^ âŒ¥LâŒ˜L    â£    âŒ˜RâŒ¥Râ† â†‘ â†“ â†’ â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
	`)[0].keys.â€¦
parse_boards â† Î»(Î¹){
	Î¹ â† Î¹.mapâ€¦(parse_boards0)
	Î¹.filter(.keys.â€– === 4).forEach(Î»(Î¹){Î¹.keys = [['_'].Ã—(14), â€¦Î¹.keys, ['_'].Ã—(11)]})
	Î¹.forEach(Î»(Î¹){ Î¹.keys = Î¹.keys.â€¦ })
	Î¹.forEach(Î»(Î¹){ Î¹.keys = Î¹.keys.map(Î¹=> Object.hasOwnProperty(macros,Î¹)? macros[Î¹] : Î¹) })
	Î¹.forEach(Î»(Î¹){ Î¹.keys = _.zip(builtin_keys,Î¹.keys).filter(Î¹=> Î¹[1] !== '_') })
	Î¹ = Î¹.mapâ€¦(Î»(Î¹){ Î¹.keys.forEach(k=> k[0] = Î¹.root+k[0]); â†© Î¹.keys })
	â†© Î¹.map(Î¹=> M(â€¦Î¹)) }
keycodes â† parse_boards([multiline`
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚ 357A78637660616264656D676F00 â”‚
	â”‚ 321213141517161A1C191D1B1833 â”‚
	â”‚ 300C0D0E0F111020221F23211E2A â”‚
	â”‚  6E000102030504262825292724  â”‚
	â”‚  38 060708090B2D2E2B2F2C 3C  â”‚
	â”‚ 3F3B3A37   31   363D7B7E7D7C â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
	`]).map(Î¹=> [Î¹.trigger,Î¹.output])._.object()
	â€¦â† ({FnF1:'03Â°',FnF2:'02Â°',FnF3:'a0',FnF4:'83',FnF5:'16Â°',FnF6:'15Â°',FnF7:'14Â°',FnF8:'10Â°',FnF9:'13Â°',FnFa:'07Â°',FnFb:'01Â°',FnFc:'00Â°'})
system â† parse_boards([multiline`
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â‡§ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚ \` 1 2 3 4 5 6 7 8 9 0 - = _  â”‚ â”‚ ~ ! @ # $ % ^ & * ( ) __+ _  â”‚
	â”‚  _ q w e r t y u i o p [ ] \\ â”‚ â”‚  _ Q W E R T Y U I O P { } | â”‚
	â”‚  _ a s d f g h j k l ; '  _  â”‚ â”‚  _ A S D F G H J K L : "  _  â”‚
	â”‚  _  z x c v b n m , . /  _   â”‚ â”‚  _  Z X C V B N M < > ?  _   â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
	`])
text_keys â† [â€¦system.map(.trigger).filter(..0!=='â‡§'), ' ']
macros['X'] = "; say`âš™`"

parse_key_line â† Î¹=>{ t â† Î¹.match(/^\s*(@\w+)?\s*(\S+)\s+([^]*\S)/); â†© M(t[2],t[3],t[1]) }
parse_keyrc â† Î»(src){
	tâ‚ â† []; tâ‚‘ â† parse_boards(
		(src+'\n').replace(/\n{2,}/g,'\n')
		.replace(/(?:^|\n)#.*/g,'')
		.replace(/(?:^|\n)(?![â”‚â”Œâ””])(.+)/g,(Ë£,Î¹)=>{ tâ‚.push(parse_key_line(Î¹)); â†© ''})
		.match(/(â”Œ.+â”)\n((?:â”‚.+â”‚\n)+)(â””.+â”˜)\n/g).map(.replace(/\n$/,'') )
		)
	â†© [â€¦tâ‚, â€¦tâ‚‘].-eq(system) }
show_private_xml â† Î»(mappings){tâ†;
	Mod â† Î¹â‡’ {'â‡§':'VK_SHIFT', '^':'ModifierFlag::CONTROL_L', 'âŒ¥':'VK_OPTION', 'âŒ˜':'VK_COMMAND', 'â‡§L':'ModifierFlag::SHIFT_L', 'âŒ¥L':'ModifierFlag::OPTION_L', 'âŒ˜L':'ModifierFlag::COMMAND_L', 'â‡§R':'ModifierFlag::SHIFT_R', 'âŒ¥R':'ModifierFlag::OPTION_R', 'âŒ˜R':'ModifierFlag::COMMAND_R', 'Fn':'ModifierFlag::FN', ' ':'ModifierFlag::NONE'}[Î¹]
	shells â† {}; shell â† Î¹=> shells[Î¹] || (shells[Î¹] = 'KeyCode::VK_OPEN_URL_'+_(shells).size())
	appdef â† Î¹=> appdefs[Î¹] = Î¹ |> (@device_memo(Î¹=> catch_Î¹(=> osaáµ¥`id of app ${Î¹}`) )); appdefs â† {}
	compile_mapping â† Î»(Î¹){
		Key â† Î¹=> ('KeyCode::'+(/^\d$/.exec(Î¹)? 'KEY_'+Î¹ : /^[a-z]$/.exec(Î¹)? Î¹.toUpperCase() : keycodes[Î¹]? 'RawValue::0x'+keycodes[Î¹] : â€½('invalid key: '+Î¹))).replace(/^(.+)Â°$/,'Consumer$1')
		compile_keystring â† Î¹=>{
			[md,ky] â† split_with(/FnF.|F.|.[LR]|./g.exec(Î¹), Mod)
			if (md.â€– === 1 && ky.â€– === 0){ ky = [md[0]]; md = [] }else{ md.push(' ') }
			if (!{1:1,2:1}[ky.â€–]) â€½(APP+' invalid keystring: '+node.util.inspect(Î¹))
			â†© {cmd: {1:'__KeyToKey__', 2:'__SimultaneousKeyPresses__'}[ky.â€–], Î¹: ky.map(Key).join(',')+','+md.map(Mod).join('|')+','} }
		compile_trigger â† Î¹=>{ t â† compile_keystring(Î¹); â†© t.cmd+' '+t.Î¹ }
		compile_output â† Î¹=>{tâ†; â†©0,
			(t=/^\] ([^]*)$/.exec(Î¹))? compile_keystring(t[1]).Î¹ :
			# (t=/^; ([^]+)$/.exec(Î¹))? shell(sh`PATH="/usr/local/bin:$PATH"; (Î¶Î» ${t[1]} &)`) :
			(t=/^; ([^]+)$/.exec(Î¹))? shell(sh`PATH="/usr/local/bin:$PATH"; (Î¶Î» ${Î¶_compile(t[1])} &)`) :
				_(Î¹).map(Î¹=> _(char16hex(Î¹)).map(Î¹=> compile_keystring('âŒ¥L'+Î¹).Î¹))._.flatten().join('') }
		compile_appdef â† Î¹=>( Î¹ = Î¹.toLowerCase().re`^@(.+)$`[1].replace(/_/g,' '), appdef(Î¹)? Î¹ : (_alert('[keyrc] warning','app '+node.util.inspect(Î¹)+' not found'),âˆ…) )
		if (Î¹.if){ if_ â† compile_appdef(Î¹.if); if (!if_) â†© âˆ… }
		â†© {Î¹:compile_trigger(Î¹.trigger) + compile_output(Î¹.output), if:if_} }
	[onces,mappings] â† mappings._.partition(Î¹=> /^notsave\.KEY_once_/.test(Î¹.if) )
	compile_key_line â† Î¹=> compile_mapping(parse_key_line(Î¹)).Î¹
	â†© {root: {
		item:[
			M2( 'notsave.2touch', [
				# â€¦['iBooks|preview','Chrome','sublime tExt','path Finder','Github desktop','Terminal','Vlc'].map(Î¹=>`
				â€¦['iBooks|preview','Chrome','sublime tExt','path Finder','Github desktop','Terminal','Vlc','Discord','Spotify'].map(Î¹=>`
				${Î¹.re`[A-Z]`[0].toLowerCase()} ; `+js`${Î¹.toLowerCase().split(/\|/g)}.map(Î¹=> go_to('app',Î¹))` ),
				â€¦[1,2,3,4,5].map(Î¹=>`
				${Î¹} ] ^${Î¹} `),
				# â˜â˜ should be like @notsave.2touch and then you can say â˜â˜${Î¹}
				].map(compile_key_line) ),
			M2( t='notsave.power_key', builtin_keys.-(text_keys).map(Î¹=> `${/^F[^n]$/.exec(Î¹)? 'Fn'+Î¹ : Î¹} ${/^[âŒ¥â‡§âŒ˜][RL]$/.exec(Î¹)? Î¹[0] : Î¹}` ).map(compile_key_line).map(Î¹=> Î¹+','+shell(sh`${KB} disable ${t}`)) ),
			â€¦onces.map(Î¹=>M2( Î¹.if, [compile_mapping(_(Î¹).omit('if')).Î¹+','+shell(sh`${KB} disable ${Î¹.if}`)] )),
			â€¦(t=mappings.map(compile_mapping).filter(Î¹=>Î¹)._.groupBy('if'), [â€¦_(t).omit('undefined')|>(_.values), t.undefined]).map(Î¹=>M2( 'keyrc '+Î¹[0].if, Î¹.map(.Î¹).reverse(), Î¹[0].if )),
			],
		vkopenurldef: _(shells).map((name,Î¹)â‡’ {name, url:{'@type':'shell', '#text':Î¹}}),
		appdef: _(appdefs).map((Î¹,k)â‡’ {appname:k, equal:Î¹}),
		}} }

################################################################################
regen â† (opt={})=>{
	Î¹ â† show_private_xml([â€¦parse_keyrc(Ï†`~/.keyrc`.text), â€¦_(Ï†`~/.keyrc.json`.json||{}).values()])
	Ï†`~/Library/Application Support/Karabiner/private.xml`.Î¹ = Î¹ # file:/~/Library/Application%20Support/Karabiner/private.xml
	sháµ¥`${KB} reloadxml`
	if( !opt.minimal ){
		Î¹.root.item.map(.name).filter(Î¹=> !Î¹.re`^notsave\.`).map(Î¹=> sháµ¥`${KB} enable ${Î¹}`)
		# if( Ï†`/Applications/PowerKey.app`.âˆƒ ){ Ï†`~/Documents/keyrc_power_key.sh`.text = '#!/bin/bash\n'+sh`(/usr/local/bin/Î¶Î» ${"say`âš™`"} &); ${KB} enable notsave.power_key`; node.fs.chmodSync(Ï†`~/Documents/keyrc_power_key.sh`+'',0o777) }		
		} }

##################################### main #####################################
# i think this was being affected by the Î¶.if_main_do bug and is now okay
# module.if_main_do((â€¦a)=>{
# switch( a[0] ){
# 	default:
# 		npm`chokidar@2.0.0`.watch(Ï†`~/.keyrc`+'').on('all',(ev,Î¹)=>{
# 			try{ regen() }catch(e){ _alert('[keyrc] build error:',e.stack) }
# 			})
# 	break; case 'start':
# 		require('set-input-source')(__dirname+'/node_modules/unicode-hex-input-fix')
# 		restart_and_keep_alive(__filename)
# 	break; case 'test':
# 		console.log(parse_keyrc(Ï†(a[1]).text))
# 	} })

################################################################################
module.exports.KEY_once = Î»(trigger,f,â€¦a){
	code â† '('+f+')(â€¦'+JSON.stringify(a)+')'
	fi â† 'notsave.KEY_once_'+ğŸ²id(9)
	db â† (Ï†`~/.keyrc.json`.json||{}); id â† ğŸ²id(9); db[id] = {trigger,output:'; t â† Ï†`~/.keyrc.json`.json; delete t["'+id+'"]; Ï†`~/.keyrc.json`.json = t;'+code,if:fi}; Ï†`~/.keyrc.json`.json = db
	regen({minimal:âœ“})
	sháµ¥`${KB} enable ${fi}`
	}
module.exports.robot_key_tap = Î»(Î¹){tâ†; câ†;
	Î¹ = Î¹.replace(/^[âŒ˜^â‡§âŒ¥]*(?=.)/,Î¹=>(c=Î¹,''))
	;[â€¦c].âˆª([]).â€–===c.â€– || â€½
	if ((t=Î¹.re`^FnF([1-4])$`) && (t[1]==='1'||t[1]==='2'? c.â€– : âœ“)){
		c = _(c).map(Î¹â‡’ {'âŒ˜':'command', '^':'control', 'â‡§':'shift', 'âŒ¥':'option'}[Î¹]+' down')
		osaáµ¥`system events: key code ${[âˆ…,0x6b,0x71,0xa0,0x83][t[1]]} using {â€¦${c.join(',')}}`
		}
	else {
		c = _(c).map(Î¹â‡’ {'âŒ˜':'command', '^':'control', 'â‡§':'shift', 'âŒ¥':'alt'}[Î¹])
		Î¹ = text_keys.includes(Î¹)? Î¹ : { '^':'control', F1:'f1', F2:'f2', F3:'f3', F4:'f4', F5:'f5', F6:'f6', F7:'f7', F8:'f8', F9:'f9', Fa:'f10', Fb:'f11', Fc:'f12', FnF1:'lights_mon_down', FnF2:'lights_mon_up', FnF5:'lights_kbd_down', FnF6:'lights_kbd_up', FnF7:'audio_prev', FnF8:'audio_pause', FnF9:'audio_next', FnFa:'audio_mute', FnFb:'audio_vol_down', FnFc:'audio_vol_up', 'â†':'left', 'â†‘':'up', 'â†’':'right', 'â†“':'down', 'â†©':'enter', 'â‡¥':'tab', 'â‡§':'shift', 'âŒ¥':'alt', 'âŒ˜':'command', 'âŒ«':'backspace', 'â‹':'escape', 'â£':'space', }[Î¹] || â€½
		# hurrah, .typeString works now! if you want to use it
		npm`robotjs_head_2017-12-01@0.4.8`.keyTap(Î¹,c) } }

# mild todo:
# right command is maybe problematic
# if desired, more than just KeyToKey and SimultaneousKeyPresses: https://github.com/tekezo/Karabiner/tree/master/src/core/kext/RemapFunc
# 2d regexes would be wonderful for parsing .keyrc
# remap the keyboard brightness keys to sync up with the main brightness keys, and then you can reuse the keyboard brightness keys

# todo: append ',KeyCode::VK_NONE' to the end of an autogen entry to make it Ã— even if it's a VK_OPEN_URL_*

# https://github.com/beardedspice/beardedspice/tree/master/BeardedSpice/Tabs
# https://github.com/beardedspice/beardedspice/tree/master/BeardedSpice/MediaStrategies
# âŒ˜ + F8	Set Focused Browser tab as Active Player (effectively directing your commands to that tab)
# âŒ˜ + F6	Focus Active Player (Shows the tab currently controlled by BeardedSpice)
# âŒ˜ + F11	Show Track information (shows a notification with info about the currently playing tab)

# faster applescript http://stackoverflow.com/a/3757178/322866 ? or with background python program, i dont care really

# ! wtf is it needing to be build *twice* before changes happen?

# could be useful: Split the window however you like! Create new panes, delete panes, move and clone views from pane to pane. http://github.com/SublimeText/Origami

########### inject into Î¶/it ###########
# E.robot_key_tap = Î¹=> require_new(Ï†`~/code/scratch/keyrc/it.Î¶`).robot_key_tap(Î¹)
# E.KEY_once = (â€¦a)=> require_new(Ï†`~/code/scratch/keyrc/it.Î¶`).KEY_once(â€¦a)
