#!/usr/bin/env Î¶
# config: os_daemon(Ï†`~/code/scratch/Ï†_Î”_archive.Î¶`).restart()

# notify('Ï†_Î”_archive start')

#################################### prelude ###################################
Î”_as â† (s,f)=>{tâ†;Î¹â†; last â† @device0('watcher_'+simple_hash([s,f])); if(!( last.Î¹===(t= (Î¹=s())|>(f)|>(simple_hash2)) )){ last.Î¹ = t; â†© Î¹ } }

################################## Ï†_Î”_archive #################################

# ! slowing down machine ?
# # this is not quite right. like, the thing we're pretending to be is a giant stream of all filesystem events. filtering through that by a filesystem set selector is outside the scope of EventEmitter.
# # it probably ought to be using reactive programming?

# # huh, we could/should implement it as a library that logs all (requested) filesystem events whether or not its caller is running ?
# # that would require reliable long-running processes

# log2 â† (â€¦a)=> Ï†`/tmp/log.Ï†_Î”_archive`.text += a.join(' ')+'\n'

# fsÊ· â† new node.EventEmitter().on('newListener',Î»(fl,f){
# 	if (fl !== (fl=Ï†(fl)+'')){ fsÊ·.on(fl,f); process.nextTick(=> fsÊ·.removeListener(fl,f) ); â†© }
# 	fsÊ·._events[fl] || npm`chokidar@2.0.0`.watch(fl,{ ,ignoreInitial:âœ“ ,alwaysStat:âœ“ })
# 		.on('error',Î»(Î¹){ console.error('[fs_watch] wat '+Î¹) })
# 		.on('all',Î»(ev,Î¹,stat){ t â† {'addDir':'add','unlinkDir':'unlink'}; type â† t[ev]||ev; fsÊ·.emit(fl, Î¹, {type, dir: !!t[ev], stat, time: type==='unlink'? new Date() : stat.ctime}) })
# 	})

# Ï†.cwd = Ï†`~/file/notes`
# fsÊ·.on('.',(fl,{type,dir,time})=>{ if( dir || fl.re`(^|/)\.archive(/|$)` || fl.re`\.(?:gif|jpg|mov|mp3|mp4|pages|pdf|png|wav)$` ) â†©
# 	log2( ,time.ymdhmss,'#note',type.padEnd(6),fl )
# 	# ! ? Ï†l â† Ï†(fl,{exists:type!=='unlink'}); Ï†`.archive/${time.ymdhmss} ${Ï†l.exists?'=':'X'} ${fl}`.buf = Ï†l.buf
# 	Ï†`.archive/â€¦${fl==='.auto/Local/Auto Save Session.sublime_session' && '.sublime/'}${time.ymdhmss} ${type==='unlink'?'X':'='} ${fl}`.buf = type==='unlink'? '' : Ï†(fl).buf
# 	})

# # bug: this only gets subfiles if they were new since the last version *and* their folders were not



# this is pretty fucked up

# ########## so let's add another fucked up bit, and watch for doi files #########
# E.has_doi = Ï†Î¹=>{
# 	is_doi â† re`(doi:|doi\.org/) *â€¦${npm`doi-regex@0.1.4`().source}`.i
# 	â†© Î ((yes,no)=> !Ï†Î¹.match(/\.pdf$/i)? yes(âœ—) : npm`textract@2.1.1`.fromFileWithPath(Ï†Î¹,(e,Î¹)=> e? no(e) : yes(is_doi.test(Î¹)) ) ) }
# npm`chokidar@2.0.0`.watch(Ï†`~/Downloads`+'',{depth:0,alwaysStat:âœ“}).on('all',Î»(ev,Î¹){
# 	if (Ï†(Î¹).Ï†`..`+''===Ï†`~/Downloads`+'') {
# 		has_doi(Î¹).then(t=>{ if (t) {
# 			hsáµ¥`hs.alert(${'moving paper '+Ï†(Î¹).name+' to mendeley'})`
# 			node.fs.rename(Î¹,Ï†`~/Documents/Mendeley Desktop/${Ï†(Î¹).name}`+'')
# 			} })
# 		} })

############# so let's add another fucked up bit, and kill DS_Store ############
npm`chokidar@2.0.0`.watch(Ï†`~/Downloads`+'',{depth:0,alwaysStat:âœ“}).on('all',Î»(ev,Î¹){
	log2( ,Time().ymdhmss,'#DS_Store',Î¹ )
	if (Ï†(Î¹).Ï†`..`+''===Ï†`~/Downloads`+'')
	if (Ï†(Î¹).name === '.DS_Store')
		sháµ¥`rm ${Î¹}`
	})

########################### look at me cron no hands ###########################
;(=>{
	# u â† 'crazyblogging'
	# this will work fine for crazyblogging but Î”_as ... isnt reentrant. #fixme
	u â† 'nihilsupernum'
	page â† `https://${u}.tumblr.com/`
	t â† Î”_as(=> GET_L(page), Î¹=> (Î¹+'').match(re`\b(?:(https?|chrome|chrome-extension)://|(?:file|mailto):)(?:[^\sâ€œâ€"<>]*\([^\sâ€œâ€"<>]*\))?(?:[^\sâ€œâ€"<>]*[^\sâ€œâ€"<>)\]}âŸ©?!,.:;])?`.g) .filter(Î¹=>{ Î¹=npm`urijs@1.18.12`(Î¹); â†© Î¹.hostname()+'/'+Î¹.segment(0)===`${u}.tumblr.com/post` }) )
	if( t ) notify(`Î” tumblr.${u}`).then(=> go_to(page))
	}).every(0.01d)

################################### yahh cron ##################################
;(=>{
	t â† Ï†`~/code/scratch/daily.sh`+''
	node.child_process.spawn(t,{,shell:âœ“,detached:âœ“,stdio:'ignore'}).unref()
	}).every(1.1d)

################################## cronomatron #################################
;(=> Ï†`~/file/pix/â†’ bg laptop`.TMP_children() ) â‰«(Î¹=> ğŸ²(Î¹) |>(imgur_from).then(Î¹=> set_newtab_bg(Î¹.link)))
.every(0.01d)
