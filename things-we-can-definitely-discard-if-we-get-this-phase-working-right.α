//===---------------------===// load.α hack utils //===--------------------===//

//split_symbol ← λ(l,s){r ← [[]]; l.map(λ(v){if (se(v,s)) r.push([]); else r₋₁.push(v)}); return r}
//split_slice ← λ(l){r ← split_symbol(l,':'); r ← [[(is(r₀₀)? r₀₀ : S('0'))]].concat(r[1:]).m_concat(); return r}

//===---------===// "precedence/open/anyfix/operator macros" //===---------===//

ops ← λ(v){v ←! v isa Array? v₀ : v; return v isa Symbol? operatorsᵥ : undefined}
ops1 ← λ(v){t ← ops(v); return t isa Array? err('?!') : t}

/*parse_tyui ← λ(r,op_,rest){
	op ← undefined
	if (op_.right.no) { // last item is full
		if (rest.no || ¬ops1(rest₀)) { // allowed to be at the end
			// [is a last item] [last item is full] [next item is void]: why marvelous, just let the above level handle this end
			return [r,rest]
		} else {
			// [is a last item] [last item is full] [next item is left-wall]: recurse back up to whatever is eating many thing in sequence?
			// [is a last item] [last item is full] [next item is maybe left-wall]: ??? not sure ???
			// [is a last item] [last item is full] [next item is left-eaty]:
			// 	if its left-priority > our right-priority: recurse to next item
			// 	elif its left-priority < our right-priority: recurse upwards
			// 	else: this is that =≠<>≤≥ thingy! or something like it!
			err('y',rest)
		}
	} else { // last item is want
		if (rest.no) { // at the end
			// [is a last item] [last item is want] [next item is void]: oh no, you don''t get your satisfaction! but this is still not a problem.
			err('aa')
		} else if (¬ops1(rest₀)) {
			// [is a last item] [last item is want] [next item is not-an-op]: eat it
			err('x')
		} else {
			err('z')
			// [is a last item] [last item is want] [next item can be left-wall and have lower priority than us]: recurse to next item!
			// [is a last item] [last item is want] [next item is any other op]: error!
		}
	}
}

parse_qwer ← λ(r,last,prec_r,rest){
	op ← undefined
	if (rest.no) { // at the end
		err('a')
	} else if (¬is(last)) { // at the beginning
		if (op←!ops1(rest₀)) { // next is an op
			if (op.left_eat) {
				last ←! S('void')
				err('?? recurse to next, eaty') }
			else err('?? recurse to next, wall')
		} else { // next is not an op
			last ←! rest₀; rest ←! rest[1:]
		}
	} else if (op←!ops1(last)) { // last was an op
		err('b')
	} else { // last is not an op
		if (op←!ops1(rest₀)) { // next is an op
			if (op.left_eat) {
				if (prec_r < op.prec_l) {
					//! okay ... so sometimes operators are arrays, like if they're () or [] etc. this needs to be handled.
					if (rest₀ isa Array) rest₀ ←! operator_expand(rest₀)
					t ← parse_tyui([rest₀,last],op,rest[1:]); last ←! t₀; rest ←! t₁
				} else if (prec_r > op.prec_l) {
					err('5')
				} else {
					err('6')
				}
			} else {
				err('1')
			}
		} else { // next is not an op
			r.push(last); last ←! rest₀; rest ←! rest[1:]
		}
	}
	return [last,rest]}*/
/*
parse_ooo ← λ(r,last,prec_r,rest){
	t ← undefined
	if (is(last)) { // [last item is full]
		if (rest.no) err('‽b') // [last item is full] [next item is void]: why marvelous, just let the above level handle this end
		else {
			if (t←!left_wall(rest₀)) {
				// [last item is full] [next item is left-wall]: recurse back up to whatever is eating many thing in sequence?
				// [last item is full] [next item is maybe left-wall]: ??? not sure ???
				if (t is an op) {
					?recurse to t?
				} else {
					last ←! t; rest ←! rest[1:]
				}
			} else {
				// [last item is full] [next item is left-eaty]: if its left-priority > our right-priority: recurse to next item; elif its left-priority < our right-priority: recurse upwards; else: this is that =≠<>≤≥ thingy! or something like it!
				err('d')
			}
		}
	} else { // [void last item]
		if (rest.no) err('‽a')
		else {
			if (t←!left_wall(rest₀)) {
				// [last item is void] [next item is left-wall]: marvelous, no problem, just do whatever the thing that is eating things says
				// [last item is void] [next item is maybe left-wall]: next item is definitely left-wall
				if (t is an op) {
					?recurse to t?
				} else {
					last ←! t; rest ←! rest[1:]
				}
			} else {
				// [last item is void] [next item is left-eaty]: oh my well you don''t get to eat anything then! this is not actually a problem. we can just pass you void/undefined.
				err('f')
			}
		}
	}
}
*/
// [last item is want] [next item is not-an-op]: eat it
// [last item is want] [next item can be left-wall and have lower priority than us]: recurse to next item!
// [last item is want] [next item is any other op]: error!
// [last item is want] [next item is void]: oh no, you don''t get your satisfaction! but this is still not a problem.

// i think we can figure out left-priorities by just going on ahead and recursing to the item. because all of these things are pure! recursing to the item is cheap and stuff.
// so it might be somewhat hard to figure out just what the priority of possibly even the last item is.
// yeah. we didn''t solve the "which operator am i even?" problem.
// alright. let''s leave that there for now and go ahead to implementing this. it looks like we have something actually solid now? i mean ... it''s still kinda just a conceptual prototype. but it looks like a _usable_ one
/*
operator_expand ← λ(group){
	r ← [ops1(group₀)]
	last ← undefined
	rest ← group[1:]
	while (¬rest.no) {t ← parse_ooo(r,last,0,rest); last ←! t₀; rest ←! t₁}
	if (last) r.push(last)
	return r}
*/
/*
operators ← {} // {op_repr:op}
op_ANY ← {} // object, not a dictionary
def_operators ← λ(prec_l,prec_r,ops){
	symbol_set_split ← λ(v){
		t ← v.match(~/^([₋␣])?(.+?)([₋␣])?$/); p ← [t₁||'?',t₃||'?']; n ← t₂
		return {name:n, spaces:λ{_.zip(p,v).every(λ{v₀='?'||v₀=v₁})}, symbols:λ(){me ← this; return ['₋␣','₋␣'].cartesian().map(λ{v.join('')}).filter(λ(v){return me.spaces(v)}).map(λ{new Symbol(me.name,v)})}}}
	ops.map(λ(op){
		op ←! op.match(~/\[.*?\]|..\[|[^\[\]]+/g).map(λ(v){t←0; r ← ((t ←! v₀='[' && v₋₁=']')? v[1:-1] : v).match(~/\.|[^.]+/g); return t?[r]:r}).m_concat()
		op ←! op.map(λ{v isa Array? v.map(λ) : v='.'? op_ANY : v})
		left_eat ← false; if (op₀=op_ANY) {left_eat ←! true; op ←! op[1:]}
		t ← symbol_set_split(op₀); op ←! op[1:]
		;({DOT:['.'], BACKTICK:['`'], SUBSCRIPT:subscript_ops}[t.name]||[t.name]).map(λ(n){
			op ←! op.map(λ{v isa Array? v.map(λ) : v=op_ANY? v : symbol_set_split(v)})
			r ← {prec_l:prec_l, prec_r:prec_r, left_eat:left_eat, op:_.defaults({name:n},t), right:op}
			r.op.symbols().map(λ(v){operatorsᵥ ←! operatorsᵥ? (operatorsᵥ isa Array? operatorsᵥ : [operatorsᵥ]).concat([r]) : r})
			}) }) }
*/
/*
;[	'400 401 .DOT₋. .₋SUBSCRIPT .₋[ .₋(',
	'390 391 ¬₋. -₋.',
	'380 381 .₋*₋. .₋/₋. .₋%₋.',
	'370 371 .₋+₋. .₋-₋.',
	'350 350 .₋=₋. .₋≠₋. .₋<₋. .₋>₋. .₋≤₋. .₋≥₋.',
	'340 341 .₋&₋. .₋|₋.',
	'331 330 .₋?₋.₋:₋.',
	'321 322 .₋+=₋.',
	'323 320 .₋←₋. .₋←!₋.',
	'300 301 `₋. ~₋. ~@₋.',
	'290 291 ¬␣.',
	'280 281 .␣*␣. .␣/␣. .␣%␣.',
	'270 271 .␣+␣. .␣-␣.',
	'260 260 .␣isa␣.',
	'250 250 .␣=␣. .␣≠␣. .␣<␣. .␣>␣. .␣≤␣. .␣≥␣.',
	'240 241 .␣&␣. .␣|␣.',
	'231 230 .₋?␣.␣:␣.',
	'221 222 .␣+=␣.',
	'223 220 .␣←␣. .␣←!␣.',
	'210 211 λ.. if.[:].[,][else.] while.[:]. return[.] try.[,][catch.][,][finally.]',
	'200 201 `␣. ~␣. ~@␣.',
	'100 100 , :'
	]//.map(λ(v){t ← v.split(' '); def_operators(i(t₀),i(t₁),t[2:])})
*/
//===--------------------------===// <edge> //===--------------------------===//

	// a bit outdated:
	// tokenize: characters are tokenized with λ(rest_characters) → [token,rest_characters]
	// anyfix/open macros: was // anyfix: tokens naming anyfix macros are expanded into forms with λ(previous_forms,symbol,rest_tokens) → [previous_forms,rest_tokens], but they are not allowed to eat more than the last form of previous_forms . these functions may be called multiple times, so they should be pure.
	// ?: forms naming macros are expanded into forms
	// ?: forms are translated into javascript

//===---------------------------===// todo //===---------------------------===//

/* PRECEDENCE_TABLE.TXT notes

"is there anything i want to push out despite spacing? check from bottom up (top down)"

a, b + 7, 9

maybe ,
if shouldn''t. if is a statement. if _always_ pushes out, except against ,
v+2 * 7

[] _eats_ tokens without giving them any opportunity to bind to anything

// okay, we've let our thoughts on this percolate for a while. let's see if we can write out the operators in a sensible way.

oh!
eating another left-eating op (probably?) doesn''t change the number of things we''re eating, but another non-left-eating op *does*
so the question is: what gets ops interpreted as functions and what gets ops interpreted as macros?

// http://compilers.iecc.com/comparch/article/01-07-068

parse_expression ()
	return parse_expression_1 (parse_primary (), 0)
parse_expression_1 (lhs, min_precedence)
	while the next token is a binary operator whose precedence is >= min_precedence
		op := next token
		rhs := parse_primary ()
		while the next token is a binary operator whose precedence is greater
				 than op''s, or a right-associative operator
				 whose precedence is equal to op''s
			lookahead := next token
			rhs := parse_expression_1 (rhs, lookahead''s precedence)
		lhs := the result of applying op with operands lhs and rhs
	return lhs
Example execution of the algorithm[edit]
An example execution on the expression 2 + 3 * 4 + 5 == 19 is as follows. We give precedence 0 to equality expressions, 1 to additive expressions, 2 to multiplicative expressions.

parse_expression_1 (lhs = 2, min_precedence = 0)

the next token is +, with precedence 1. the while loop is entered.
op is + (precedence 1)
rhs is 3
the next token is *, with precedence 2. recursive invocation.
parse_expression_1 (rhs = 3, min_precedence = 2)
the next token is *, with precedence 2. the while loop is entered.
op is * (precedence 2)
rhs is 4
the next token is +, with precedence 1. no recursive invocation.
lhs is assigned 3*4 = 12
the next token is +, with precedence 1. the while loop is left.
12 is returned.
the next token is +, with precedence 1. no recursive invocation.
lhs is assigned 2+12 = 14
the next token is +, with precedence 1. the while loop is not left.
op is + (precedence 1)
rhs is 5
the next token is ==, with precedence 0. no recursive invocation.
lhs is assigned 14+5 = 19
the next token is ==, with precedence 0. the while loop is not left.
op is == (precedence 0)
rhs is 19
the next token is end-of-line, which is not an operator. no recursive invocation.
lhs is assigned the result of evaluating 19 == 19, for example 1 (as in the C standard).
the next token is end-of-line, which is not an operator. the while loop is left.
1 is returned.
*/

/*repr_js_trans_infix ← merge_o({'&':'&&','|':'||','isa':'instanceof','=':'===','≠':'!==','≤':'<=','≥':'>='},object_by('. * / % + - < > in && || +='.split(' '),λ{v}))
repr_js ← λ(v,line){rj ← λ{repr_js(v,line)}; mrj ← λ{v.map(rj).join(b||'')}; ln ← λ{(v && v.line && line? '\n'.repeat(λ(v){line₀ += v; return v}(Math.max(0, v.line-line₀))) : '')}
	return ¬is(v)? pr('<gah>',line₀) :
		v.repr_js? v.repr_js(line) :
		v isa Symbol? ln(v) + (v.space_before?' ':'') + (v.v='/'?'÷':v.v='$args'?'Array.prototype.slice.apply(arguments)':v.v) + (v.space_after?' ':'') :
		v isa Array?
			v.no? '()' :
				v₀ isa Symbol? ln(v₀) + (
					v₀.v='__literal__'? v₁+'' :
					//v₀.v='__do__'? v.length=2? rj(v₁) : '{'+mrj(v[1:],';')+'}' :
					v₀.v='__do__e'? '('+rj(v₁)+')' :
					v₀.v='__do__s'? '{'+mrj(v[1:],';')+'}' :
					v₀.v='__get__'? '('+rj(v₁)+'['+rj(v₂)+'])' :
					v₀.v='__sub__'? '('+rj(v₁)+'['+rj(v₂)+'])' :
					v₀.v='__array__'? '['+mrj(v[1:],',')+']' :
					v₀.v='←'? 'var '+rj(v₁)+' = '+rj(v₂) :
					v₀.v='←!'? '('+rj(v₁)+' = '+rj(v₂)+')' :
					v₀.v='¬'? '(!'+rj(v₁)+')' :
					v₀.v='new'? 'new '+rj(v₁).replace(~/^\((.*)\)$/,'$1') :
					v₀.v='return'? 'return '+rj(v₁) : // should be return(…) or return
					v₀.v='throw'? 'throw '+rj(v₁) :
					v₀.v='delete'? 'delete '+rj(v₁) :
					v₀.v='while'? 'while('+rj(v₁)+'){'+rj(v₂)+'}' :
					v₀.v='try'? 'try{'+rj(v₁)+'}catch(e){'+rj(v₂)+'}' :
					v₀.v='λ'? 'function λ('+mrj(v₁,',')+'){'+rj(v₂)+'}' :
					v₀.v='if'? '('+rj(v₁)+'?'+rj(v₂)+':'+rj(v₃)+')' :
					v₀.v='if_s'? 'if('+rj(v₁)+'){'+rj(v₂)+'}'+(¬is(v₃)?'':'else{'+rj(v₃)+'}') :
					v₀.v='-' && v.length=2? '(-('+rj(v₁)+'))' :
					own(repr_js_trans_infix,v₀.v)? '('+rj(v₁)+repr_js_trans_infix[v₀.v]+rj(v₂)+')'  :
						'('+rj(v₀)+'('+mrj(v[1:],',')+'))' ) :
					rj(v₀)+'('+mrj(v[1:],',')+')' :
		typeof(v)='object'? '{'+Object.keys(v).map(λ(k){return rj(k)+':'+rj(vₖ)}).join(',')+'}' :
			'<what:'+v+'>'}
repr_js_file ← λ(form){return repr_js(form, [1])[1: -1].replace(~/ +/mg,' ').replace(~/^ /mg,'').replace(~/;$/m,'')}*/

//===---------------===// probably shit; try to discard //===--------------===//
/*
def_group ← λ(a,b){}
def_precedence ← λ(value,associativity,name){}
def_operators ← λ(precedence,operators){
	def_precedence.apply(null,precedence)
	operators.map(λ(op){

	}) }

;[	['13 → group		\\[…*\\] (…*) {…*} ‹…*›'],
	['12 ← lex-like		/\\d+/\\./\\d+/ ; λ…*<→{> new/.+/'],
	['11 ← tight		\\[ ( { ‹ .\\.. .−\\[ .−( '+subscript_ops.map(λ{'.−'+v}).join(' ')],
	['10 → prefix		¬−. ↔-−.'],
	['9  ← mul			.*. .\\/. .%.'],
	['8  ← add			.+. .-.'],
	['7  ← bitwise		'],
	['6  ← cmp 			.isa. .in. .¬in.'],
	['5  → cmp-chained	.=. .≠. .\\<. .\\>. .≤. .≥.'],
	['4  ← logical		.&. .|.'],
	['3  → if-infix		.?.:.'],
	['2  → statement	.←. .←!. .+=. λ.. if.:?.,?[else.]? while.:?. return.? try.,?[catch.,?]?[finally.]?'],
	['1  → quote		`. ~. ~@.'],
	['0  ← separator	, :']
	].map(λ(v){t ← v.split(~/\t+/); def_operators(t₀.split(/ +/),t₁.split(' '))})

precedences ← {}*/

/*
open_eval ← λ{operators_expand(open_macro_eval(groups_expand(v)))}

groups ← {'(':')','[':']','{':'}','‹':'›'}
open_macros ← {}
operators ← {}
open_macros_set ← λ
operators_add ← λ

groups_expand ← λ(g){r ← group_expand(S('{'),g.concat([S('}')])); if (¬r₁.no) err(); return r₀}
	group_expand ← λ(g,l){
		check ← λ(){if (l.no) err('group is not closed @'+g.line)}
		check()
		r ← [g]; while(true){
			if (se(l₀,groups[g.v])) return [r,l[1:]]
			if (l₀ isa Symbol && own(groups,l₀.v)) {t ← group_expand(l₀,l[1:]); r.push(t₀); l ←! t₁; check(); continue}
			r.push(l₀); l ←! l[1:]; check()}}

open_macro_eval ← λ(v){

}

operators_expand ← λ(v){

}

open_macros_set('λ',λ(forms,sym,tokens){

})
open_macros_set('−.−',λ(forms,sym,tokens){return s_int(forms₋₁) && s_int(tokens₀)? [forms[: -1].concat([s_mk_float(forms₋₁,tokens₀)]),tokens[1:]] : [forms.concat([sym]),tokens]})

anyfix_macros_set('.', λ(forms,sym,tokens){return [forms[: -1].concat([[sym,forms₋₁||err('bad .',forms₋₁,tokens),tokens₀]]),tokens[1:]]})
anyfix_macros_set([';',','], λ(forms,sym,tokens){return [forms,tokens]})
anyfix_macros_set(unicode.subscripts.concat(unicode.subscripts.map(λ{'₋'+v})),
	λ(forms,sym,tokens){return [forms[: -1].concat([[S('__sub__'),forms₋₁,sym.with_v(unicode.midscript(sym.v))]]),tokens]})
anyfix_macros_set('λ', λ(forms,sym,tokens){
	// don't require () ?
	if (tokens₀ isa Array && tokens₀₀.v = '(') {
		p ← tokens₀[1:].filter(λ{¬se(v,',')}); tokens ← tokens[1:]
		// may disrespect precedence
		t ← anyfix_macro_eval_p1([],tokens); b ← t₀₀; tokens ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [forms.concat([[sym,p,b]]),tokens] }
	else if (tokens₀ isa Array && tokens₀₀.v = '{') {
		p ← [S('v'),S('b'),S('c')]
		// may disrespect precedence
		tokens₀₀.v ←! '(' //! gah
		t ← anyfix_macro_eval_p1([],tokens); b ← t₀₀; tokens ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [forms.concat([[sym,p, [S('return')].concat([b])]]),tokens] }
	else return [forms.concat([sym]),tokens] })

--- phase macro ---
group			[] () {} ‹›
special			λ .
--- phase evaluated ---
← tight			[ ( { ‹ ….… …−[ …−( …₀ᵢ // …++ …--
← new			new…
→ prefix		¬−… ↔-−… // ↔+−…
← mul			…*… …/… …%… // % is temporary
← add			…+… …-…
← bitwise
← cmp 			…isa… …in… …¬in…
s cmp-chained	…=… …≠… …<… …>… …≤… …≥…
← logical		…&… …|… // maybe && || and or ?
→ if-infix		…?…:…
→ assignment	…←… …←!… …+=… // temporary hacks, bah -= *= /= &= |=
? separator		…;… …,…
s ?				λ… if…[:]…[else…] while…[:]… return[…] try…[catch…][finally…] // maybe throw ?

groups ← {'(':')','[':']','{':'}','‹':'›'}
group ← λ(g){
	group ← λ(g,l){
		check ← λ(){if (l.no) err('group is not closed @'+g.line)}
		check()
		r ← [g]; while(true){
			if (se(l₀,groups[g.v])) return [r,l[1:]]
			if (l₀ isa Symbol && own(groups,l₀.v)) {t ← group(l₀,l[1:]); r.push(t₀); l ←! t₁; check(); continue}
			r.push(l₀); l ←! l[1:]; check()}}
	r ← group(S('{'),g.concat([S('}')])); if (¬r₁.no) err(); return r₀}

open_macro_eval ← λ{anyfix_macro_eval(group(v))}


anyfix_macros ← {}; anyfix_macros_set ← λ(ss,f){(ss isa Array? ss : [ss]).map(λ(s){symbol_set_decode(s).map(λ(s){
	v ← s.v; s ← s.space
	if (¬is(f)) {if (own(anyfix_macros,v)) {delete(anyfix_macros[v][s]); if (Object.keys(anyfix_macros[v]).no) delete(anyfix_macros[v])}}
	else {if (¬own(anyfix_macros,v)) {anyfix_macros[v] ←! {}} anyfix_macros[v][s] ←! f}
	}) }) }

anyfix_macro_eval ← λ(token){t ← anyfix_macro_eval_form([], [token]); if (¬(t₁.no && t₂.no)) err(); return t₀}
anyfix_macro_eval_l ← λ(tokens){r ← []; while (¬tokens.no) {t ← anyfix_macro_eval_1(r,tokens); r ←! t₀; tokens ←! t₁} return r}
anyfix_macro_eval_form ← λ(buf,tokens,dont){while (¬(buf.length>1 || tokens.no || (¬buf.no && dont && dont(tokens)))) {t ← anyfix_macro_eval_1(buf,tokens); buf ←! t₀; tokens ←! t₁} return [buf₀,buf[1:],tokens]}
anyfix_macro_eval_1 ← λ(forms,tokens){
	v ← tokens₀; tokens ←! tokens[1:]
	if (v isa Array) {t ← ((anyfix_macros[v₀.v]||err(v₀))[v₀.space]||err(v₀,v₀.space))(forms,v₀, [v[1:]].concat(tokens)); forms ←! t₀; tokens ←! t₁}
	else if (v isa Symbol && own(anyfix_macros,v.v) && anyfix_macros[v.v][v.space]) {t ← anyfix_macros[v.v][v.space](forms,v,tokens); forms ←! t₀; tokens ←! t₁}
	else forms.push(v)
	return [forms,tokens]}

anyfix_macro_eval_p1 ← λ(forms,tokens){l ← forms.length; while (¬tokens.no && forms.length < l+1) {t ← anyfix_macro_eval_1(forms,tokens); forms ←! t₀; tokens ←! t₁} return [forms,tokens]}

; (λ(){
	vector ← λ(forms,sym,tokens){tokens₀ ←! anyfix_macro_eval_l(tokens₀); return [forms.concat([(has_sym(tokens₀,':')? [S('__sliceλ__')].concat(split_slice(tokens₀)) :
		[sym.with_v('__array__')].concat(tokens₀))]),tokens[1:]]}
	block ← λ(forms,sym,tokens){return [forms.concat([[S('__do__')].concat(tokens₀)]),tokens[1:]]}
anyfix_macros_set('[', vector)
anyfix_macros_set('−[', λ(forms,sym,tokens){return forms.no? vector([],sym,tokens) : [
	forms[: -1].concat(
		has_sym((tokens₀ ←! anyfix_macro_eval_l(tokens₀)),':')?
			[[S('__slice__'),forms₋₁].concat(split_slice(tokens₀))] :
			[[S('__sub__'),forms₋₁].concat(tokens₀)]
			),tokens[1:]]})
anyfix_macros_set('(',block)
anyfix_macros_set('−(', λ(forms,sym,tokens){return forms.no? block([],sym,tokens) : [forms[: -1].concat([[forms₋₁].concat(anyfix_macro_eval_l(tokens₀))]),tokens[1:]]})
})()
anyfix_macros_set('{', λ(forms,sym,tokens){
	r←undefined
	starts_like_dict ← λ{(v₀ isa Symbol || typeof(v₀)='string') && se(v₁,':')}
	if (starts_like_dict(tokens₀)) {
		r ←! {}; buf ← []; tokens_ ← tokens₀
		while (¬tokens_.no) {if (¬starts_like_dict(tokens_)) {err(tokens_)} t ← anyfix_macro_eval_form(buf,tokens_[2:],starts_like_dict); r[tokens_₀.v||tokens_₀] ←! t₀; buf ←! t₁; tokens_ ← t₂}
		r ←! [r].concat(buf)
		}
	else r ←! [[S('__do__s')].concat(anyfix_macro_eval_l(tokens₀))]
	return [forms.concat(r),tokens[1:]] })
anyfix_macros_set('‹', λ(forms,sym,tokens){err('‹› not implemented')})
anyfix_macros_set('.', λ(forms,sym,tokens){return [forms[: -1].concat([[sym,forms₋₁||err('bad .',forms₋₁,tokens),tokens₀]]),tokens[1:]]})
anyfix_macros_set([';',','], λ(forms,sym,tokens){return [forms,tokens]})
anyfix_macros_set(unicode.subscripts.concat(unicode.subscripts.map(λ{'₋'+v})),
	λ(forms,sym,tokens){return [forms[: -1].concat([[S('__sub__'),forms₋₁,sym.with_v(unicode.midscript(sym.v))]]),tokens]})
anyfix_macros_set('λ', λ(forms,sym,tokens){
	// don't require () ?
	if (tokens₀ isa Array && tokens₀₀.v = '(') {
		p ← tokens₀[1:].filter(λ{¬se(v,',')}); tokens ← tokens[1:]
		// may disrespect precedence
		t ← anyfix_macro_eval_p1([],tokens); b ← t₀₀; tokens ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [forms.concat([[sym,p,b]]),tokens] }
	else if (tokens₀ isa Array && tokens₀₀.v = '{') {
		p ← [S('v'),S('b'),S('c')]
		// may disrespect precedence
		tokens₀₀.v ←! '(' //! gah
		t ← anyfix_macro_eval_p1([],tokens); b ← t₀₀; tokens ← t₁; if (t₀.length ≠ 1) err('bad λ')
		return [forms.concat([[sym,p, [S('return')].concat([b])]]),tokens] }
	else return [forms.concat([sym]),tokens] })
anyfix_macros_gen ← λ(v,to){
	// this is horrifying and needs a good refactoring
	parse ← λ{v.match(~/(\[.*?\])|[^[\]]+/g).map(λ{v₀='['? [parse(v[1: -1])] : v.trim().split(' ')}).m_concat().filter(λ{v ≠ ''})}
	t ← parse(v); first ← t₀='…'; t ← first?t[1:]:t; n ← t₀; vs ← t[1:]
	anyfix_macros_set(n,λ(forms,sym,tokens){
		buf ← []
		r ← [to? sym.with_v(to) : sym]; if (first) r.push(is(forms₋₁)?forms₋₁:err())
		vs.map(λ(v,i){
			if (v='…') {
				dont ← vs[i+1] isa Array && vs[i+1]₀ ≠ '…'? vs[i+1]₀ : undefined
				t ← anyfix_macro_eval_form(buf,tokens,λ{se(v₀,dont)}); r.push(t₀); buf ←! t₁; tokens ←! t₂}
			else if (v isa Array) {
				tokens_ ← tokens
				buf_ ← buf
				r_ ← []
				vs_ ← v
				if (vs_.every(λ(v){
						if (v='…') {
							dont ← vs_[i+1] isa Array && vs_[i+1]₀ ≠ '…'? vs_[i+1]₀ : undefined
							t ← anyfix_macro_eval_form(buf_,tokens_,λ{se(v₀,dont)}); r_.push(t₀); buf_ ←! t₁; tokens_ ←! t₂}
						else {
							if (buf_.no && se(tokens_₀,v))
								tokens_ ←! tokens_[1:]
							else return false
						}
						return true
					})) {
					tokens ←! tokens_
					r ←! r.concat(r_)
					buf ←! buf_
				}
			}
			else err('|'+v+'|')
		})
		return [(first?forms[: -1]:forms).concat([r],buf),tokens]
	}) }
anyfix_macros_gen('if … [:] … [else …]','if_s')
anyfix_macros_gen('… ? … [:] …','if')
anyfix_macros_gen('while … [:] …')
anyfix_macros_gen('return […]') // !!
anyfix_macros_gen('throw …')
anyfix_macros_gen('try … [catch …] [finally …]') // !!
anyfix_macros_gen('new …')
anyfix_macros_gen('¬− …')
anyfix_macros_gen('… isa …')
anyfix_macros_gen('… in …')
anyfix_macros_gen('… ¬in …')
anyfix_macros_gen('… * …')
anyfix_macros_gen('… / …')
anyfix_macros_gen('… % …') //-
anyfix_macros_gen('… + …')
anyfix_macros_gen('… - …')
anyfix_macros_gen('↔-− …') // !!
anyfix_macros_gen('… = …')
anyfix_macros_gen('… ≠ …')
anyfix_macros_gen('… < …')
anyfix_macros_gen('… > …')
anyfix_macros_gen('… ≤ …')
anyfix_macros_gen('… ≥ …')
anyfix_macros_gen('… & …'); anyfix_macros_gen('… && …') //-
anyfix_macros_gen('… | …'); anyfix_macros_gen('… || …') //-
anyfix_macros_gen('… ← …')
anyfix_macros_gen('… ←! …')
anyfix_macros_gen('… += …')
*/